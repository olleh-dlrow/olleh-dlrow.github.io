<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>已知概率密度分布的采样方法</title>
    <link href="/2023/01/10/%E5%B7%B2%E7%9F%A5%E6%A6%82%E7%8E%87%E5%AF%86%E5%BA%A6%E5%88%86%E5%B8%83%E7%9A%84%E9%87%87%E6%A0%B7%E6%96%B9%E6%B3%95/"/>
    <url>/2023/01/10/%E5%B7%B2%E7%9F%A5%E6%A6%82%E7%8E%87%E5%AF%86%E5%BA%A6%E5%88%86%E5%B8%83%E7%9A%84%E9%87%87%E6%A0%B7%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="已知概率密度分布的采样方法"><a href="#已知概率密度分布的采样方法" class="headerlink" title="已知概率密度分布的采样方法"></a>已知概率密度分布的采样方法</h1><h2 id="逆变换法"><a href="#逆变换法" class="headerlink" title="逆变换法"></a>逆变换法</h2><p><a href="https://baike.baidu.com/item/%E5%8F%8D%E5%8F%98%E6%8D%A2%E6%B3%95/9005059">反变换法_百度百科 (baidu.com)</a><br>$$<br>F(X) &#x3D; P(X \leq x), X &#x3D; F^{-1}(U)<br>$$</p><h2 id="拒绝采样"><a href="#拒绝采样" class="headerlink" title="拒绝采样"></a>拒绝采样</h2><p><a href="https://blog.csdn.net/jteng/article/details/54344766">(101条消息) 拒绝采样(reject sampling)原理详解_jteng的博客-CSDN博客_rejection sampling</a></p><p><img src="/2023/01/10/%E5%B7%B2%E7%9F%A5%E6%A6%82%E7%8E%87%E5%AF%86%E5%BA%A6%E5%88%86%E5%B8%83%E7%9A%84%E9%87%87%E6%A0%B7%E6%96%B9%E6%B3%95/image-20220902232805271.png" alt="image-20220902232805271"></p><ol><li>取q(z), kq(z) &gt;&#x3D; p(z)</li><li>从q(z)中采样X</li><li>在[0, 1]中均匀采样U</li><li>如果U &lt;&#x3D; p(z)&#x2F;(kq(z))，取X，否则舍弃</li><li>X中剩下的样本就是根据p(z)采样得到的样本</li></ol><h2 id="重要性采样"><a href="#重要性采样" class="headerlink" title="重要性采样"></a>重要性采样</h2><h2 id="马尔科夫蒙特卡罗采样法"><a href="#马尔科夫蒙特卡罗采样法" class="headerlink" title="马尔科夫蒙特卡罗采样法"></a>马尔科夫蒙特卡罗采样法</h2>]]></content>
    
    
    <categories>
      
      <category>CG</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CG</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最短未排序数组</title>
    <link href="/2023/01/10/%E6%9C%80%E7%9F%AD%E6%9C%AA%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <url>/2023/01/10/%E6%9C%80%E7%9F%AD%E6%9C%AA%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="最短未排序数组"><a href="#最短未排序数组" class="headerlink" title="最短未排序数组"></a>最短未排序数组</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定一个数组，求它的一个子数组的最短长度，使得该数组完成升序排序后，整个数组也达到升序。</p><p><img src="/2023/01/10/%E6%9C%80%E7%9F%AD%E6%9C%AA%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/image-20201124181409087.png" alt="image-20201124181409087"></p><h3 id="方法1：选择排序思想"><a href="#方法1：选择排序思想" class="headerlink" title="方法1：选择排序思想"></a>方法1：选择排序思想</h3><p>模拟选择排序的方法，能够得到每个位置排好序后应该放置的数字，如果这个数字发生了改变，说明这个位置是在所求的子数组内部的，因此通过这种方法能够找到该数组的左边界和右边界，算法复杂度为：时间$O(n^2)$, 空间$O(1)$。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findUnsortedSubarray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> nums.length, r = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; nums.length; j++) &#123;<br>                <span class="hljs-keyword">if</span> (nums[j] &lt; nums[i]) &#123;<br>                    r = Math.max(r, j);<br>                    l = Math.min(l, i);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> r - l &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : r - l + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法2：比对排序数组"><a href="#方法2：比对排序数组" class="headerlink" title="方法2：比对排序数组"></a>方法2：比对排序数组</h3><p>如果有足够大的空间，那么该上面的算法可以直接在排好序之后给每个值一一比对，找出发生改变的位置的左边界和右边界，算法复杂度为：时间$O(n)$， 空间$O(n)$。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findUnsortedSubarray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span>[] snums = nums.clone();<br>        Arrays.sort(snums);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> snums.length, end = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; snums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (snums[i] != nums[i]) &#123;<br>                start = Math.min(start, i);<br>                end = Math.max(end, i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (end - start &gt;= <span class="hljs-number">0</span> ? end - start + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法3：使用栈"><a href="#方法3：使用栈" class="headerlink" title="方法3：使用栈"></a>方法3：使用栈</h3><p>下面两种方法都需要考虑的数字进行了筛选，该问题的核心是找到子数组的左边界和右边界。</p><p>对于左边界而言，在排好序后该位置的数字应该是所有降序区间的数字中最小的那个，因为对于该数字前面的数字，它们的顺序已经是升序，因此不需要进行排列。</p><p>右边界同理，只需要把考察的方向更换一下。</p><p>这个算法的核心是，如果前面的数字大于当前的数字，则入栈，否则将栈中的元素依次弹出，直到放入前面的元素后栈依然是升序的，此时经过处理得到左边界。右边界同理，该算法的复杂度为：时间$O(n)$, 空间$O(n)$。</p><p><img src="/2023/01/10/%E6%9C%80%E7%9F%AD%E6%9C%AA%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/image-20201124182650072.png" alt="image-20201124182650072"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findUnsortedSubarray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Stack &lt; Integer &gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span> &lt; Integer &gt; ();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> nums.length, r = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; nums[stack.peek()] &gt; nums[i])<br>                l = Math.min(l, stack.pop());<br>            stack.push(i);<br>        &#125;<br>        stack.clear();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">while</span> (!stack.isEmpty() &amp;&amp; nums[stack.peek()] &lt; nums[i])<br>                r = Math.max(r, stack.pop());<br>            stack.push(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> r - l &gt; <span class="hljs-number">0</span> ? r - l + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法4：找特殊极值（最优）"><a href="#方法4：找特殊极值（最优）" class="headerlink" title="方法4：找特殊极值（最优）"></a>方法4：找特殊极值（最优）</h3><p>解决问题的核心方法同上，但是不需要使用栈来处理了，因为直接可以直接通过比大小的方式得到左右边界的值。</p><p>复杂度: 时间$O(n)$, 空间$O(1)$。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Solution&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findUnsortedSubarray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] sums)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE, max = Integer.MIN_VALUE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, nd = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(r &gt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(nums[l] &gt;= max)&#123;<br>                max = nums[l];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                nd = l;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(nums[r] &lt;= min)&#123;<br>                min = nums[r];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                st = r;<br>            &#125;<br>            l++;<br>            r--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nd - st + <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最佳CPU任务安排</title>
    <link href="/2023/01/10/%E6%9C%80%E4%BD%B3CPU%E4%BB%BB%E5%8A%A1%E5%AE%89%E6%8E%92/"/>
    <url>/2023/01/10/%E6%9C%80%E4%BD%B3CPU%E4%BB%BB%E5%8A%A1%E5%AE%89%E6%8E%92/</url>
    
    <content type="html"><![CDATA[<h1 id="最佳CPU任务安排"><a href="#最佳CPU任务安排" class="headerlink" title="最佳CPU任务安排"></a>最佳CPU任务安排</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>有一条任务队列，其中每个任务用一个大写的字母表示，CPU在执行任务时，两个相同任务之间的最大间隔最少是一个给定的值n，不同任务之间可以没有空闲（间隔），求CPU执行的最小周期数（每一个空闲也算一个周期）。</p><p><img src="/2023/01/10/%E6%9C%80%E4%BD%B3CPU%E4%BB%BB%E5%8A%A1%E5%AE%89%E6%8E%92/image-20201123095843719.png" alt="image-20201123095843719"></p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ol><li><p>贪心算法O(tasks.length)</p><p> 显然，要想让任务周期最短，数量最多的任务的处理方式是最重要的，当该任务处理完毕后，剩下的任务可以采取插空的方法。比如3A,2B,1C，n&#x3D;2，此时先放A，得到A##A##A，那么实际空闲数等于(Count(A)-1)*n-(Count(tasks)-Count(A))和0中较大的那个。如果有多个最大值，则可以将他们捆绑起来看，比如3A,3B,1C,n&#x3D;2, 则AB#AB#AB-&gt;X#X#X，此时空闲数&#x3D;max(0，(Count(A)-1)*(n-maxCount+1)-(Count(tasks)-Count(A)))，如果n-maxCount+1为负数，则说明空闲已经被挤占完 了，不会影响最终结果。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">leastInterval</span><span class="hljs-params">(<span class="hljs-type">char</span>[] tasks, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span>[] counter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> task : tasks) &#123;<br>        counter[task - <span class="hljs-string">&#x27;A&#x27;</span>]++;<br>        <span class="hljs-keyword">if</span> (max == counter[task - <span class="hljs-string">&#x27;A&#x27;</span>]) &#123;<br>            maxCount++;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (max &lt; counter[task - <span class="hljs-string">&#x27;A&#x27;</span>]) &#123;<br>            max = counter[task - <span class="hljs-string">&#x27;A&#x27;</span>];<br>            maxCount = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> <span class="hljs-variable">partCount</span> <span class="hljs-operator">=</span> max - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">partLength</span> <span class="hljs-operator">=</span> n - (maxCount - <span class="hljs-number">1</span>);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">emptySlots</span> <span class="hljs-operator">=</span> partCount * partLength;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">availableTasks</span> <span class="hljs-operator">=</span> tasks.length - max * maxCount;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">idles</span> <span class="hljs-operator">=</span> Math.max(<span class="hljs-number">0</span>, emptySlots - availableTasks);<br>    <br>    <span class="hljs-keyword">return</span> tasks.length + idles;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>优先队列O(n*tasks.length)</p><p> 先统计每个任务的数目，在安排任务时，依次安排任务数最多的任务，直到所有的任务被安排完。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">leastInterval</span><span class="hljs-params">(<span class="hljs-type">char</span>[] tasks, <span class="hljs-type">int</span> n)</span> &#123;<br>        Map&lt;Character, Integer&gt; counts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Character, Integer&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> t : tasks) &#123;<br>            counts.put(t, counts.getOrDefault(t, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        PriorityQueue&lt;Integer&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;Integer&gt;((a, b) -&gt; b - a);<br>        pq.addAll(counts.values());<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">alltime</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cycle</span> <span class="hljs-operator">=</span> n + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (!pq.isEmpty()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">worktime</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            List&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; cycle; i++) &#123;<br>                <span class="hljs-keyword">if</span> (!pq.isEmpty()) &#123;<br>                    tmp.add(pq.poll());<br>                    worktime++;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> cnt : tmp) &#123;<br>                <span class="hljs-keyword">if</span> (--cnt &gt; <span class="hljs-number">0</span>) &#123;<br>                    pq.offer(cnt);<br>                &#125;<br>            &#125;<br>            alltime += !pq.isEmpty() ? cycle : worktime;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> alltime;<br>    &#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>优先队列</tag>
      
      <tag>贪心算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>组合数</title>
    <link href="/2023/01/10/%E7%BB%84%E5%90%88%E6%95%B0/"/>
    <url>/2023/01/10/%E7%BB%84%E5%90%88%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="组合数"><a href="#组合数" class="headerlink" title="组合数"></a>组合数</h1><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p>给出两个整数n和k, 返回1~n 的所有k 个组合数</p><p>eg:</p><p>n &#x3D; 4, k &#x3D; 2</p><p>answer: [ [2,4], [3,4], [2, 3], [1, 2], [1, 3], [1, 4] ], 共6种情况</p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><h3 id="解法一：DFS"><a href="#解法一：DFS" class="headerlink" title="解法一：DFS"></a>解法一：DFS</h3><p>考虑深度优先算法，先在当前序列中任取一个数字，然后与其后的子序列形成的组合数再进行组合，例如，对于序列1<del>4，当需要求2个数的组合时，先选取一个数为1，然后在2</del>3中再取一个数与其进行组合，得到1,2 1,3 1,4 。再取第一个数为2， 同理得到2,3 2,4 。最后取第一个数为3，得到3,4 。此时剩余的数字的个数小于2（此处只有一个数字4），问题解决。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//k为需要组合的数字的个数，s为需要组合的序列的起点，ans存放结果，tmp临时存放生成的序列</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;ans, vector&lt;<span class="hljs-type">int</span>&gt; tmp)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(k == <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//如果拿取的数字达到要求，将生成序列放入答案中</span><br>        ans.<span class="hljs-built_in">push_back</span>(tmp);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = s; i &lt;= n; i++)&#123;<br>        <span class="hljs-keyword">if</span>(n - i + <span class="hljs-number">1</span> &lt; k)<span class="hljs-keyword">break</span>;<span class="hljs-comment">//如果剩余的数字个数小于还需拿取的数字个数，则该种情况Pass</span><br>        tmp.<span class="hljs-built_in">push_back</span>(i);<br>        <span class="hljs-built_in">DFS</span>(k - <span class="hljs-number">1</span>, i + <span class="hljs-number">1</span>, n, ans, tmp);<span class="hljs-comment">//对剩下的序列进行组合。</span><br>        tmp.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combine</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)&#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    <span class="hljs-built_in">DFS</span>(k, <span class="hljs-number">1</span>, n, ans, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="解法二：动态规划"><a href="#解法二：动态规划" class="headerlink" title="解法二：动态规划"></a>解法二：动态规划</h3><p>先找到所求函数的转移方程，这里用到高中所学的公式：<br>$$<br>C_{N}^{M} &#x3D; C_{N - 1}^{M - 1} + C_{N - 1}^{M}<br>$$<br>意思就是说，要找到N个数的组合数，可以先找到N-1个数中不含N的组合数，再找到N-1个数中含N的组合数。</p><p>此时需要寻找所求n,k之间的关系，我们把两个变量放入二维坐标系中就能比较清楚的看出循环思路，如图：</p><p><img src="/2023/01/10/%E7%BB%84%E5%90%88%E6%95%B0/Combinations.png" alt="comb"></p><p>假设图中紫色的点代表待求的最终关于n和k的组合数，则需要先求出两个绿色点处的组合数，然后让左边点求出的组合数添加上数n后，再和右边点求出的组合数结合起来就是最终结果。以此类推，我们需要求的点为图中红色边框内的所有点，为了使临时存放的值尽可能少，我们可以制定以下策略：</p><p>先从左向右求出n &#x3D; k + b上每个点代表的组合数（内部循环），这样，利用当前斜线上的前一个点和上一条线上相同横坐标的点再求n &#x3D; k + b + 1, n &#x3D; k + b + 2, … , n &#x3D; k + b + a上的点（外层循环），求出的最后一个点即为答案。该算法的时间复杂度为$O(n^2)$, 空间复杂度为$O(n)$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinations</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)&#123;<br>    <span class="hljs-keyword">if</span>(k == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;();<span class="hljs-comment">//k = 0比较特殊，可以拿出来单独讨论</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; *combs = <span class="hljs-keyword">new</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;[k+<span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> startN = <span class="hljs-number">0</span>; <span class="hljs-comment">//外层循环的变量</span><br>    <span class="hljs-type">int</span> increment;  <span class="hljs-comment">//内层循环的变量</span><br>    <span class="hljs-keyword">while</span>(startN &lt;= n - k)&#123;<br>        increment = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(increment &lt;= k)&#123;<br>            <span class="hljs-keyword">if</span>(increment == <span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//k=1，代表从1-n中任取一个值</span><br>                combs[increment].<span class="hljs-built_in">clear</span>();<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= startN + increment; i++)<br>                    combs[increment].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">1</span>, i));<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(increment == startN + increment)&#123;<span class="hljs-comment">//n个数中拿取n个数，组合数为它自身</span><br>                vector&lt;<span class="hljs-type">int</span>&gt; comb;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= increment; i++)&#123;<br>                    comb.<span class="hljs-built_in">push_back</span>(i);<br>                &#125;<br>                combs[increment].<span class="hljs-built_in">push_back</span>(comb);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">int</span> curN = startN + increment;<br>                vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; lastComb = combs[increment - <span class="hljs-number">1</span>];<br>                <span class="hljs-comment">//上个点的组合数再添加上数n</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it = lastComb.<span class="hljs-built_in">begin</span>(); it != lastComb.<span class="hljs-built_in">end</span>(); it++)&#123;<br>                    it-&gt;<span class="hljs-built_in">push_back</span>(curN);<br>                    combs[increment].<span class="hljs-built_in">push_back</span>(*it);<br>                &#125;<br>            &#125;<br>            increment++;<br>        &#125;<br>        startN++;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans = combs[k];<br>    <span class="hljs-keyword">delete</span>[] combs;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DFS</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python常用语法和注意点</title>
    <link href="/2023/01/10/%E8%87%AA%E7%94%A8-python%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E5%92%8C%E6%B3%A8%E6%84%8F%E7%82%B9/"/>
    <url>/2023/01/10/%E8%87%AA%E7%94%A8-python%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%E5%92%8C%E6%B3%A8%E6%84%8F%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="Python常用语法和注意点"><a href="#Python常用语法和注意点" class="headerlink" title="Python常用语法和注意点"></a>Python常用语法和注意点</h1><blockquote><p>自从接触了linux系统以后，觉得相比于学习语言，仍然有很多很多的指令需要记忆，因此我认为把一些重要的，或者比较常用的语法和注意事项记录下来是非常有必要的。以下内容主要目的是方便我以后快速查找一些可能用到的类和函数，同时这也是一个很好的复习机会。</p></blockquote><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>title():首字母大写</p><p>+ :连接字符串</p><p>rstrip():删除开头和结尾多余的空白</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>operator[]:使用下标访问列表中的元素</p><p>list.append():在列表末尾添加元素</p><p>list.insert(0, “ducati”):在列表中插入元素</p><p>del  list[index]:删除某个位置的元素</p><p> val &#x3D; list.pop(index):弹出一个位置元素，可以赋值</p><p>list.remove(val):根据值删除元素</p><p>list.sort():对列表进行永久排序</p><p>sorted(list):对列表进行临时排序</p><p>list.reverse():永久性翻转列表的顺序</p><p>len(list):返回列表长度</p><br><p>for elem in list: 遍历列表</p><p>range(i , j):生成i~j - 1的数字（-1）代表最后一个数字</p><p>list &#x3D; [opt for elem in range(i, j)]: 列表解析</p><p>[i : j]: 使用列表的一部分（前开后闭），也常用来复制列表</p><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>无法修改的列表</p><p>tuple &#x3D; (i, j): 给存储元组的变量赋值（但不能修改变量中的元素）</p><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>dir[key] &#x3D; value ：插入键值对</p><p>del dir[key] : 删除键值对</p><p>for key, val in dir.items(): 遍历键值对</p><p>dir.keys(), dir.values(): 遍历键，值</p><h2 id="输入与while循环"><a href="#输入与while循环" class="headerlink" title="输入与while循环"></a>输入与while循环</h2><p>ans &#x3D; input(fmt): 输入字符串</p><p>while list:当列表不空时循环</p><p>while elem in list: 当某个元素在列表中时循环（删除重复元素）</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>def func(arg1, arg2&#x3D;default) : 设置默认参数</p><p>def func(list[:]) ： 传递形参</p><p>def func(*args) ：传递任意数量的实参</p><p>def func(**dir_args): 传递任意数量的关键字实参</p><p>import pack: 导入整个模块</p><p>from pack import function as alias: 导入特定函数(as 为起别名)</p><p>from pack import * ：从模块中导入所有函数</p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>class ClassName():</p><p>​def _<em>init</em>_  (self, arg1, arg2 …):</p><p>​self.val1 &#x3D; arg1</p><p>​self.val2 &#x3D; arg2</p><p>​…</p><p>​</p><p>​def func1(self):</p><p>​…</p><p>​def func2(self, arg1,…):</p><p>​…</p><p>…</p><p><strong>继承</strong>：</p><p>class FatherClass(SonClass):</p><p>​def _<em>init</em>_ (self, son’s arg…, arg1, …):</p><p>​super()._<em>init</em>_(son’s arg…)</p><p>​self.val1 &#x3D; arg1</p><p>​…</p><p>…</p><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p>with open(filename, “r&#x2F;w&#x2F;a&#x2F;+”) as file_object:</p><p>​# 逐行读取</p><p>​for line in file_object:</p><p>​print (line)</p><p>​# 在with 之外使用</p><p>​lines &#x3D; file_object.readlines()</p><p>​# 写入</p><p>​file_object.wirte(content)</p><p>​…</p><p>for line in lines:</p><p>​print (line.rstrip())</p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自用-linux常用命令(bash+script)</title>
    <link href="/2023/01/10/%E8%87%AA%E7%94%A8-linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4(bash+script)/"/>
    <url>/2023/01/10/%E8%87%AA%E7%94%A8-linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4(bash+script)/</url>
    
    <content type="html"><![CDATA[<h1 id="自用-linux常用命令-bash-script"><a href="#自用-linux常用命令-bash-script" class="headerlink" title="自用-linux常用命令(bash+script)"></a>自用-linux常用命令(bash+script)</h1><blockquote><p>自从接触了linux以后，发现有大量需要记忆的指令，尽管我能够通过man或者info来查询这些指令的信息，但是如果我不知道这些指令的名字也是没有办法的事情，因此这里把一些常用的指令名称记录下来。</p></blockquote><br><h2 id="linux的文件权限与目录配置"><a href="#linux的文件权限与目录配置" class="headerlink" title="linux的文件权限与目录配置"></a>linux的文件权限与目录配置</h2><p>-rw——-  1 shuwen shuwen    29957 8月   2 09:35 .bash_history</p><p>解读：</p><ol><li>代表文件类型，常见的有：[d], [-], [l] (link file), [b] (装置文件里可供储存的接口设备，<em>可随机存取装置</em>，<em>block device</em> ), [c] (装置文件里串行端口设备，如键盘，鼠标，<em>一次性读取装置</em>  <em>character device</em> ) , [s] (数据接口文件 ，资料接口文件 ，<em>sockets</em> ), [p] (数据输送文件 ，<em>FIFO, pip</em> )</li><li>剩下三组分别表示文件拥有者，群组，其他人的权限</li><li>第二栏表示有多少档名连结到此节点（i-node），包括hard-link 和 Sympolic-link</li><li>第三，四栏表示拥有者和群组</li><li>第五栏表示文件容量大小（bytes）</li><li>第六栏表示建档日期或者最近修改日期</li><li>第七栏为档名</li></ol><br><p><strong>更改文件属性与权限</strong></p><p>chgrp, chown, chmod (改变文件权限，SUID, SGID, SBIT等特性)</p><p>eg: chmod u&#x3D;rwx, go&#x3D;rx  .bashrc</p><p>eg: chmod 777 .bashrc</p><p>eg: chmod a+x .bashrc</p><p>note : 区分文件夹和文件的x属性（前者是可工作权限，后者是可执行权限）</p><h2 id="linux文件与目录管理"><a href="#linux文件与目录管理" class="headerlink" title="linux文件与目录管理"></a>linux文件与目录管理</h2><p>cd , pwd , mkdir , rmdir</p><p>$PATH</p><p>cp , rm , mv , rename, </p><p>取得路径的文件名与目录名称：basename , dirname</p><br><p><strong>文件内容查阅</strong></p><p>cat , tac(cat倒过来写，即从最后一行显示), nl(显示并输出行号) , more , less , head, tail , od(以二进制的方式读取文件内容)</p><p><strong>修改文件时间或建置新档</strong></p><p>touch </p><p>mtime: modification time, 文件内容（不是属性或者权限）改变时更新</p><p>ctime: status time, 状态改变（属性或者权限）</p><p>atime: access time, 访问后更新，如cat就能改变</p><p><strong>文件与目录的默认权限与隐藏权限</strong></p><p>chattr, lsattr：改变，查看隐藏权限</p><p>umask: 文件预设权限（显示被剪掉的权限）</p><p><strong>文件特殊权限</strong></p><p>SUID(4): 执行者将暂时具有该程序拥有者的权限，eg: passwd指令执行后，user将暂时拥有root权限，可以修改密码（因为密码文件对外人是不可修改的）。</p><p>SGID(2): 对文件：执行者暂时获得群组的支持；对目录：若user在此目录下拥有w权限，则user建立的文件，其群组与此目录群组相同</p><p>SBIT(1): 只对目录有效，当user具有wx权限，并且在该目录下建立文件或者目录时，仅自己和root才有权力删除该文件(即使对方有w权限也不能删我的文件)</p><blockquote><p>可见，后两个权限可以大大提高群组合作的效率和安全性</p></blockquote><p><strong>观察文件类型</strong></p><p>file</p><p><strong>指令与文件搜寻</strong></p><p>which: 脚本文件名搜寻，（根据PATH环境变量搜寻）</p><p><strong>文件档名搜寻</strong></p><p>whereis</p><p>locate&#x2F;updatedb</p><p>find</p><br><h2 id="vim程序编辑器"><a href="#vim程序编辑器" class="headerlink" title="vim程序编辑器"></a>vim程序编辑器</h2><p>常用快捷键：</p><p>nG: 跳转到第n行</p><p>0, $: 移动到这一行的第1(最后)列。</p><p>&#x2F;word ?word: 向下（上）查找，使用（n ，N上下查询）</p><p>:n1, n2 s&#x2F;word1&#x2F;word2&#x2F;g(c): 在两行之间寻找并替代字符串，加c确认</p><p>ndd: 删除向下n行</p><p>dG: 删除到最后一行的所有数据（d1G: 到第一行）</p><p>d$: 删到这行最后一个字符(d0: … )</p><p>nyy: 复制几行</p><p>y1G, yG, y0, y$: 同理dd</p><p>p, P: 粘贴在下（上）一行</p><p>u: 撤销</p><p>ctrl + r: 重复上个动作(等价于按键[<strong>.</strong>])</p><p>a, i, o(A, I, O): 都是插入</p><p>r, R: 小写取代一次，大写进入取代模式，esc退出</p><br><p>:w ! 强制保存</p><p>:w filename 另存为</p><p>:r filename 将文件内容添加到光标的后面</p><p>:! command 暂时离开vi界面，执行command</p><br><p><strong>区块选择</strong></p><p>v: 字符选择，将光标经过的地方反白选择</p><p>V: 行选择，</p><p>ctrl + v: 区块选择</p><p>y: 复制</p><p>d: 删除</p><p>p: 将刚刚复制的区块粘贴到游标所在处</p><p><strong>多文件编辑</strong></p><p>:n N 编辑下（上）个文件</p><p>:files 列出目前这个vim开启的所有文件</p><p><strong>多窗口功能</strong></p><p>:sp filename 文件分区显示（默认为当前文件）</p><p>ctrl + w + 方向： 上下翻页 </p><p><strong>挑字补全功能</strong></p><p>ctrl + x -&gt; ctrl + n, f, o: 补齐方式：文件的内容文字，文件名，vim内建关键词</p><br><h2 id="BASH相关"><a href="#BASH相关" class="headerlink" title="BASH相关"></a>BASH相关</h2><p>type: 显示指令类型</p><p><strong>变量</strong></p><p>echo : 打印到屏幕，取用变量</p><p>unset: 取消设定变量</p><p>env: 观察环境变量</p><p>set: 观察所有变量</p><p>$: shell 的PID变量</p><p>?: 上一个指令的回传值变量</p><p>export: 自定义变量转环境变量</p><p>locale: 影响显示结果的语系变量</p><p>read: 读取变量</p><p>declare&#x2F;typeset: 宣告变量类型</p><p>ulimit: 与文件系统及程序的限制关系（可以查看栈空间大小）</p><p><strong>变量的删除、取代和替换</strong></p><p>echo ${path#&#x2F;*local&#x2F;bin:} : 从变量最前面开始向右删除，并且删除最短的那个</p><p>eg: &#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;sbin:&#x2F;bin:&#x2F;usr&#x2F;games:&#x2F;usr&#x2F;local&#x2F;games:&#x2F;snap&#x2F;bin</p><p>变成 <del>&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:</del>&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;sbin:&#x2F;bin:&#x2F;usr&#x2F;games:&#x2F;usr&#x2F;local&#x2F;games:&#x2F;snap&#x2F;bin</p><p>echo ${path##&#x2F;*:} : 删除最长的那个</p><p>eg: <del>&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;sbin:&#x2F;bin:&#x2F;usr&#x2F;games:&#x2F;usr&#x2F;local&#x2F;games:</del>&#x2F;snap&#x2F;bin</p><p>echo ${path%:*bin} : 从后向前删除（%，%%规则与上同理）</p><p>echo ${path&#x2F;sbin&#x2F;SBIN} : 取代第一个遇到的</p><p>echo ${path&#x2F;&#x2F;sbin&#x2F;SBIN} : 取代所有</p><blockquote><p>有种憨憨办法，把变量内容输出到一个临时文件里修改，在把它拷贝回来，就不用记这么多指令了，不过，如果要写shell script的话，这些指令还是很有必要记忆的。</p></blockquote><p><strong>变量的测试和内容替换</strong></p><p>username&#x3D;${username:-default} : 如果username为空或者未设定，则设定default，否则设定为username(常和read连用以避免用户输入为空)</p><p>var&#x3D;${str:?expr} : 当str为空或者未设定时，expr输出至stderr，否则var&#x3D;$str</p><p><strong>命名别名设定</strong></p><p>alias, unalias</p><p><strong>历史命令</strong></p><p>history</p><p><strong>终端机环境设定</strong></p><p>stty -a: 显示所有stty参数</p><p>set: 设定整个指令的输出&#x2F;输入环境（eg: set -u 当使用未设定变量时，会显示错误讯息）</p><p>ctrl + C: 终止目前指令</p><p>ctrl + D: 输入结束</p><p>ctrl + S: 暂停屏幕输出</p><p>ctrl + Z: 暂停目前命令</p><p><strong>通配符与特殊符号</strong></p><p>*: 0~无穷多个任意字符</p><p>?: 一定有一个任意字符</p><p>[]: 一定有一个在括号内的字符，eg: [abcd]代表一定有a~d 中的一个</p><p>[-] : 在编码顺序内的所有字符，eg: [0-9]</p><p>[^] : 反向选择，一定无括号内的字符</p><p><strong>数据流重导向</strong></p><p>2&gt;&amp;1 : 将错误信息和正确信息都输出到指定位置并且不会发生混乱</p><p>cat &gt; catfile ：利用cat来建立一个文件的简单流程，ctrl + D 终止</p><p>cat &gt; catfile &lt; ~&#x2F;.bashrc : 将.bashrc中的数据输出到catfile中</p><p>cat &gt; catfile &lt;&lt; “eof” : 将输入信息输出到catfile中，遇到eof 结束</p><p><strong>命令执行的判断依据</strong></p><p>; , &amp;&amp; , || </p><p>| ：管线命令，仅能处理经由前面一个指令传来的正确信息，对standard error没有直接处理的能力。</p><p><strong>撷取命令</strong></p><p>cut : 取出一行信息中想要的</p><p>cut -d ‘分隔符’ -f 分割区间</p><p>cut -c 12-14 取出字符在12-14之间的数据</p><br><p>grep: 分析某一行的信息</p><p><strong>排序命令</strong></p><p>sort: 依据某种方式排序</p><p>sort - t ‘:’ -k 3   以某个区间进行排序</p><br><p>uniq: 将重复资料仅一行显示</p><p>uniq -c 进行计数</p><br><p>wc: 计算文件里的字，行和字符数目</p><p><strong>双向重导向</strong></p><p>tee: 将标准输出到指定文件和屏幕上</p><p>tee [-a] filename (-a 以累加的方式进行)</p><p><strong>字符转换命令</strong></p><p>tr: 删除一段讯息当中的文字，或者进行文字讯息的替换</p><p>tr [-ds] set1 …</p><p>-d : 删除set1字符串</p><p>-s : 替换重复字符串</p><p>eg: 将小写转大写 last | tr ‘[a-z]’ ‘[A-Z]’</p><br><p>col : col -x 将tab转space</p><br><p>join : 处理两个文件，当有相同数据的一行，将他们整合到一起</p><p>eg: </p><p>&#x3D;&#x3D;&gt; &#x2F;etc&#x2F;passwd &lt;&#x3D;&#x3D;<br>root: x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash<br>daemon : x:1:1:daemon:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;sbin&#x2F;nologin<br>bin: x:2:2:bin:&#x2F;bin:&#x2F;usr&#x2F;sbin&#x2F;nologin</p><p>&#x3D;&#x3D;&gt; &#x2F;etc&#x2F;group &lt;&#x3D;&#x3D;<br>root: x:0:<br>daemon: x:1:<br>bin: x:2:</p><p>&gt;&gt; join -t ‘:’ -1 4 &#x2F;etc&#x2F;passwd -2 3 &#x2F;etc&#x2F;group | head -n 3</p><p>join: &#x2F;etc&#x2F;passwd:6: is not sorted: games: x:5:60:games:&#x2F;usr&#x2F;games:&#x2F;usr&#x2F;sbin&#x2F;nologin<br>join: &#x2F;etc&#x2F;group:11: is not sorted: uucp: x:10:<br>0:root: x:0:root:&#x2F;root:&#x2F;bin&#x2F;bash:root: x:<br>1:daemon: x:1:daemon:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;sbin&#x2F;nologin:daemon: x:<br>2:bin: x:2:bin:&#x2F;bin:&#x2F;usr&#x2F;sbin&#x2F;nologin:bin: x:</p><br><p>paste: 将两行贴在一起，中间以tab（默认）分开</p><p>expand: 将tab 转换成space</p><p><strong>分区命令</strong></p><p>split: 将大文件分成小文件</p><p>eg : cd &#x2F;tmp; split -b 300k &#x2F;etc&#x2F;services services</p><p>再合并起来: cat services* &gt;&gt; servicesback</p><p><strong>参数代换</strong></p><p>xargs: 将stdin的资料分割成为args</p><p>eg: 将&#x2F;etc&#x2F;passwd 内的第一栏取出，仅取三行，使用id将每个账号内容显示出来</p><p>cut -d ‘:’ -f 1 &#x2F;etc&#x2F;passwd | head -n 3 | xargs -n 1 id</p><p>eg: 将所有&#x2F;etc&#x2F;passwd内账号都用id查找，但查到sync就结束</p><p>cut -d ‘:’ -f 1 &#x2F;etc&#x2F;passwd | xargs -e ‘sync’ -n 1 id</p><br><h2 id="正规表示法与文件格式化处理"><a href="#正规表示法与文件格式化处理" class="headerlink" title="正规表示法与文件格式化处理"></a>正规表示法与文件格式化处理</h2><p>用途：处理字符串</p><br><p><strong>基础正规表示法字符汇整</strong></p><p>^word : 待搜寻字符串在行首</p><p>word$: … 在行尾</p><p>. : 代表一定有一个任意字符</p><p>: 跳脱符</p><p>* : 重复0到无穷多个前一个字符(任意字符表示为.*)</p><p>[list] : 字符集合，里面列出想要撷取的字符</p><p>eg: a[afl]y -&gt; aay, afy, aly</p><p>[n1-n2] : 列出想要撷取的字符范围</p><p>[^list] : 不想要的</p><p>\{n, m\} : 连续n-m个前一个字符</p><p>eg: grep -n ‘go\{2, 3\}g’ filename 找出含有goo或gooog的行</p><br><p>sed: 将数据进行取代、删除、新增、撷取（倾向于一整行处理）</p><p>eg: sed ‘s&#x2F;要被取代的字符串&#x2F;新的字符串&#x2F;g’</p><br><p><strong>文件的格式化与相关处理</strong></p><p>printf: 格式化打印</p><p>awwk: 一行当中分成数个字段来处理</p><p>eg: 显示last中的账号与ip</p><p>last -n 5 | awk ‘{print $1 “\t” $3}’</p><p>awk内建变量：</p><p>NF: 每一行拥有的字段总数</p><p>NR: 目前awk所处理的是第几行的数据</p><p>FS: 目前的分隔字符，默认空格</p><p>eg: 查阅&#x2F;etc&#x2F;passwd中第三栏小于10的数据，并且列出账号与第三栏</p><p>cat &#x2F;etc&#x2F;passwd | awk ‘BEGIN {FS&#x3D;”:”} $3 &lt; 10 {print $1 “\t” $3}’</p><br><p><strong>文件比对工具</strong></p><p>diff, cmp</p><p>patch: 将旧文件升为新文件，-R可以还原(git 原理)</p><br><h2 id="Shell-Scripts"><a href="#Shell-Scripts" class="headerlink" title="Shell Scripts"></a>Shell Scripts</h2><p>#!&#x2F;bin&#x2F;bash： 声明使用的shell 名称</p><p>var&#x3D;$((运算内容))：进行数值运算的格式</p><p>bash(sh) script: 直接执行方式，会创建一个新的bash 环境来执行脚本内的命令</p><p>source script: 在父程序中执行</p><p><strong>利用test指令的测试功能</strong></p><p>文件类型判断: -e -f -d </p><p>文件权限侦测：-r -w -x -u(SUID) -g(SGID) -k(SBIT) -s(是否为空白文件)</p><p>文件比较：-nt (newer than)file1 比 file2 新 ，-ot(older than) -ef</p><p>整数判定：-eq -ne -gt -lt -ge -le</p><p>判定字符串：-z string , &#x3D;&#x3D; , !&#x3D; ,</p><p>多重条件判定: -a -o !</p><p>[] : 判断符号</p><p>$0, $1, $2 … : args</p><p>$#: 后接的参数个数</p><p>$@: 所有非首个args</p><p>$*: 代表$1c$2c$3c… ，默认c为空格</p><p><strong>条件判断和函数</strong></p><p>if [ .. ] ;then </p><p>elif [ ..  ] ; then</p><p>else</p><p>fi </p><br><p>case $变量名称 in</p><p>“第一个变量内容”)</p><p>​程序段</p><p>​;;</p><p>…</p><p>*) 其他值</p><p>​;;</p><p>esac</p><br><p>function fname() {</p><p>​程序段</p><p>}</p><p><strong>循环</strong></p><p>while []</p><p>do</p><p>…</p><p>done</p><br><p>until []</p><p>do</p><p>…</p><p>done</p><br><p>for var in con1 con2 con3 …</p><p>do</p><p>…</p><p>done</p><p>for((初始值; 限制值; 执行步阶))</p><p>do</p><p>…</p><p>done</p><p>eg: for((i &#x3D; 1; i &lt;&#x3D;${nu} ;i&#x3D;i+1))</p><p>do</p><p>…</p><p>done</p><p><strong>shell script的追踪与debug</strong></p><br><h2 id="硬件，操作系统问题汇总"><a href="#硬件，操作系统问题汇总" class="headerlink" title="硬件，操作系统问题汇总"></a>硬件，操作系统问题汇总</h2><p><strong>CPU：</strong></p><p>CPU的工作频率：内频，外频，倍频，超频</p><ul><li>内频：每秒工作次数</li><li>外频：CPU与外部组件的数据传输速度</li><li>倍频：CPU内部加速工作效能的倍数</li><li>外频*倍频&#x3D;CPU频率速度</li><li>超频：强行提高外频或者倍频</li></ul><p>大概相当于，在一个车间内，零件的运输速度和加工速度相同时效率才能最高，而一般情况下，内频的速度会快很多，因此为了减少时间的浪费，需要主动给外频增加倍数。</p><p>CPU的总线宽度：32,64位</p><p>CPU对主存储器的工作频率 * 位数 &#x3D; CPU从内存中取得的最快带宽</p><p>一般来说，CPU的运算速度是很高的，所以可以一次执行多个任务（多线程），这就仿佛一个人的能力远远大于他需要处理的工作量，这当然是资本家最欣慰的事情。</p><br><p><strong>内存：</strong></p><p>主存储器为动态随机存取内存（DRAM），断电以后数据全部消失</p><p>DDR（双倍数据传送速度）</p><p>多通道设计：增加主存储器的个数以增加宽度</p><p>SRAM(静态随机存取内存)</p><p>L2 cache(第二层快取)</p><p>ROM（只读存储器），用来存放一些非常重要的数据（如开关机必须用到的BIOS，控制着开机时各项硬件参数的取得）</p><p><strong>硬盘与存储设备：</strong></p><p>硬盘：</p><ul><li>扇区（sector）：最小物理存储单位（一维）</li><li>磁道（track）：同一个同心圆的扇区组合成的圆（二维）</li><li>磁柱（cylinder）：所有磁盘盘上面的同一个磁道组成（三维）</li></ul><p>磁盘与主板的传输界面：</p><ul><li>SATA界面</li><li>SAS界面：串行式SCSI，拥有更快的接口速度，SAS硬盘的磁盘盘转速与传输速度也比SATA好，但是价格贵。</li><li>USB界面</li></ul><p>固态硬盘（SSD）：</p><p>区别于传统的机械磁盘（HDD），没有马达不需要转动，而是通过内存直接读写</p><p>CMOS与BIOS：</p><p>CMOS：记录主板上面的重要参数</p><p>BIOS：写入到主板上的某一块flash挥着EEPROM的程序，它可以在开机的时候执行，加载CMOS当中的数据。</p><p><strong>操作系统：</strong></p><p>通常由核心和系统呼叫接口组成，其中核心将硬件联系起来，不同的硬件需要设计不同的核心，而用户又通过接口来运作核心，核心调度硬件进行数据的存储和运算。不同的操作系统有不同的开发接口，因此针对其开发的应用程序也是专一性的。</p><p>核心功能：</p><p>系统呼叫接口：方便程序开发者与核心沟通。</p><p>程序管理：CPU安排任务的运作顺序</p><p>内存管理：分配，释放内存</p><p>文件系统管理：如数据的I&#x2F;O工作，不同文件格式的支持</p><p>装置驱动：由核心管理。</p><br><h2 id="Linux磁盘与文件系统管理"><a href="#Linux磁盘与文件系统管理" class="headerlink" title="Linux磁盘与文件系统管理"></a>Linux磁盘与文件系统管理</h2><p><strong>文件系统</strong>Ext2&#x2F;3&#x2F;4:</p><p>superblock: 记录filesystem 的整体信息，包括inode&#x2F;block的总量，使用量，剩余量，以及文件系统的格式和相关信息。</p><p>inode: 记录文件的属性和block号码（在一个filesystem下，一个文件对应一个inode）</p><p>block: 实际记录文件内容，文件太大时会占用多个block，一个block只能最多放置一个文件的数据</p><p>格式化以后，inode和block的编号和空间就不再发生改变。</p><p><strong>数据读取方式</strong>：</p><ul><li>索引式文件系统：inode直接记录下block的号码，能够实现快速查找</li><li>FAT文件系统（FAT是win的一种filesystem): 通过链表的方式记录block的位置，类似于1-&gt;7-&gt;4-&gt;15，因此如果数据太离散，磁盘可能需要转很多圈才能读取到文件的全部数据。</li></ul><br><p>inode table:</p><ul><li><p>该文件的存取模式（rwx）</p></li><li><p>该文件的拥有者和群组（owner&#x2F;group）</p></li><li><p>该文件的容量</p></li><li><p>该文件建立和状态改变的时间（ctime），最近一次读取时间（atime），修改时间（mtime）</p></li><li><p>该文件真正内容的指向（pointer）</p></li></ul><p>如果文件太大，inode存不下所有block的编号（inode只有128bytes), 就会间接拿一个block来记录</p><br><p>dumpe2fs： 查询Ext家族superblock信息的指令</p><p>Usage: dumpe2fs [-bh] device_name</p><br><p>缓存快取：有些文件经常读取，可以放在内存的缓冲区中</p><p>目录树：建立目录时，文件系统会分配一个inode与至少一块block给该目录，而该block中会记录文件的inode</p><p>挂载：将文件系统与目录树结合，即设定挂载点一定是目录，该目录为文件系统的入口</p><p>VFS（Virtual Filesystem Switch）: 用来管理所有的文件系统</p><p>示意：</p><p>user process -&gt; (kernel)systemcall -&gt; VFS-&gt; XFS,DOS,Ext4…filesystem -&gt;缓存快取-&gt;驱动程序-&gt;磁盘装置控制器</p><p><strong>文件系统的简单操作</strong>：</p><p>df: 列出文件系统的整体磁盘使用量</p><p>du: 评估文件系统的磁盘使用量（常用在推测目录所占用容量）</p><p><strong>实体链接与符号链接：ln</strong></p><p>hard link: 实体链接，多个档名对应到同一个inode号码，因此可以使用不同的名称访问到相同的存储空间，即使不小心将档名删除了，inode和block还是存在的。不能跨filesystem, 不能link目录。</p><p>Symbolic Link: 快捷方式，如果删除原档名此文件将失效！</p><p>ln: ln [-sf] source goal </p><p>-s symbolic link</p><p>-f 如果目标文件存在，就主动将目标文件移除后再建立</p><p>当新建一个目录时，新的目录link数为2（dir&#x2F;, dir&#x2F;.), 上层目录的link数会增加1(dir&#x2F;..), 这就是为什么总能回到上级目录。</p><p><strong>磁盘的分区、格式化、检验与挂载</strong>：略过，需要的时候再baidu，常用指令：gdisk, fdisk, mkfs, mount</p><br><p>Ext4文件系统主要有：boot sector, superblock, inode bitmap, block bitmap, inode table, date block</p><p>文件block记录文件实际数据，目录的block则爱记录该目录底下文件名与其inode号码对照表</p><p>日志文件系统会多处一块记录区，随时记载文件系统的主要活动，可加快系统复原时间</p><br><h2 id="压缩，打包"><a href="#压缩，打包" class="headerlink" title="压缩，打包"></a>压缩，打包</h2><p>常见扩展名：*.tar, *.tar.gz, *.tgz, *.gz, *Z, *bz2, *xz</p><p>tar: 将多个文件打包成一个文件，便于压缩</p><h2 id="账号管理-与ACL权限设定"><a href="#账号管理-与ACL权限设定" class="headerlink" title="账号管理 与ACL权限设定"></a>账号管理 与ACL权限设定</h2><p>UID: User ID</p><p>GID: Group ID</p><p><strong>&#x2F;etc&#x2F;passwd</strong>:</p><p>每行代表一个账号，结构如下：</p><p><strong>root</strong>: x :<strong>​1</strong>:<strong>1</strong>: root : <strong>&#x2F;root</strong> : <strong>&#x2F;bin&#x2F;bash</strong></p><ol><li>账号名称</li><li>代表密码，放在shadow中</li><li>UID: 0(管理员)，1<del>999(系统账号)(1</del>200:由distributions自行建立的系统账号, 201<del>999: 若用户有系统账号需求时，可以使用的账号UID)，1000</del>60000(给一般使用者使用)</li><li>GID: 同UID</li><li>用户信息说明栏（使用finger时有用）</li><li>家目录</li><li>Shell</li></ol><br><p><strong>&#x2F;etc&#x2F;shadow</strong>:</p><p>root : $6$wtb… … YLP3fsF3t : 16559 : 0 : 99999 : 7 :::</p><ol><li>账号名称</li><li>密码（加密）</li><li>最近更动密码的日期（以1970.1.1为1往上累加日期，如1971.1.1 为366）</li><li>密码不可被更动的天数（与第3字段相比）：0表示随时可以更改</li><li>密码需要重新变更的天数（与第3字段相比）：99999（273年）表示除非你是DIO,否则不必强制更改:)</li><li>密码需要变更期限前的警告天数（与第5字段相比）：prompt:再过n天密码就要过期了，请尽快重置密码！</li><li>密码过期后的账号宽限时间（密码失效日）（与第5字段相比）：一般情况下，密码过期后系统会强制重设密码，但失效后就 再也无法登陆了</li><li>账号失效日期：使用自1970年来的总日数设定，在此日期之后，将无法使用。</li><li>保留功能</li></ol><p><strong>&#x2F;etc&#x2F;group</strong>:</p><p>root : x : 0 :</p><ol><li>组名</li><li>群组密码（放在gshadow中，没什么卵用）</li><li>GID</li><li>此群组支持的账号名称，eg: root : x : 0 : dmtsai, alex</li></ol><br><p>初始群组：默认为与账号名称相同的群组</p><p>有效群组：新建文件或者目录时赋予的群组</p><p>groups: 查看当前账号所属的群组，第一个为有效群组</p><p>newgrp: 有效群组的切换，eg: newgrp users, 但只能切换为支持你的群组</p><br><p><strong>&#x2F;etc&#x2F;gshadow</strong>:</p><p>root:::</p><ol><li>组名</li><li>密码栏，为空或!表示无合法密码，无群组管理员</li><li>群组管理员账号</li><li>有加入该群组支持的所属账号（与&#x2F;etc&#x2F;group相同）</li></ol><br><p><strong>账号管理</strong></p><p>useradd : 添加账号，默认直接添加输入的用户名</p><p>useradd参考档：&#x2F;etc&#x2F;default&#x2F;useradd, &#x2F;etc&#x2F;login.defs, &#x2F;etc&#x2F;skel&#x2F;*</p><p>passwd: 为特定用户修改密码</p><p>chage: 详细的密码参数显示功能，显示最近修改日期，失效日期等等</p><p>usermod: 修改账号信息（类似于useradd）</p><p>userdel: 删除用户数据</p><br><p>id: 查询某人或自己的相关UID&#x2F;GID等等的信息</p><p>finger: 查询&#x2F;etc&#x2F;passwd文件内的信息</p><p>chsh: 改变shell</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>vim</tag>
      
      <tag>bash</tag>
      
      <tag>script</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#--装箱和拆箱</title>
    <link href="/2023/01/10/%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1/"/>
    <url>/2023/01/10/%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1/</url>
    
    <content type="html"><![CDATA[<h1 id="C-——-装箱和拆箱"><a href="#C-——-装箱和拆箱" class="headerlink" title="C# —— 装箱和拆箱"></a>C# —— 装箱和拆箱</h1><p>1、装箱和拆箱是一个抽象的概念<br>2、装箱是将值类型转换为引用类型 ；拆箱是将引用类型转换为值类型<br>利用装箱和拆箱功能，可通过允许值类型的任何值与Object 类型的值相互转换，将值类型与引用类型链接起来<br>例如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span> val = <span class="hljs-number">100</span>;<br><span class="hljs-built_in">object</span> obj = val;<br>Console.WriteLine (“对象的值 = &#123;<span class="hljs-number">0</span>&#125;<span class="hljs-string">&quot;, obj);</span><br></code></pre></td></tr></table></figure><p>这是一个装箱的过程，是将值类型转换为引用类型的过程</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span> val = <span class="hljs-number">100</span>;<br><span class="hljs-built_in">object</span> obj = val;<br><span class="hljs-built_in">int</span> num = (<span class="hljs-built_in">int</span>) obj;<br>Console.WriteLine (<span class="hljs-string">&quot;num: &#123;0&#125;&quot;</span>, num);<br></code></pre></td></tr></table></figure><p>这是一个拆箱的过程，是将值类型转换为引用类型，再由引用类型转换为值类型的过程</p><p>注：被装过箱的对象才能被拆箱<br>3、.NET中，数据类型划分为值类型和引用(不等同于C++的指针)类型，与此对应，内存分配被分成了两种方式，一为栈，二为堆，注意：是托管堆。<br>   值类型只会在栈中分配。<br>   引用类型分配内存与托管堆。<br>   托管堆对应于垃圾回收。</p><p>**4：装箱&#x2F;拆箱是什么？<br>**装箱：用于在垃圾回收堆中存储值类型。装箱是值类型到 object 类型或到此值类型所实现的任何接口类型的隐式转换。<br>拆箱：从 object 类型到值类型或从接口类型到实现该接口的值类型的显式转换。</p><p>**5：为何需要装箱？(为何要将值类型转为引用类型？)<br>**一种最普通的场景是，调用一个含类型为Object的参数的方法，该Object可支持任意为型，以便通用。当你需要将一个值类型(如Int32)传入时，需要装箱。<br>另一种用法是，一个非泛型的容器，同样是为了保证通用，而将元素类型定义为Object。于是，要将值类型数据加入容器时，需要装箱。</p><p>**6：装箱&#x2F;拆箱的内部操作。<br>**装箱：<br>对值类型在堆中分配一个对象实例，并将该值复制到新的对象中。按三步进行。<br>第一步：新分配托管堆内存(大小为值类型实例大小加上一个方法表指针和一个SyncBlockIndex)。<br>第二步：将值类型的实例字段拷贝到新分配的内存中。<br>第三步：返回托管堆中新分配对象的地址。这个地址就是一个指向对象的引用了。<br>有人这样理解：如果将Int32装箱，返回的地址，指向的就是一个Int32。我认为也不是不能这样理解，但这确实又有问题，一来它不全面，二来指向Int32并没说出它的实质(在托管堆中)。<br>拆箱：<br>检查对象实例，确保它是给定值类型的一个装箱值。将该值从实例复制到值类型变量中。<br>有书上讲，拆箱只是获取引用对象中指向值类型部分的指针，而内容拷贝则是赋值语句之触发。我觉得这并不要紧。最关键的是检查对象实例的本质，拆箱和装箱的类型必需匹配，这一点上，在IL层上，看不出原理何在，我的猜测，或许是调用了类似GetType之类的方法来取出类型进行匹配(因为需要严格匹配)。</p><p>**7：装箱&#x2F;拆箱对执行效率的影响<br>**显然，从原理上可以看出，装箱时，生成的是全新的引用对象，这会有时间损耗，也就是造成效率降低。<br>那该如何做呢？<br>首先，应该尽量避免装箱。<br>比如上例2的两种情况，都可以避免，在第一种情况下，可以通过重载函数来避免。第二种情况，则可以通过泛型来避免。<br>当然，凡事并不能绝对，假设你想改造的代码为第三方程序集，你无法更改，那你只能是装箱了。<br>对于装箱&#x2F;拆箱代码的优化，由于C#中对装箱和拆箱都是隐式的，所以，根本的方法是对代码进行分析，而分析最直接的方式是了解原理结何查看反编译的IL代码。比如：在循环体中可能存在多余的装箱，你可以简单采用提前装箱方式进行优化。</p><p>**8：对装箱&#x2F;拆箱更进一步的了解<br>**装箱&#x2F;拆箱并不如上面所讲那么简单明了，比如：装箱时，变为引用对象，会多出一个方法表指针，这会有何用处呢？<br>我们可以通过示例来进一步探讨。<br>举个例子。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c#">Struct A : ICloneable<br>&#123;<br><span class="hljs-keyword">public</span> Int32 x;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> String <span class="hljs-title">ToString</span>()</span> &#123;<br><span class="hljs-keyword">return</span> String.Format(”&#123;<span class="hljs-number">0</span>&#125;”,x);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">object</span> <span class="hljs-title">Clone</span>()</span> &#123;<br><span class="hljs-keyword">return</span> MemberwiseClone();<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>()</span><br>&#123;<br>A a;<br>a.x = <span class="hljs-number">100</span>;<br>Console.WriteLine(a.ToString());<br>Console.WriteLine(a.GetType());<br>A a2 = (A)a.Clone();<br>ICloneable c = a2;<br>Ojbect o = c.Clone();<br>&#125;<br></code></pre></td></tr></table></figure><p>5.0：a.ToString()。编译器发现A重写了ToString方法，会直接调用ToString的指令。因为A是值类型，编译器不会出现多态行为。因此，直接调用，不装箱。(注：ToString是A的基类System.ValueType的方法)<br>5.1：a.GetType()，GetType是继承于System.ValueType的方法，要调用它，需要一个方法表指针，于是a将被装箱，从而生成方法表指针，调用基类的System.ValueType。(补一句，所有的值类型都是继承于System.ValueType的)。<br>5.2：a.Clone()，因为A实现了Clone方法，所以无需装箱。<br>5.3：ICloneable转型：当a2为转为接口类型时，必须装箱，因为接口是一种引用类型。<br>5.4：c.Clone()。无需装箱，在托管堆中对上一步已装箱的对象进行调用。<br>附：其实上面的基于一个根本的原理，因为未装箱的值类型没有方法表指针，所以，不能通过值类型来调用其上继承的虚方法。另外，接口类型是一个引用类型。对此，我的理解，该方法表指针类似C++的虚函数表指针，它是用来实现引用对象的多态机制的重要依据。</p><p>**9：如何更改已装箱的对象<br>**对于已装箱的对象，因为无法直接调用其指定方法，所以必须先拆箱，再调用方法，但再次拆箱，会生成新的栈实例，而无法修改装箱对象。有点晕吧，感觉在说绕口令。还是举个例子来说：(在上例中追加change方法)</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Change</span>(<span class="hljs-params">Int32 x</span>)</span> &#123;<br><span class="hljs-keyword">this</span>.x = x;<br>&#125;<br>调用：<br>A a = <span class="hljs-keyword">new</span> A();<br>a.x = <span class="hljs-number">100</span>;<br>Object o = a; <span class="hljs-comment">//装箱成o，下面，想改变o的值。</span><br>((A)o).Change(<span class="hljs-number">200</span>); <span class="hljs-comment">//改掉了吗？没改掉。</span><br></code></pre></td></tr></table></figure><p>没改掉的原因是o在拆箱时，生成的是临时的栈实例A，所以，改动是基于临时A的，并未改到装箱对象。<br>(附：在托管C++中，允许直接取加拆箱时第一步得到的实例引用，而直接更改，但C#不行。)<br>那该如何是好？<br>嗯，通过接口方式，可以达到相同的效果。<br>实现如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">interface</span> <span class="hljs-title">IChange</span> &#123;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Change</span>(<span class="hljs-params">Int32 x</span>)</span>;<br>&#125;<br><span class="hljs-keyword">struct</span> A : IChange &#123;<br>…<br>&#125;<br></code></pre></td></tr></table></figure><p>调用：<br>((IChange)o).Change(200);&#x2F;&#x2F;改掉了吗？改掉了。<br>为啥现在可以改？<br>在将o转型为IChange时，这里不会进行再次装箱，当然更不会拆箱，因为o已经是引用类型，再因为它是IChange类型，所以可以直接调用Change，于是，更改的也就是已装箱对象中的字段了，达到期望的效果。</p><p><strong>10、</strong><br>   将值类型转换为引用类型，需要进行装箱操作(boxing)：</p><p>1、首先从托管堆中为新生成的引用对象分配内存。</p><p>2、然后将值类型的数据拷贝到刚刚分配的内存中。</p><p>3、返回托管堆中新分配对象的地址。</p><p>可以看出，进行一次装箱要进行分配内存和拷贝数据这两项比较影响性能的操作。</p><p>将引用内型转换为值内型，需要进行拆箱操作(unboxing)：</p><p>1、首先获取托管堆中属于值类型那部分字段的地址，这一步是严格意义上的拆箱。</p><p>2、将引用对象中的值拷贝到位于线程堆栈上的值类型实例中。</p><p>经过这2步，可以认为是同boxing是互反操作。严格意义上的拆箱，并不影响性能，但伴随这之后的拷贝数据的操作就会同boxing操作中一样影响性能。</p><p><strong>11、</strong><br>NET的所有类型都是由基类System.Object继承过来的，包括最常用的基础类型：int, byte, short，bool等等，就是说所有的事物都是对象。如果申明这些类型得时候都在堆(HEAP)中分配内存，会造成极低的效率！(个中原因以及关于堆和栈得区别会在另一篇里单独得说说！)<br>.NET如何解决这个问题得了？正是通过将类型分成值型(value)和引用型(regerencetype)，C#中定义的值类型包括原类型（Sbyte、Byte、Short、Ushort、Int、Uint、Long、Ulong、Char、Float、Double、Bool、Decimal）、枚举(enum)、结构(struct)，引用类型包括：类、数组、接口、委托、字符串等。<br>值型就是在栈中分配内存，在申明的同时就初始化，以确保数据不为NULL；<br>引用型是在堆中分配内存，初始化为null，引用型是需要GARBAGE COLLECTION来回收内存的，值型不用，超出了作用范围，系统就会自动释放！<br>下面就来说装箱和拆箱的定义！<br>装箱就是隐式的将一个值型转换为引用型对象。比如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;<br>Syste.Object obj=i;<br></code></pre></td></tr></table></figure><p>这个过程就是装箱！就是将i装箱！<br>拆箱就是将一个引用型对象转换成任意值型！比如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;<br>System.Object obj=i;<br><span class="hljs-built_in">int</span> j=(<span class="hljs-built_in">int</span>)obj;<br></code></pre></td></tr></table></figure><p>这个过程前2句是将i装箱，后一句是将obj拆箱！</p>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈&amp;递归&amp;深度优先搜索</title>
    <link href="/2023/01/10/%E6%A0%88&amp;%E9%80%92%E5%BD%92&amp;%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    <url>/2023/01/10/%E6%A0%88&amp;%E9%80%92%E5%BD%92&amp;%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="栈-amp-递归-amp-深度优先搜索"><a href="#栈-amp-递归-amp-深度优先搜索" class="headerlink" title="栈&amp;递归&amp;深度优先搜索"></a>栈&amp;递归&amp;深度优先搜索</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈是一种支持先进后出的数据存储结构，也是一种最常见的数据结构。对于一个栈来说，我们只能每次从栈顶压入元素，或者从栈顶取出元素，而内部的其他数据对外是不可访问的。栈一般分为顺序栈和链式栈。</p><p>一般用法是，栈最初是空的，栈顶指向NULL或者-1, 当需要有元素压入栈时，则开辟一片新的空间（顺序栈就是当前栈顶的下一个位置），然后将栈顶指之；出栈时，先将该元素赋给其他的值或者销毁（顺序栈可略过），然后移动栈顶指针至前一个元素。</p><p><strong>注意</strong>：只有栈不满时才能入栈，只有栈不空时才能出栈。在解决实际问题时，如果push 和pop的算法并没有检查栈顶的位置，很容易造成越界！</p><h3 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h3><blockquote><p>以数组的形式存储数据的栈，除了方便查找以外并没有其他优点（但是一般情况下栈结构是不允许查找栈顶以外元素的），但是如果临时使用栈的话，顺序栈写起来不会十分麻烦，一般常用于小规模使用。缺点就是栈的空间具有限制。</p></blockquote><h4 id="顺序栈的实现"><a href="#顺序栈的实现" class="headerlink" title="顺序栈的实现"></a>顺序栈的实现</h4><blockquote><p>一般情况下，顺序栈只需要一个数组和一个记录栈顶下标的变量就能实现，比较规范的写法如下。</p></blockquote><p><strong>文件：sq_stack.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//从顺序栈开始写起</span><br><span class="hljs-comment">//顺序栈没有别的优势，就是好写，o(╥﹏╥)o，同时如果突然改需求成链表</span><br><span class="hljs-comment">//就不用查找那么麻烦</span><br><span class="hljs-comment">//现在开始吧(*^▽^*)</span><br><br><span class="hljs-comment">//先定义基本数据类型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ElemType;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_SIZE 500</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    <span class="hljs-type">int</span> top;<br>    ElemType stack[MAX_SIZE];<br>&#125;Stack;<br><br><span class="hljs-comment">//基本操作</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">init_sq_stack</span><span class="hljs-params">(Stack **st)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">is_empty</span><span class="hljs-params">(Stack *st)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">push</span><span class="hljs-params">(Stack *st, ElemType *x)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">(Stack *st)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_top</span><span class="hljs-params">(Stack *st,ElemType *x)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">destory_sq_stack</span><span class="hljs-params">(Stack **st)</span></span>;<br></code></pre></td></tr></table></figure><br><p><strong>文件：sq_stack.c</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sq_stack.h&quot;</span></span><br><br><span class="hljs-comment">//基本操作</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">init_sq_stack</span><span class="hljs-params">(Stack **st)</span></span>&#123;<br>    *st = (Stack*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Stack));<br>    (*st)-&gt;top = <span class="hljs-number">-1</span>;<br>    <span class="hljs-built_in">memset</span>((*st)-&gt;stack, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>((*st)-&gt;stack));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">is_empty</span><span class="hljs-params">(Stack *st)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> st-&gt;top == <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">push</span><span class="hljs-params">(Stack *st, ElemType *x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(st-&gt;top == MAX_SIZE - <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;The stack is full!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    st-&gt;top++;<br>    st-&gt;stack[st-&gt;top] = (*x);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">(Stack *st)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">is_empty</span>(st))&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;The stack is empty!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    st-&gt;top--;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_top</span><span class="hljs-params">(Stack *st,ElemType *x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">is_empty</span>(st))&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;The stack is empty!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    (*x) = st-&gt;stack[st-&gt;top];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">destory_sq_stack</span><span class="hljs-params">(Stack **st)</span></span>&#123;<br>    <span class="hljs-built_in">free</span>(*st);<br>    (*st) = <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="链式栈"><a href="#链式栈" class="headerlink" title="链式栈"></a>链式栈</h3><blockquote><p>链式栈是实现栈的比较理想的存储方式，它不受空间限制。为了方便出栈，链式栈中的结点一般指向它的前一个结点，而栈空时，头结点指向NULL。</p></blockquote><h4 id="链式栈的实现"><a href="#链式栈的实现" class="headerlink" title="链式栈的实现"></a>链式栈的实现</h4><p><img src="/2023/01/10/%E6%A0%88&%E9%80%92%E5%BD%92&%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/link_stack.png" alt="link_stack"></p><center>链式栈的基本结构</center><p><strong>文件：link_stack.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-comment">//链式栈不受空间的约束，是一种比较理想的栈的结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ElemType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    ElemType data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> *last;<br>&#125;StNode;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">stack</span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> *top;<br>    <span class="hljs-type">int</span> size;<br>&#125;Stack;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">init_stack</span><span class="hljs-params">(Stack **st)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">is_empty</span><span class="hljs-params">(Stack *st)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">push</span><span class="hljs-params">(Stack *st, ElemType *x)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">(Stack *st)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_top</span><span class="hljs-params">(Stack *st,ElemType *x)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">destory_stack</span><span class="hljs-params">(Stack **st)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_size</span><span class="hljs-params">(Stack *st)</span></span>;<br></code></pre></td></tr></table></figure><br><p><strong>文件：link_stack.c</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;link_stack.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">init_stack</span><span class="hljs-params">(Stack **st)</span></span>&#123;<br>    *st = (Stack *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Stack));<br>    (*st)-&gt;size = <span class="hljs-number">0</span>;<br>    (*st)-&gt;top = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">is_empty</span><span class="hljs-params">(Stack *st)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> st-&gt;top == <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">push</span><span class="hljs-params">(Stack *st, ElemType *x)</span></span>&#123;<br>    StNode *s = (StNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(StNode));<br>    s-&gt;data = (*x);<br>    s-&gt;last = st-&gt;top;<br>    st-&gt;top = s;<br>    st-&gt;size++;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">(Stack *st)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">is_empty</span>(st))&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;The stack is empty!\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    StNode *tmp = st-&gt;top;<br>    st-&gt;top = tmp-&gt;last;<br>    <span class="hljs-built_in">free</span>(tmp);<br>    st-&gt;size--;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_top</span><span class="hljs-params">(Stack *st,ElemType *x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">is_empty</span>(st))&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;The stack is empty!\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    (*x) = st-&gt;top-&gt;data;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">destory_stack</span><span class="hljs-params">(Stack **st)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>((*st)-&gt;top != <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">pop</span>(*st);<br>    &#125;<br>    <span class="hljs-built_in">free</span>(*st);<br>    (*st) = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_size</span><span class="hljs-params">(Stack *st)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> st-&gt;size;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>在定义一个过程或者函数时出现调用本过程或 本函数的成分称为<strong>递归</strong>，调用自身为<strong>直接递归</strong>，比如二叉树中的先序遍历，图中的深度优先搜索；调用其他函数称为<strong>间接递归</strong>，比如快速排序。</p><p>如果一个递归过程或递归函数中的递归调用语句是最后一条执行语句，则称这种递归调用为<strong>尾递归</strong>，比如阶乘算法。</p><p>一般情况下， 一个递归模型由<strong>递归出口</strong>和<strong>递归体</strong>两部分组成，在实际算法中也就是要解决这两个东西。</p><p>举个例子，在阶乘算法中，n &#x3D;&#x3D; 1 就是递归出口，当递归深入到这一层时就需要返回，而递归体就是 $ f(n) &#x3D; n * f(n - 1) $，程序通过该递归体一步步向下递推，直到 遇到n &#x3D;&#x3D; 1的情况时返回，最后依照原先的路径一步步回归到 $ n &#x3D;&#x3D; n_0 $就完成了本次递归。</p><blockquote><p>递归的本质应该是广义上的数学归纳法，即结构归纳法，在知道已知条件$ K_0 $的情况下，通过假设$ Ki $成立推导出$ K_(i + 1) $成立，完成证明。递归因此也是将大问题转化成若干个小问题的过程。</p></blockquote><h3 id="递归与非递归的转换"><a href="#递归与非递归的转换" class="headerlink" title="递归与非递归的转换"></a>递归与非递归的转换</h3><p>​因为递归依然是通过调用系统栈来实现的，所以本质上，只要记录下递归过程中的参数和返回值，就能够自己用栈来模拟递归过程。</p><p>一般情况下，<strong>尾递归</strong>算法能够通过<strong>循环或者迭代</strong>的方式转换为等价的非递归算法，例如求Fibonacci数列的非递归算法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">1</span>, i, s;<br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span> || n == <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">3</span>;i &lt;= n;i++)&#123;<br>            s = a + b;<br>            a = b;<br>            b = s;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><p>而对于<strong>非尾递归</strong>的算法，可以通过栈来模拟递归执行过程，从而将其转化为等价的非递归算法。</p><p>最典型递归算法的莫过于汉诺塔原理，几乎讲到递归就会涉及它。先贴出一份递归写法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Hanoi</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">char</span> X, <span class="hljs-type">char</span> Y, <span class="hljs-type">char</span> Z)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c -&gt; %c\n&quot;</span>,X, Z);<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">Hanoi</span>(n - <span class="hljs-number">1</span>, X, Z, Y);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c -&gt; %c\n&quot;</span>, X, Z);<br>        <span class="hljs-built_in">Hanoi</span>(n - <span class="hljs-number">1</span>, Y, X, Z);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br><p>​非递归的实现：需要使用一个栈来暂时存放还不能直接移动盘片的任务&#x2F;子任务。</p><p>大概的思路是，先将任务Hanoi(n, x, y, z)进栈，栈不空是循环：出栈一个任务Hanoi(n, x, y, z)，如果它是可以直接移动的， 就移动盘片；否则将该任务转化为Hanoi(n - 1, x, z, y)，move(n, x, z) , Hanoi(n - 1, y , x, z)，按相反顺序依次进栈， 其中move(n, x, z)是可以直接移动的任务，相关代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    <span class="hljs-type">int</span> n;   <span class="hljs-comment">//盘片个数</span><br>    <span class="hljs-type">char</span> x, y, z;<br>    <span class="hljs-type">int</span> flag;   <span class="hljs-comment">//可直接移动时为1，否则为0</span><br>&#125;ElemType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>ElemType data[MaxSize];<br>    <span class="hljs-type">int</span> top;<br>&#125;StackType;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitElem</span><span class="hljs-params">(ElemType *e, <span class="hljs-type">int</span> n, <span class="hljs-type">char</span> x, <span class="hljs-type">char</span> y, <span class="hljs-type">char</span> z, <span class="hljs-type">int</span> flag)</span></span>&#123;<br>    e-&gt;n = n; e-&gt;x = x; e-&gt;y = y; e-&gt;z = z; e-&gt;flag = flag;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Hanoi</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">char</span> x, <span class="hljs-type">char</span> y, <span class="hljs-type">char</span> z)</span></span>&#123;<br>    StackType *st;<br>    ElemType e, e1, e2, e3;<br>    <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">InitStack</span>(st);<br>    <span class="hljs-built_in">InitElem</span>(&amp;e, n, x, y, z, <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">push</span>(st, e);<br>    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">StackEmpty</span>(st))&#123;<br>        <span class="hljs-built_in">pop</span>(st, e);<br>        <span class="hljs-keyword">if</span>(e.flag == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">InitElem</span>(&amp;e1, e.n - <span class="hljs-number">1</span>, e.y, e.x, e.z, <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">if</span>(e1.n == <span class="hljs-number">1</span>)&#123;<br>                e1.flag = <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> e1.flag = <span class="hljs-number">0</span>;<br>            <span class="hljs-built_in">push</span>(st, e1);<br>            <span class="hljs-built_in">InitElem</span>(&amp;e2, e.n, e.x ,e.y, e.z, <span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">push</span>(st, e2);<br>            <span class="hljs-built_in">InitElem</span>(&amp;e3, e.n - <span class="hljs-number">1</span>, e.x, e.z, e.y, <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">if</span>(e3.n == <span class="hljs-number">1</span>)&#123;<br>                e3.flag = <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> e3.flag = <span class="hljs-number">0</span>;<br>            <span class="hljs-built_in">push</span>(st, e3);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c -&gt; %c\n&quot;</span>,e.x, e.z);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">DestroyStack</span>(st);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h2><h3 id="图中的DFS"><a href="#图中的DFS" class="headerlink" title="图中的DFS"></a>图中的DFS</h3><ul><li><p><strong>原理</strong></p><p>​<strong>深度优先遍历</strong>的过程是从图中的某个初始点v出发，首先访问初始点v，然后选择一个与v相邻的且没有被访问过的顶点w，以w为初始顶点，再从它出发进行深度优先遍历，直到图中与顶点v邻接的所有顶点都被访问过为止，一般通过递归来实现。</p><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> visited[max] = &#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-comment">//全局数组，判断结点是否被访问过</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(AdjGraph *G, <span class="hljs-type">int</span> v)</span></span>&#123;<br>    ArcNode *p;<br>    visited[v] = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%d&quot;</span>,v);<br>    p = G-&gt;adjlist[v].firstarc;<br>    <span class="hljs-keyword">while</span>(p != <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">if</span>(visited[p-&gt;adjvex] == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">DFS</span>(G, p-&gt;adjvex);<br>        &#125; p = p-&gt;nextarc;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>应用</strong></p><blockquote><ol><li>判断两点之间是否有最短路径</li><li>求出最大连通图的数量</li><li>拓扑排序（需要借助post实现）</li><li>求两点之间的所有路径（回溯）</li></ol></blockquote></li></ul><h3 id="广义DFS"><a href="#广义DFS" class="headerlink" title="广义DFS"></a>广义DFS</h3><p>相较于限制在图中的DFS，广义上的DFS能够解决更多，更普遍的问题。</p><p>DFS和枚举类似，都是一种很朴素自然的遍历方法。当我们遇到一种状态之后，我们开始判断它产生（或连接）的所有合理的新状态，每遇到一个新状态便递归使用DFS访问它，直到该状态下的所有情况访问完，该算法结束。</p><p><img src="/2023/01/10/%E6%A0%88&%E9%80%92%E5%BD%92&%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/dfs_flow.png" alt="dfs_flow"></p><p>模板1(递归实现):</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">DFS function(<span class="hljs-keyword">params</span>: current <span class="hljs-keyword">node</span><span class="hljs-title">, target</span> <span class="hljs-keyword">node</span><span class="hljs-title">, hash_table</span> visited):<br>if cur == target: return <span class="hljs-literal">true</span><br>for every suitable neighbor <span class="hljs-keyword">in</span> current <span class="hljs-keyword">node</span><span class="hljs-title">&#x27;s</span> neighbors:<br>add each to visited<br>if DFS(each, target, visited): return <span class="hljs-literal">true</span><br>//if not find target<br>return <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>模板2(栈实现):</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">DFS function(<span class="hljs-keyword">params</span>: root <span class="hljs-keyword">node</span><span class="hljs-title">, target</span> <span class="hljs-keyword">node</span><span class="hljs-title">):</span><br><span class="hljs-title">hash_table</span> visited<br>init stack  //store nodes that not finished yet<br>add root to stack<br>while stack not empty:<br>current <span class="hljs-keyword">node</span> <span class="hljs-title">= top</span> of stack<br>remove top elem <span class="hljs-keyword">in</span> stack<br>if cur == target: return <span class="hljs-literal">true</span><br>for every suitable neighbor <span class="hljs-keyword">in</span> cur <span class="hljs-keyword">node</span><span class="hljs-title">&#x27;s</span> neighbors:<br>add each to visited<br>add each to stack<br>//if not find target<br>return <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DFS</tag>
      
      <tag>栈</tag>
      
      <tag>递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>寻找唯一值</title>
    <link href="/2023/01/10/%E5%AF%BB%E6%89%BE%E5%94%AF%E4%B8%80%E5%80%BC/"/>
    <url>/2023/01/10/%E5%AF%BB%E6%89%BE%E5%94%AF%E4%B8%80%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="寻找唯一值"><a href="#寻找唯一值" class="headerlink" title="寻找唯一值"></a>寻找唯一值</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>找出数组中唯一的值，因为该数组除了那个值以外，其他的值都有两个。</p><p>例如：arr &#x3D; {1,1,2,2,3}, 找出数字3</p><h2 id="利用异或运算的性质"><a href="#利用异或运算的性质" class="headerlink" title="利用异或运算的性质"></a>利用异或运算的性质</h2><p class="note note-primary">异或运算</p><blockquote><p>异或运算满足交换律和结合律（对于二进制的每一位，异或运算相当于差的绝对值</p><p>a^b &#x3D; b^a, a^b^c &#x3D; a^(b^c)</p><p>a^a&#x3D;0 （自己和自己一定相同）</p><p>0^a&#x3D;a （0^0&#x3D;0, 0^1&#x3D;1）</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">single_number</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; arr)</span></span>&#123;<br>    <span class="hljs-type">int</span> a = arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">if</span>(arr.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> a;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; arr.<span class="hljs-built_in">size</span>(); i++)&#123;<br>        a ^= arr[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br></code></pre></td></tr></table></figure><p>解释：</p><p>设数组中的数为b,b,c,c,e,d,e… …，则a &#x3D; b^b^c^c^e^d^e^… … &#x3D; 0^0^e^e^d^… … &#x3D; 0^0^0^d^0^… … &#x3D; d，因此遍历完所有数据后，得到的结果就是唯一值。</p><br><p><strong>位运算的一些常见用法</strong></p><ul><li>除以2：n &gt;&gt; 1</li><li>判断奇偶：n &amp; 1为true代表该数是奇数，否则为偶数</li><li>交换数据：a ^&#x3D; b, b ^&#x3D; a, a ^&#x3D; b</li></ul><br><h2 id="利用哈希表"><a href="#利用哈希表" class="headerlink" title="利用哈希表"></a>利用哈希表</h2><p class="note note-primary">哈希表</p><p>对于遍历的每一个元素，如果哈希表中不存在该元素，则添加；否则在哈希表中删除该元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">single_number2</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; arr)</span></span>&#123;<br>    unordered_set&lt;<span class="hljs-type">int</span>&gt; my_set;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it = arr.<span class="hljs-built_in">begin</span>(); it != arr.<span class="hljs-built_in">end</span>(); it++)&#123;<br>        <span class="hljs-keyword">if</span>(my_set.<span class="hljs-built_in">count</span>(*it) &gt; <span class="hljs-number">0</span>)&#123;<br>            my_set.<span class="hljs-built_in">erase</span>(*it);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            my_set.<span class="hljs-built_in">insert</span>(*it);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> *my_set.<span class="hljs-built_in">begin</span>();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>位运算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>异或运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>寻找所有异构字符串</title>
    <link href="/2023/01/10/%E5%AF%BB%E6%89%BE%E6%89%80%E6%9C%89%E5%BC%82%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2023/01/10/%E5%AF%BB%E6%89%BE%E6%89%80%E6%9C%89%E5%BC%82%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="寻找所有异构字符串"><a href="#寻找所有异构字符串" class="headerlink" title="寻找所有异构字符串"></a>寻找所有异构字符串</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>对于一个字符串s，给定一个字符串p，找到s中所有和p同分异构（字母的种类和数量相同，但组合可以不同）的字符串，输出他们的起始下标。</p><p><img src="/2023/01/10/%E5%AF%BB%E6%89%BE%E6%89%80%E6%9C%89%E5%BC%82%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/image-20201126164101209.png" alt="image-20201126164101209"></p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>问题解决的核心在于统计每一个字符串中字符的频率，如果两者相等，则说明是要寻找的字符串。一种方式是创建两个哈希表，其中一个存储字符串p中字符的频率，然后遍历s中和p字符串长度相同的子字符串，并采取类似队列进出的方式计算它们的频率（前一个子字符串扔掉最后一个字符在加上前面一个字符就得到新的字符串），比较该值和p，如果相同则得到一个解。但是该算法的时间复杂度为两个字符串长度的乘积，因此一般会比较慢。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">findAnagrams</span><span class="hljs-params">(String s, String p)</span> &#123;<br>        <br>        Map&lt;Character, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> ch : p.toCharArray())&#123;<br>            map.put(ch, map.getOrDefault(ch, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(s.length() &lt; p.length())&#123;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>        <br>        Map&lt;Character, Integer&gt; cp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; p.length() - <span class="hljs-number">1</span>; i++)&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            cp.put(ch, cp.getOrDefault(ch, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> p.length() - <span class="hljs-number">1</span>; i &lt; s.length(); i++)&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> s.charAt(i);<br>            cp.put(ch, cp.getOrDefault(ch, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(cp.size() == map.size())&#123;<br>                <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">for</span>(Map.Entry&lt;Character, Integer&gt; entry : map.entrySet())&#123;<br>                    <span class="hljs-type">char</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> entry.getKey();<br>                    <span class="hljs-keyword">if</span>(!entry.getValue().equals(cp.getOrDefault(key, -<span class="hljs-number">1</span>)))&#123;<br>                        flag = <span class="hljs-literal">false</span>;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(flag)ans.add(i + <span class="hljs-number">1</span> - p.length());<br>            &#125;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> s.charAt(i + <span class="hljs-number">1</span> - p.length());<br>            <span class="hljs-keyword">if</span>(cp.get(head).equals(<span class="hljs-number">1</span>))&#123;<br>                cp.remove(head);<br>            &#125;<br>            <span class="hljs-keyword">else</span> cp.replace(head, cp.get(head) - <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>更好的方法是采用类似滑动窗口的方法：</p><p>依然使用一个哈希表来存储p中字符串的频率，再初始化begin和end两个指针，这是我们把哈希表中的内容当做是begin,end之间的字符串还欠缺的值，所求的解应该满足一下条件：</p><ol><li>包含p中的所有字符</li><li>每个字符的值都相等</li><li>两者的长度相等</li></ol><p>因此，可以先移动end指针，每找到一个符合条件的字符，就在哈希表中减去一个该字符，说明这个字符的需求少了一个，直到哈希表中的字符个数都小于等于0，说明当前begin,end字符串的字符集合包含p的字符集合，这时移动begin，表示抛弃掉多余的字符，如果抛弃的这个字符是我们需要的，则需要继续移动end来添加，否则当begin，end字符串的长度等于p的长度时，说明该字符串的字符集包含p的字符集并且两个集合的大小相等，这正是两个者相等的条件，得到一个解。以此类推，当end遍历完s时输出所有解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">findAnagrams</span><span class="hljs-params">(String s, String t)</span> &#123;<br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(t.length()&gt; s.length()) <span class="hljs-keyword">return</span> result;<br>        Map&lt;Character, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> c : t.toCharArray())&#123;<br>            map.put(c, map.getOrDefault(c, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> map.size();<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, end = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <br>        <br>        <span class="hljs-keyword">while</span>(end &lt; s.length())&#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(end);<br>            <span class="hljs-keyword">if</span>( map.containsKey(c) )&#123;<br>                map.put(c, map.get(c)-<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span>(map.get(c) == <span class="hljs-number">0</span>) counter--;<br>            &#125;<br>            end++;<br>            <br>            <span class="hljs-keyword">while</span>(counter == <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">tempc</span> <span class="hljs-operator">=</span> s.charAt(begin);<br>                <span class="hljs-keyword">if</span>(map.containsKey(tempc))&#123;<br>                    map.put(tempc, map.get(tempc) + <span class="hljs-number">1</span>);<br>                    <span class="hljs-keyword">if</span>(map.get(tempc) &gt; <span class="hljs-number">0</span>)&#123;<br>                        counter++;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(end-begin == t.length())&#123;<br>                    result.add(begin);<br>                &#125;<br>                begin++;<br>            &#125;<br>            <br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库原理-关系代数</title>
    <link href="/2023/01/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86-%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0/"/>
    <url>/2023/01/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86-%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库原理-关系代数"><a href="#数据库原理-关系代数" class="headerlink" title="数据库原理-关系代数"></a>数据库原理-关系代数</h1><h2 id="什么是关系代数？"><a href="#什么是关系代数？" class="headerlink" title="什么是关系代数？"></a>什么是关系代数？</h2><p>​关系代数是数据库查询的理论基础，数据库中所有的查询语句都能够用相对应的关系代数运算来表达</p><p>​关系代数操作的对象就是关系，它通过对关系进行组合和分割来生成一个新的关系。也就是说，该运算的域没有发生变化，这和我们常用的实数运算是类似的。</p><h2 id="离散数学回顾-关系的概念"><a href="#离散数学回顾-关系的概念" class="headerlink" title="离散数学回顾-关系的概念"></a>离散数学回顾-关系的概念</h2><p>​关系在数据库中对应的是一张张表格，而关系中的元组对应的是表格中的行。从数学定义上来看，数据库中的关系和离散数学中的关系有相同的概念，即<a href="https://en.wikipedia.org/wiki/Cartesian_product">笛卡尔积</a>的子集。在离散数学中，关系定义如下：</p><p><br>设$$n\in I_{+}，A_1, A_2, …, A_n$$是$n$个集合，$R\subseteq \times_{i&#x3D;1}^{n} A_i$, 称$R$是集合$A_1, A_2, …, A_n$ 上的<strong>n​元关系</strong></p><br><p>从定义中可以看出关系有如下性质：</p><ol><li>关系是集合</li><li>关系中的元素是有序n重组</li></ol><p>​数学上的关系和现实中常用的关系的概念是有区别的，因为数学上不是所有的关系都有意义，比如把汽车种类和食物种类做笛卡尔积后得到的关系基本毫无用处，除非你生活在汽车人的世界里:)</p><p>下面是一个关系的例子：</p><blockquote><p>假设我们想要记录一车苹果的质量，但我们只关心它的两个属性：</p><p>color: in (green, red)</p><p>size:    in (large, little)</p><p>则所有可能出现的苹果种类构成了笛卡尔积，这个集合有2x2&#x3D;4个元素：</p><p>{&lt;green, large&gt;, &lt;green, little&gt;, &lt;red, large&gt;, &lt;red, little&gt;}</p><p>我们可以确定这车苹果所包含的种类一定在这个笛卡尔积中，因此可以为这些苹果建立一个关系：</p><table><thead><tr><th>color</th><th>size</th></tr></thead><tbody><tr><td>green</td><td>large</td></tr><tr><td>red</td><td>little</td></tr></tbody></table><p>这表明这车苹果中只有绿色大苹果和红色小苹果</p></blockquote><h2 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h2><p>包括并、差、交和广义的笛卡尔积，注意，集合运算操作的对象是关系中的元素，即元组，因此，除了笛卡尔积之外，其它运算中两个关系必须有相同的属性</p><p>每种运算的定义如下：</p><p>并(Union):<br>$$<br>R \bigcup S &#x3D; {t | t \in R \vee t \in S}<br>$$</p><p>差(Difference):<br>$$<br>R - S &#x3D; {t | t \in R \wedge t \notin S}<br>$$</p><p>交(Intersection):<br>$$<br>R \bigcap S &#x3D; {t | t \in R \wedge t \in S}<br>$$</p><p>积(Cartesian Product):<br>$$<br>R \times S &#x3D; {t_r t_s | (t_r \in R) \wedge (t_s \in S)}<br>$$</p><p>前3种十分易于理解，对于广义笛卡尔积，新生成的关系的属性由R和S的属性拼接而成，而该关系是R和S中元素的所有组合的集合。在数据库中，广义笛卡尔积常用于多表查询，对应语句<code>from table1, table2</code></p><h2 id="关系运算"><a href="#关系运算" class="headerlink" title="关系运算"></a>关系运算</h2><p>关系运算包括选择、投影、连接、除，广义上还有外连接</p><p>选择(Selection):<br>$$<br>{\sigma}_{F}(R) &#x3D; {t | (t \in R) \wedge F(t) &#x3D; True}<br>$$<br>其中$F$为条件表达式</p><p>只有满足条件的元组被留下来，形成新的关系，对应于SQL语句里的<code>where</code></p><br><p>投影(Projection):<br>$$<br>{\Pi}_A (R) &#x3D; {t[A] | (t \in R)}<br>$$</p><p>只选择原关系中的部分属性组成新的关系，对应于SQL语句里的<code>select</code>（碰巧是上一个运算的名字，容易弄混）</p><br><p>连接(Join):<br>$$<br>R \underset{A\theta B}{\bowtie} S &#x3D; {\sigma}_{R.A \theta S.B}(R \times S)<br>$$</p><p>常见的连接运算：</p><ol><li><p>等值连接：即 $\theta$ 为 &#x3D; 的连接</p></li><li><p>自然连接。特殊的等值连接，要求两个关系中有相同的属性组，表示其属性和域都得相同，结果会把重复的属性去掉。自然连接是内连接的一种，如果一个关系中该属性的某个取值在另一个关系中找不到，则忽略这个取值对应的元组。</p><p> 自然连接可以分解为3个步骤：求$R \times S$， 选择满足等值条件的元组($ R.B_1 &#x3D; S.B_1 \wedge R.B_2 &#x3D; S.B_2 …$)，去掉重复的属性</p><p> ($B_1, B_2,…$)</p></li></ol><br><p>除(Division):<br>$$<br>R \div S &#x3D; {t[X] | t \in R \wedge {\Pi}_Y (S) \subseteq Y_X }<br>$$</p><p>其中R(X, Y), S(Y, Z)</p><p>求除运算的4个步骤：</p><ol><li>求${\Pi}_X (R)$</li><li>求${\Pi}_Y (S)$</li><li>求$Y_X$ ($X$在 $R$ 中的像集(Image Set))，类似于SQL语句中的GROUP BY X，将关系 $R$ 中的元组根据 $X$ 的取值划分成了一个个小组</li><li>$R \div S$ 的计算结果为像集 $Y_X$ 包含了 ${\Pi}_Y(S)$ 的 $x_i$，即，如果上一步所求的小组中包含S投影在Y上的关系，则将该小组对应的 $X$ 的取值放到结果关系中</li></ol><p>还是拿苹果关系作为例子:</p><blockquote><p>假设现在给每个苹果编号</p><table><thead><tr><th>id</th><th>color</th><th>size</th></tr></thead><tbody><tr><td>1</td><td>green</td><td>large</td></tr><tr><td>2</td><td>red</td><td>little</td></tr><tr><td>3</td><td>red</td><td>large</td></tr><tr><td>4</td><td>green</td><td>little</td></tr></tbody></table><p>然后从中筛选出又大又红的苹果，则可以把除数设置为要筛选的属性</p><table><thead><tr><th>color</th><th>size</th></tr></thead><tbody><tr><td>red</td><td>large</td></tr></tbody></table><p>把两个关系做除运算后，就可以得到质量又大又红的苹果的编号</p><table><thead><tr><th>id</th></tr></thead><tbody><tr><td>3</td></tr></tbody></table></blockquote><br><p>外连接:</p><p>同样要进行等值连接，但是会根据连接的方式决定是否把某些属性置空，最后再去掉重复的属性</p><p>假设关系R和S有公共属性Y，如果R中的某些元组在S中没有与Y上值相等的元组，或者相反，则</p><p>全外连接：都不去掉，相应属性以null填充</p><p>左外连接：保留关系R上的元组，S上的其他属性用null填充</p><p>右外连接：保留关系S上的元组，R上的其他属性用null填充</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>关系代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库原理-函数依赖</title>
    <link href="/2023/01/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86-%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96/"/>
    <url>/2023/01/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86-%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库原理-函数依赖"><a href="#数据库原理-函数依赖" class="headerlink" title="数据库原理-函数依赖"></a>数据库原理-函数依赖</h1><h2 id="为什么要引入函数依赖？"><a href="#为什么要引入函数依赖？" class="headerlink" title="为什么要引入函数依赖？"></a>为什么要引入函数依赖？</h2><p>函数依赖是数据库设计基础理论的一部分，它能够帮助我们定义属性之间的一部分联系，能够用来确定候选键，定义范式，从而评价关系模式设计的好坏。</p><h2 id="函数依赖的定义"><a href="#函数依赖的定义" class="headerlink" title="函数依赖的定义"></a>函数依赖的定义</h2><p>设R(U)，U是R的属性集，X,Y是U的子集，对于X的每一个具体值，都有唯一的Y与之对应，则称X函数决定Y，或者Y函数依赖于X</p><p>函数依赖还要满足如下条件：</p><ol><li><p>R的一切关系都要满足约束条件（即表格中的子表也要满足）</p></li><li><p>只能根据语义来确定函数依赖，没有形式上的定义。例如姓名$\to$ 班级 依赖下，只有在没有同名的前提下才能够成立</p></li></ol><p>函数依赖大概能够理解为，每个X只能 有&#x2F;对应 一个Y，它反映了表中属性之间的决定关系</p><p>以学校中的关系为例子：</p><blockquote><p>存在关系S（sno(学号), sname(姓名), class(班级), cno(课程号), tno(教师号), tname(教师姓名), tage(教师年龄), address(教师地址), grade(成绩))</p><p>则以下函数依赖是成立的</p><p>$sno \to sname$</p><p>$sno \to class$</p><p>$tno \to tname$</p><p>$tno \to tage$</p><p>…</p></blockquote><h3 id="完全函数依赖"><a href="#完全函数依赖" class="headerlink" title="完全函数依赖"></a>完全函数依赖</h3><p>在$R(U)$中，如果$X \to Y$, 并且对于$X$的每一个真子集$X’$，都有$X’ \nrightarrow Y$, 则称$Y$完全函数依赖于$X$，记作$X \overset{f}{\to} Y$。否则，$Y$部分函数依赖于$X$，记作$X \overset{P}{\to} Y$。</p><p>举个例子：</p><blockquote><p>$(sno, cno) \to grade$ 是一个完全函数依赖，因为 $sno \nrightarrow grade$, $ cno \nrightarrow grade$</p></blockquote><h3 id="传递函数依赖"><a href="#传递函数依赖" class="headerlink" title="传递函数依赖"></a>传递函数依赖</h3><p>设$X,Y,Z$为$U$的不同子集，如果$X \rightarrow Y, Y \nrightarrow X, Y \rightarrow Z$, 则必有$X \to Z$，则称$Z$传递函数依赖于$X$, 记作$X \overset{t}{\to} Z$。</p><h2 id="用函数依赖定义候选键"><a href="#用函数依赖定义候选键" class="headerlink" title="用函数依赖定义候选键"></a>用函数依赖定义候选键</h2><p>候选键：唯一标识实体又没有多余属性的<strong>属性集</strong></p><p>定义：设$X$为$R&lt;U, F&gt;$中的属性或者属性集，若$X \overset{f}{\to} U$，则称$X$为$R$的候选键</p><p>从定义可以看出，$X$能够唯一确定$R$的属性全集(即确定$R$), 又因为是完全函数依赖，因此$X$是最小的属性集(如果有比$X$大的属性集，则$X$就是该属性集的真子集，这与完全函数依赖的定义相矛盾)</p><p>因此候选键具有以下性质：</p><ol><li>唯一确定性</li><li>最小性</li><li>存在性和不唯一性。每一个关系都有至少一个候选键，否则就会出现相同的实体</li></ol><p>主键：其中一个候选键</p><p>主属性：包含在任何一个候选键中的属性</p><p>非主属性：不包含在任何一个候选键中的属性</p><p>常见的学号、班号、教师编号等都可以是相应表中的候选键，在选课表中，学生号和课程号这个全集就是唯一的候选键</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>函数依赖</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>天际线问题</title>
    <link href="/2023/01/10/%E5%A4%A9%E9%99%85%E7%BA%BF%E9%97%AE%E9%A2%98/"/>
    <url>/2023/01/10/%E5%A4%A9%E9%99%85%E7%BA%BF%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="天际线问题-Skyline-Problem"><a href="#天际线问题-Skyline-Problem" class="headerlink" title="天际线问题(Skyline Problem)"></a>天际线问题(Skyline Problem)</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>A city’s skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Now suppose you are <strong>given the locations and height of all the buildings</strong> as shown on a cityscape photo (Figure A), write a program to <strong>output the skyline</strong> formed by these buildings collectively (Figure B).</p><p><a href="https://leetcode.com/static/images/problemset/skyline1.jpg"><img src="https://assets.leetcode.com/uploads/2018/10/22/skyline1.png" alt="Buildings"> </a><a href="https://leetcode.com/static/images/problemset/skyline2.jpg"><img src="https://assets.leetcode.com/uploads/2018/10/22/skyline2.png" alt="Skyline Contour"></a></p><p>The geometric information of each building is represented by a triplet of integers <code>[Li, Ri, Hi]</code>, where <code>Li</code> and <code>Ri</code> are the x coordinates of the left and right edge of the ith building, respectively, and <code>Hi</code> is its height. It is guaranteed that <code>0 ≤ Li, Ri ≤ INT_MAX</code>, <code>0 &lt; Hi ≤ INT_MAX</code>, and <code>Ri - Li &gt; 0</code>. You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height 0.</p><p>For instance, the dimensions of all buildings in Figure A are recorded as: <code>[ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ] </code>.</p><p>The output is a list of “<strong>key points</strong>“ (red dots in Figure B) in the format of <code>[ [x1,y1], [x2, y2], [x3, y3], ... ]</code> that uniquely defines a skyline. <strong>A key point is the left endpoint of a horizontal line segment</strong>. Note that the last key point, where the rightmost building ends, is merely used to mark the termination of the skyline, and always has zero height. Also, the ground in between any two adjacent buildings should be considered part of the skyline contour.</p><p>For instance, the skyline in Figure B should be represented as:<code>[ [2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0] ]</code>.</p><p><strong>Notes:</strong></p><ul><li>The number of buildings in any input list is guaranteed to be in the range <code>[0, 10000]</code>.</li><li>The input list is already sorted in ascending order by the left x position <code>Li</code>.</li><li>The output list must be sorted by the x position.</li><li>There must be no consecutive horizontal lines of equal height in the output skyline. For instance, <code>[...[2 3], [4 5], [7 5], [11 5], [12 7]...]</code> is not acceptable; the three lines of height 5 should be merged into one in the final output as such: <code>[...[2 3], [4 5], [12 7], ...]</code></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>用中文简单描述一下：</p><blockquote><p>在一个二维平面上分布着许多矩形的建筑物，你需要将它们的轮廓线用特定的坐标表示出来</p><p>规定：输出的轮廓线中每一个矩形的左上角坐标，而末尾坐标一定为(x, 0)</p></blockquote><br><p>初一看，要求的点一定在轮廓线的交叉点或者转折点上，而这些点又一定伴随着某个矩阵的开始或者结束（但并不是每一个开始或者结束点都会产生这些点），因此一个初步的思路是将这些点按一定的顺序排列起来，然后在遍历这些点的过程中，根据当前建筑物的高度决定是否输出某个点。</p><p><img src="/2023/01/10/%E5%A4%A9%E9%99%85%E7%BA%BF%E9%97%AE%E9%A2%98/Skyline-Page-1.png" alt="all cross points"></p><p>答案中的点一定在图中的点产生（把高度为0也看成一个矩形），而只有绿色的点才是我们需要输出的。</p><p>可以进一步思考，因为所求的是轮廓线上的点，因此一定和最大高度有关系。假设我们在从左往右检查的过程中，建筑物在依次地生成和销毁，一般情况下（先不考虑重合情况），当一个建筑物开始生成时，如果它的高度比最大高度要小，则不会产生轮廓线，否则为需要输出的点；而当某个建筑物开始消失时，如果最大高度没有改变，则同样不会影响轮廓线，而如果最大高度减小了，说明会和 次大高度 产生一个交叉点，这个点也是需要输出的（两种需要输出情况分别对应上图中第一二个绿色的点）。通过这种思想，我们就需要时刻能够取出和删除最大高度，因此采用优先队列或者二叉平衡树的结构是很理想的（一般使用平衡树，因为需要删除结构中的非最大值）。</p><p>然而，仍然有三种情况需要额外考虑：</p><ol><li><p>两建筑物同时生成</p><p>即起始点的横坐标相同，这时需要先让较高的建筑物生成，以避免输出较矮的那个高度（可以反证法验证一下），否则按逻辑顺序生成。</p></li><li><p>两建筑物同时摧毁</p><p>即结束点的横坐标相同，这时需要先让较矮的建筑物摧毁，以避免输出较矮的那个高度，否则按逻辑顺序摧毁。</p></li><li><p>前一个摧毁的同时，后一个立即生成</p><p>即结束点和起始点的横坐标相同，这时需要先生成建筑物；如果两建筑物刚好高度相同，则不能输出轮廓点。</p></li></ol><br><p>讨论完所有情况后，就可以按照规则先将这些点排列起来了。我们用这样一种方式来表示不同意义的点：<br>$$<br>[x, height, start _{or} end]<br>$$<br>其中<strong>x</strong>表示点的横坐标，<strong>height</strong>表示高度，最后一个参数表示该点是起始点还是结束点。</p><p>别担心，尽管这种方式只能表示起始和结束点的坐标，但是结合平衡树后就能够产生交叉点了（当前横坐标+平衡树中存储的最大高度）。</p><br><p>先根据题目给出的建筑物坐标以上述方式依次写出各点：</p><p>[2, 10, s]</p><p>[9, 10, e]</p><p>[3, 15, s]</p><p>[7, 15, e]</p><p>[5, 12, s]</p><p>[12, 12, e]</p><p>[15, 10, s]</p><p>[20, 10, e]</p><p>[19, 8, s]</p><p>[24, 8, e]</p><p>但是，这种顺序是无法满足要求的，根据前面的思想，我们需要制定如下规则：</p><ol><li>横坐标小的放前面</li><li>横坐标相同<ol><li>同为s, 先放高的</li><li>同为e, 先放矮的</li><li>一s一e， 先放s</li></ol></li></ol><p>经过上述规则后排序如下：</p><p>[2, 10, s]</p><p>[3, 15, s]</p><p>[5, 12, s]</p><p>[7, 15, e]</p><p>[9, 10 , e]</p><p>[12, 12, e]</p><p>[15, 10, s]</p><p>[19, 8, s]</p><p>[20, 10, e]</p><p>[24, 8, e]</p><p>接下来就可以正式处理这些点了：</p><p>需要的结构体：平衡树，初始值为0（假定也是一个矩形）；数组，存放和排序上述点。</p><p>对于某个具体点：</p><p>​如果是起始点，将高度插入树中（相当于生成建筑物），并且如果高度大于最大高度，输出这个点。</p><p>​如果是结束点，将该高度从树中移除（相当于销毁建筑物），并且如果移除的高度同时是最大高度，则输出该点的横坐标和新的最大高度（即交叉点），<strong>但一种情况除外，即两建筑物一生成一摧毁并且高度恰好相同时不能输出为轮廓点！</strong></p><br><p>以下是使用了c++ map 结构的代码，具体map存储高度的方式见代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//BuildingPoint,存储是否为起始点，该点的横坐标和该点的高度</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">BuildingPoint</span>&#123;<br>    <span class="hljs-type">bool</span> isStart;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> height;<br>    <span class="hljs-built_in">BuildingPoint</span>(<span class="hljs-type">bool</span> flag, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> h)&#123;<br>        isStart = flag;<br>        x = index;<br>        height = h;<br>    &#125;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> BuildingPoint&amp; a)<span class="hljs-type">const</span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>-&gt;x &lt; a.x)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>-&gt;x &gt; a.x)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//如果横坐标相同</span><br>            <span class="hljs-comment">//同为s,先放高的</span><br>            <span class="hljs-comment">//同为e,先放矮的</span><br>            <span class="hljs-comment">//一s一e,先放s</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>-&gt;isStart &amp;&amp; a.isStart)&#123;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>-&gt;height &gt;= a.height)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">this</span>-&gt;isStart &amp;&amp; !a.isStart)&#123;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>-&gt;height &lt;= a.height)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>-&gt;isStart)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">skyLine</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; buildings)&#123;<br>    <span class="hljs-comment">//用来存放高度的平衡树,键值分别为高度和出现的次数</span><br>    map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; heightCounts;<br>    <span class="hljs-comment">//当前的最大高度</span><br>    <span class="hljs-type">int</span> maxHeight = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//当前高度</span><br>    <span class="hljs-type">int</span> currentHeight;<br>    <span class="hljs-comment">//存放buildPoint的数组</span><br>    vector&lt;BuildingPoint&gt; BuildingPoints;<br>    <span class="hljs-comment">//存放结果的数组</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br><br>    <span class="hljs-comment">//初始化</span><br>    <span class="hljs-comment">//初始化heightCounts</span><br>    heightCounts[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">//先把所有buildings中的数据放入数组中</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it = buildings.<span class="hljs-built_in">begin</span>(); it != buildings.<span class="hljs-built_in">end</span>(); it++)&#123;<br>        <span class="hljs-type">int</span> startIndex = it-&gt;<span class="hljs-built_in">at</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> endIndex = it-&gt;<span class="hljs-built_in">at</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> height = it-&gt;<span class="hljs-built_in">at</span>(<span class="hljs-number">2</span>);<br>        BuildingPoints.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">BuildingPoint</span>(<span class="hljs-literal">true</span>, startIndex, height));<br>        BuildingPoints.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">BuildingPoint</span>(<span class="hljs-literal">false</span>, endIndex, height));<br>    &#125;<br>    <span class="hljs-comment">//对该数组进行排序</span><br>    <span class="hljs-built_in">sort</span>(BuildingPoints.<span class="hljs-built_in">begin</span>(), BuildingPoints.<span class="hljs-built_in">end</span>());<br><br>    <span class="hljs-comment">//循环处理</span><br>    <span class="hljs-comment">//对于某个具体点：</span><br>    <span class="hljs-comment">//如果是起始点，将高度插入树中，并且如果高度大于最大高度，输出这个点。</span><br>    <span class="hljs-comment">//如果是结束点，将该高度从树中移除，并且如果移除的高度同时是最大高度，则输出该点的横坐标和新的最大高度（即交叉点）。</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it = BuildingPoints.<span class="hljs-built_in">begin</span>(); it != BuildingPoints.<span class="hljs-built_in">end</span>(); it++)&#123;<br>        <span class="hljs-keyword">if</span>(it-&gt;isStart)&#123;<br>            <span class="hljs-comment">//如果是起点，放入heightCounts中</span><br>            <span class="hljs-keyword">if</span>(heightCounts.<span class="hljs-built_in">count</span>(it-&gt;height) &lt;= <span class="hljs-number">0</span>)&#123;<br>                heightCounts[it-&gt;height] = <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                heightCounts[it-&gt;height]++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(it-&gt;height &gt; maxHeight)&#123;<br>                ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(&#123;it-&gt;x, it-&gt;height&#125;));<br>                maxHeight = it-&gt;height;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//弹出这个结束坐标的高度</span><br>            currentHeight = it-&gt;height;<br>            <span class="hljs-keyword">if</span>(heightCounts[currentHeight] == <span class="hljs-number">1</span>)&#123;<br>                heightCounts.<span class="hljs-built_in">erase</span>(currentHeight);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                heightCounts[currentHeight]--;<br>            &#125;<br><br>            <span class="hljs-comment">//如果同时是最大值，则更新最大高度，输出当前坐标值和新的最大高度</span><br>            <span class="hljs-keyword">if</span>(currentHeight == maxHeight)&#123;<br>                maxHeight = heightCounts.<span class="hljs-built_in">rbegin</span>()-&gt;first;<br>                <span class="hljs-keyword">if</span>(maxHeight != currentHeight)&#123;<span class="hljs-comment">//特殊情况：高度相等时不能作为轮廓点</span><br>                    ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(&#123;it-&gt;x, maxHeight&#125;));<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>核心思想</strong></p><p>利用优先队列或者平衡树结构来存储建筑物，以实时根据最大高度输出结果。</p><br><p>参考解法链接：</p><p><a href="https://www.youtube.com/watch?v=GSBLe8cKu0s">Skyline Problem</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>优先队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>逆向分析-除法优化MagicNumber算法逆向</title>
    <link href="/2023/01/10/%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"/>
    <url>/2023/01/10/%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="逆向分析-除法优化MagicNumber算法逆向"><a href="#逆向分析-除法优化MagicNumber算法逆向" class="headerlink" title="逆向分析-除法优化MagicNumber算法逆向"></a>逆向分析-除法优化MagicNumber算法逆向</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在汇编指令中，除法运算一般使用<strong>有符号除法指令idiv</strong>或者<strong>无符号除法指令div</strong>。但是，除法指令的执行周期较长，效率较低，因此编译器会想办法用其他执行周期短的指令来等效替代除法指令。</p><p>在C&#x2F;C++中，除法运算不会保留余数，如果要计算余数可以通过取模运算获得。对于整数除法，C&#x2F;C++只会保留整数部分，且为<strong>向0取整</strong>。</p><p>C&#x2F;C++除法规定：</p><p>两个无符号整数相除，结果仍然是无符号</p><p>两个有符号整数相除，结果仍然是有符号</p><p>无符号和有符号混除，有符号数的最高位被当作数据位参与无符号运算，结果为无符号数</p><p>当除数为常数时，编译器可以根据4种情况对除法进行优化：</p><ul><li>除数为正的2的幂</li><li>除数为负的2的幂</li><li>除数为正的非2的幂</li><li>除数为负的非2的幂</li></ul><p>其中，后2种情况的除法优化会需要计算Magic Number，本文分析了C2.dll计算Magic Number部分的反汇编代码。C2.dll是VC++编译器下的一个动态库，其中包含了编译C&#x2F;C++文件用到的函数，用到的版本为12.0.9782.0</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><h3 id="定位代码地址"><a href="#定位代码地址" class="headerlink" title="定位代码地址"></a>定位代码地址</h3><p>使用PEView打开C2.dll文件，根据已知信息，待逆向代码的文件位置在0x1075FACE处，而.text节的PointertoRawData&#x3D;0x2000, RVA&#x3D;0x1000, 如下图所示：</p><p><img src="/2023/01/10/%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/image-20220530201752343.png" alt="image-20220530201752343"></p><p>因此代码的虚拟地址为0x1075FACE + 0x1000 - 0x2000 &#x3D; 0x1075EACE，接下来就可以使用IDA定位到该地址进行逆向分析</p><h3 id="代码行为分析"><a href="#代码行为分析" class="headerlink" title="代码行为分析"></a>代码行为分析</h3><p>函数从地址0x1075EACE处开始执行，函数的开头如下：</p><p><img src="/2023/01/10/%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/image-20220521145933400.png" alt="image-20220521145933400"></p><p>在函数的入口，函数为两个4字节类型的局部变量申请了空间，在地址0x1075EAD1处，函数直接使用了ecx寄存器，说明函数调用约定为__fastcall, 且首个参数为4字节大小。该参数紧接着进行了2次大小比较，在最左边的分支中，函数直接返回了magic_table[ecx * 8]的地址，从该指令可以猜测函数的返回值为一个大小8字节的结构体的地址，查看magic_table处的内容，发现该地址位于全局数据区：</p><p><img src="/2023/01/10/%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/image-20220521150521087.png" alt="image-20220521150521087"></p><p>分析该地址处的数组，发现数据确实大概按照4字节进行对齐排列，符合之前的猜测</p><p>接着分析右边的分支代码，在地址0x1075EAEF处，发现类似于求绝对值的代码块</p><p><img src="/2023/01/10/%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/image-20220521150954240.png" alt="image-20220521150954240"></p><p>之后函数进行了一些除法和取模的运算，然后进入循环体，其中，跳出循环体的代码主要在以下部分：</p><p><img src="/2023/01/10/%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/image-20220521153234287.png" alt="image-20220521153234287"></p><p>只有满足这3处跳转指令才能够继续循环，猜测while的判断部分为比较复杂的逻辑表达式</p><p>而在循环体内，代码包含一些分支结构和简单的四则运算，猜测和算法本身有关。</p><p>在函数的最后，代码修改了dword_1079F090处的数据，且将其地址作为返回值：</p><p><img src="/2023/01/10/%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/image-20220521153705191.png" alt="image-20220521153705191"></p><p>跳转到相应地址处发现，该变量为全局变量：</p><p><img src="/2023/01/10/%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/image-20220521154220862.png" alt="image-20220521154220862"></p><p>进一步分析可知，在地址0x1075EB93处，该变量的后4个字节也被修改了，回顾函数在第一个跳转分支中同样返回了一个大小为8字节的结构体的地址，可以猜测这个全局变量的大小也为8字节</p><p><strong>分析小结</strong></p><p>被访问自定义结构体：包含两个4字节变量</p><p>被访问全局数组：元素类型为上述结构体</p><p>函数参数：1个，大小为4字节</p><p>函数返回值：结构体地址</p><p>推断函数行为：使用除数计算MagicNumber以及指数的幂（见算法部分），然后封装成结构体返回</p><h3 id="算法逆向"><a href="#算法逆向" class="headerlink" title="算法逆向"></a>算法逆向</h3><h4 id="阶段一"><a href="#阶段一" class="headerlink" title="阶段一"></a>阶段一</h4><p>根据汇编指令，比较初步地还原出算法全过程</p><p>根据代码行为还原出的MagicInfo结构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MagicInfo</span><br>&#123;<br><span class="hljs-type">int</span> magicNumber;<br><span class="hljs-type">int</span> expInc;<br>&#125;;<br></code></pre></td></tr></table></figure><p>根据全局变量还原出的MagicInfo速查表，其主要用于快速计算除数较小的MagicNumber：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MagicInfo</span> g_MagicInfoArray[] = &#123;<br>  &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;,           <span class="hljs-comment">// 0 </span><br>  &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;,           <span class="hljs-comment">// 1</span><br>  &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;,           <span class="hljs-comment">// 2</span><br>  &#123;<span class="hljs-number">0x55555556</span>, <span class="hljs-number">0</span>&#125;,<br>  &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;,           <span class="hljs-comment">// 4</span><br>  &#123;<span class="hljs-number">0x66666667</span>, <span class="hljs-number">1</span>&#125;,<br>  &#123;<span class="hljs-number">0x2AAAAAAB</span>, <span class="hljs-number">0</span>&#125;,<br>  &#123;<span class="hljs-number">0x92492493</span>, <span class="hljs-number">2</span>&#125;,<br>  &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;,           <span class="hljs-comment">// 8</span><br>  &#123;<span class="hljs-number">0x38E38E39</span>, <span class="hljs-number">1</span>&#125;,<br>  &#123;<span class="hljs-number">0x66666667</span>, <span class="hljs-number">2</span>&#125;,<br>  &#123;<span class="hljs-number">0x2E8BA2E9</span>, <span class="hljs-number">1</span>&#125;,<br>  &#123;<span class="hljs-number">0x2AAAAAAB</span>, <span class="hljs-number">1</span>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>对算法直接还原后得到的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MagicInfo</span> g_result;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MagicInfo</span>* <span class="hljs-built_in">CalculateMagicInfoOrigin</span>(<span class="hljs-type">int</span> divisor) &#123;<br><span class="hljs-type">int</span> p = <span class="hljs-number">31</span>;<br><span class="hljs-type">int</span> var_4 = divisor;<br><span class="hljs-comment">// ecx: divisor</span><br><span class="hljs-comment">// edx: pExpInc</span><br><span class="hljs-keyword">if</span> (divisor &gt;= <span class="hljs-number">3</span> &amp;&amp; divisor &lt; <span class="hljs-number">13</span>) &#123;<br><span class="hljs-keyword">return</span> &amp;g_MagicInfoArray[divisor];<br>&#125;<br><span class="hljs-comment">// loc_1075EAEA</span><br><span class="hljs-comment">// eax &lt;- divisor</span><br><span class="hljs-comment">// cdq: edx = eax &gt;&gt; 31(SIGN)</span><br><span class="hljs-comment">// edi &lt;- eax</span><br><span class="hljs-comment">// xor edi, edx</span><br><span class="hljs-comment">// sub edi, edx</span><br><span class="hljs-comment">// edi: absDivisor</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> eax1;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> esi1;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> absDivisor;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> ebp1, ebx1, ecx1, edx1;<br><br>absDivisor = <span class="hljs-built_in">abs</span>(divisor);<br>esi1 = ((<span class="hljs-type">unsigned</span>)divisor &gt;&gt; <span class="hljs-number">31</span>) - EXP31;<span class="hljs-comment">// nLargestMultiple</span><br><br>eax1 =  esi1 / absDivisor;<span class="hljs-comment">// div edi </span><br>esi1 = esi1 - esi1 % absDivisor;<span class="hljs-comment">// sub esi, edx</span><br>esi1--;<br><br>eax1 =  EXP31 / esi1;<span class="hljs-comment">// div esi// q1</span><br><br><br>ebp1 = eax1;<span class="hljs-comment">// mov ebp, eax//q1</span><br>eax1 = (<span class="hljs-type">int</span>)eax1 * (<span class="hljs-type">int</span>)esi1;<span class="hljs-comment">// imul eax, esi</span><br>ebx1 = EXP31;<br>ebx1 -= eax1;<span class="hljs-comment">// r1</span><br><br>eax1 = EXP31 / absDivisor;<span class="hljs-comment">// div edi// nMagicNumber</span><br><br>ecx1 = eax1;<br>eax1 = (<span class="hljs-type">int</span>)eax1 * (<span class="hljs-type">int</span>)absDivisor;<span class="hljs-comment">// imul eax, edi</span><br>edx1 = EXP31 - eax1;<span class="hljs-comment">// sub edx, eax</span><br><br><span class="hljs-comment">// loc_1075EB47</span><br><span class="hljs-comment">// LOOP_BEGIN</span><br><span class="hljs-keyword">do</span> &#123;<br><span class="hljs-comment">// mov eax, var_8</span><br><span class="hljs-comment">// inc eax</span><br><span class="hljs-comment">//eax1 = var_8 + 1;</span><br>p += <span class="hljs-number">1</span>;<br>ebx1 = ebx1 + ebx1;<span class="hljs-comment">// add ebx, ebx</span><br>ebp1 = ebp1 + ebp1;<br><br><span class="hljs-comment">//var_8 = eax1;</span><br><span class="hljs-keyword">if</span> (ebx1 &gt;= esi1) &#123;<br><span class="hljs-comment">// loc_1078F407</span><br>ebp1++;<br>ebx1 -= esi1;<br>&#125;<br><span class="hljs-comment">// loc_1075EB5C</span><br>edx1 += edx1;<br>ecx1 += ecx1;<br><span class="hljs-keyword">if</span> (edx1 &gt;= absDivisor) &#123;<span class="hljs-comment">//cmp edx, edi</span><br>ecx1++;<br>edx1 -= absDivisor;<br>&#125;<br><span class="hljs-comment">// loc_1075EB3F</span><br>eax1 = absDivisor;<br>eax1 -= edx1;<br><span class="hljs-comment">//if (ebp1 &lt; eax1)goto LOOP_BEGIN;</span><br><span class="hljs-comment">//if (ebp1 == eax1) &#123;</span><br><span class="hljs-comment">//// loc_1078F40F</span><br><span class="hljs-comment">//if (ebx1 == 0)goto LOOP_BEGIN;</span><br><span class="hljs-comment">//break;</span><br><span class="hljs-comment">//&#125;</span><br>&#125; <span class="hljs-keyword">while</span> ((ebp1 &lt; eax1) || (ebp1 == eax1 &amp;&amp; ebx1 == <span class="hljs-number">0</span>));<br><span class="hljs-comment">// loc_1075EB6F</span><br>eax1 = ecx1 + <span class="hljs-number">1</span>;<br>ecx1 = var_4;<br>g_result.magicNumber = eax1;<span class="hljs-comment">// mov ds:dword_1079F090, eax</span><br><span class="hljs-keyword">if</span>((<span class="hljs-type">int</span>)ecx1 &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">// loc_1078F41C</span><br>eax1 = -(<span class="hljs-type">int</span>)eax1;<br>g_result.magicNumber = eax1; <span class="hljs-comment">// mov ds : dword_1079F090, eax</span><br>&#125;<br><span class="hljs-comment">// loc_1075EB87</span><br>ecx1 = p;<br><span class="hljs-comment">// eax1 = (int) &amp; g_result; //mov eax, offset dword_1079F090;</span><br>ecx1 += <span class="hljs-number">-32</span>; <span class="hljs-comment">//0x0FFFFFFE0</span><br>g_result.expInc = ecx1; <span class="hljs-comment">// mov ds : dword_1079F094, ecx</span><br><span class="hljs-keyword">return</span> &amp;g_result;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="阶段二"><a href="#阶段二" class="headerlink" title="阶段二"></a>阶段二</h4><p>对代码进行整理，提取出关键变量并给其命名，对部分冗余的指令进行合并：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MagicInfo</span> g_result;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MagicInfo</span>* <span class="hljs-built_in">CalculateMagicInfo</span>(<span class="hljs-type">int</span> divisor) &#123;<br><span class="hljs-type">int</span> p = <span class="hljs-number">31</span>;<br><span class="hljs-keyword">if</span> (divisor &gt;= <span class="hljs-number">3</span> &amp;&amp; divisor &lt; <span class="hljs-number">13</span>) &#123;<br><span class="hljs-keyword">return</span> &amp;g_MagicInfoArray[divisor];<br>&#125;<br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> q1, r1, q2, r2, nc, delta, absDivisor;<br><br>absDivisor = <span class="hljs-built_in">abs</span>(divisor);<br>nc = ((<span class="hljs-type">unsigned</span>)divisor &gt;&gt; <span class="hljs-number">31</span>) - EXP31;<br>nc = nc - nc % absDivisor - <span class="hljs-number">1</span>;<br>q1 = EXP31 / nc;<br>r1 = EXP31 % nc;<br>q2 = EXP31 / absDivisor;<br>r2 = EXP31 % absDivisor;<br><span class="hljs-keyword">do</span> &#123;<br>p += <span class="hljs-number">1</span>;<br>r1 *= <span class="hljs-number">2</span>;<br>q1 *= <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span> (r1 &gt;= nc)&#123;<br>q1 += <span class="hljs-number">1</span>;<br>r1 -= nc;<br>&#125;<br>r2 *= <span class="hljs-number">2</span>;<br>q2 *= <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span> (r2 &gt;= absDivisor) &#123;<br>q2 += <span class="hljs-number">1</span>;<br>r2 -= absDivisor;<br>&#125;<br>delta = absDivisor - r2;<br>&#125; <span class="hljs-keyword">while</span> ((q1 &lt; delta) || (q1 == delta &amp;&amp; r1 == <span class="hljs-number">0</span>));<br><br>g_result.magicNumber = q2 + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (divisor &lt; <span class="hljs-number">0</span>) &#123;<br>g_result.magicNumber = -g_result.magicNumber;<span class="hljs-comment">//~(q2 + 1) + 1;</span><br>&#125;<br><br>g_result.expInc = p - <span class="hljs-number">32</span>;<br><span class="hljs-keyword">return</span> &amp;g_result;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="MagicNumber正确性验证"><a href="#MagicNumber正确性验证" class="headerlink" title="MagicNumber正确性验证"></a>MagicNumber正确性验证</h4><p>判断逆向的算法是否正确，最好的办法就是将”赝品“和真品直接进行比较。本文中，我通过动态加载C2.dll函数库，直接调用计算Magic Number的原函数，并验证了整型范围内的所有除数输入，结果证明，两者的输出是一模一样的</p><p><img src="/2023/01/10/%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/image-20220521180252802.png" alt="image-20220521180252802"></p><h4 id="除法正确性验证"><a href="#除法正确性验证" class="headerlink" title="除法正确性验证"></a>除法正确性验证</h4><p>本文又测试了INT_MIN除以所有整型的结果并和原结果进行比较，两者的输出同样是一模一样的</p><p><img src="/2023/01/10/%E8%BD%AF%E4%BB%B6%E9%80%86%E5%90%91%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/image-20220521164513642.png" alt="image-20220521164513642"></p><p>验证代码见源项目。</p><h2 id="算法证明"><a href="#算法证明" class="headerlink" title="算法证明"></a>算法证明</h2><p>本文只讨论有符号数除法的优化中MagicNumber的算法</p><h3 id="前置定理"><a href="#前置定理" class="headerlink" title="前置定理"></a>前置定理</h3><p><strong>推导D2</strong><br>$$<br>\lfloor \frac{n}{d} \rfloor &#x3D; \lceil \frac{n - d + 1}{d} \rceil\ and\ \lceil \frac {n}{d} \rceil &#x3D; \lfloor \frac{n + d - 1}{d} \rfloor,\quad  for\ d &gt; 0<br>$$</p><p>$$<br>\lfloor \frac{n}{d} \rfloor &#x3D; \lceil \frac{n - d - 1}{d} \rceil\ and\ \lceil \frac {n}{d} \rceil &#x3D; \lfloor \frac{n + d + 1}{d} \rfloor,\quad  for\ d &lt; 0<br>$$</p><p><strong>推导D4</strong></p><p>如果$d \neq 0$，$x \in R$，则有：<br>$$<br>\lfloor \frac {n}{d} + x \rfloor &#x3D; \lfloor \frac{n}{d} \rfloor\quad if\ 0 \leq x &lt; |\frac{1}{d}|\<br>\lceil \frac {n}{d} + x \rceil &#x3D; \lceil \frac{n}{d} \rceil\quad if\ -|\frac{1}{d}| &lt; x \leq 0<br>$$</p><p>定义部分变量如下：</p><p>$n$: 被除数</p><p>$d$: 除数</p><p>$q$: 商</p><p>$r$: 余数</p><p>$M$: Magic Number</p><h3 id="情况1：-d-geq-2"><a href="#情况1：-d-geq-2" class="headerlink" title="情况1：$d \geq 2$"></a>情况1：$d \geq 2$</h3><p>设一个普通字的二进制位数为$W$，例如，32位整型的$W &#x3D; 32$，则有$2 \leq d &lt; 2^{W-1}$，我们希望找到一个最小的整数$m$和整数$p$使得</p><p>$$<br>\lfloor \frac{mn}{2^p} \rfloor &#x3D; \lfloor \frac{n}{d} \rfloor, \quad for\ 0 \leq  n &lt; 2^{W - 1} \tag {1a}<br>$$</p><p>$$<br>\lfloor \frac{mn}{2^p} \rfloor + 1 &#x3D; \lceil \frac{n}{d} \rceil, \quad for \ -2^{W - 1} \leq n \leq -1, \quad\ with\ 0 \leq m &lt; 2^W \ and\ p \geq W \tag{1b}<br>$$</p><p>选用最小整数$m$的原因是，一个更小的乘数能够得到一个更小的移位数，同时$p \geq W$ 是因为生成的代码会在$mn$的低半部分产生移位，如32位情况下edx的内容就是乘法运算后右移32位的数据</p><p>注意到，Magic Number是实际参与乘法指令运算的数字，记为$M$, 其与算法中表述的$m$之间的关系为：<br>$$<br>\begin{equation}<br>M&#x3D;<br>    \begin{cases}<br>    m, \quad\quad\quad\ \ if \ 0 \leq m &lt; 2^{W - 1},\<br>    m - 2^W, \quad if\ 2^{W - 1} \leq m &lt; 2^W\<br>    \end{cases}</p><p>\end{equation}<br>$$<br>由于公式(1b)必须满足$n &#x3D; -d$，$\lfloor -md &#x2F; 2^p \rfloor + 1 &#x3D; -1$, 也就是：<br>$$<br>\frac{md}{2^p} &gt; 1 \tag2<br>$$<br>令$n_c$为$n$的最大整数，并且$n_c \equiv d - 1(mod\ d)$，$n_c$一定存在因为有$n_c &#x3D; d - 1$，且有<br>$$<br>n_c &#x3D; \lfloor 2^{W - 1}&#x2F;d \rfloor d- 1 &#x3D; 2^{W - 1} - 2^{W - 1}mod\ d - 1<br>$$<br>同时，$n_c$是$n$的最大可接受值，因此有：<br>$$<br>2^{W - 1} - d \leq n_c\leq 2^{W - 1} - 1 \tag{3a}<br>$$</p><p>$$<br>n_c \geq d - 1 \tag{3b}<br>$$</p><p>由于公式(1a)必须满足$n &#x3D; n_c$：<br>$$<br>\lfloor \frac{mn_c}{2^p} \rfloor &#x3D; \lfloor \frac{n_c}{d} \rfloor &#x3D; \frac{n_c - (d - 1)}{d}<br>$$<br>或者：<br>$$<br>\frac{mn_c}{2^p} &lt; \frac{n_c + 1}{d}<br>$$<br>结合公式(2)有：<br>$$<br>\frac{2^p}{d} &lt; m &lt; \frac{2^p}{d} \frac{n_c + 1}{n_c} \tag4<br>$$<br>因为$m$是满足(4)式的最小整数, 它也是大于$2^p&#x2F;d$的下一个整数，即：<br>$$<br>m &#x3D; \frac{2^p + d - 2^p\ mod \ d}{d} \tag5<br>$$<br>结合此式和(4)式的右部有：<br>$$<br>2^p &gt; n_c (d - 2^p\ mod\ d) \tag6<br>$$<br>由上述推导可知，该算法旨在找到Magic Number $M$ 和右移数$s$ 来计算$n_c$， 然后带入(6)式判断是否满足不等式，如果不满足则尝试更大的$p$和$n_c$。这里只讨论$p \geq W$的情况，该情况下，$m$可以通过(5)式直接计算得到</p><p>然而，如果$p$和$m$是通过(6)和(5)式计算得到的，那么它们必须满足式(1a)和(1b)，根据(4)式将$n$划分成以下5种情况：<br>$$<br>0 \leq n \leq n_c\<br>n_c + 1 \leq n \leq n_c + d - 1\<br>-n_c \leq n \leq -1\<br>-n_c - d + 1 \leq n \leq -n_c - 1\<br>n &#x3D; -n_c - d<br>$$<br>根据式(4)，因为$m$为整数，有：<br>$$<br>\frac{2^p}{d} &lt; m \leq \frac{2^p(n_c + 1) - 1}{dn_c}<br>$$<br>两边同时乘以$n&#x2F;2^p$， 对于$n \geq 0$有：<br>$$<br>\frac{n}{d} \leq \frac{mn}{2^p} \leq \frac{2^p n(n_c + 1) - n}{2^p d n_c}<br>$$<br>因此有：<br>$$<br>\lfloor \frac{n}{d} \rfloor \leq \lfloor \frac{mn}{2^p}\rfloor \leq \lfloor \frac{n}{d} + \frac{(2^p - 1)n}{2^p d n_c} \rfloor<br>$$<br>对于$0 \leq n \leq n_c$，$0 \leq (2^p - 1)n&#x2F;(2^p d n_c) &lt; 1&#x2F;d$， 根据D4有：<br>$$<br>\lfloor \frac{n}{d} + \frac{(2^p - 1)n}{2^p d n_c} \rfloor &#x3D; \lfloor \frac{n}{d} \rfloor<br>$$<br>因此该情况下(1a)式满足</p><p>对于$n &gt; n_c$， $n$被限制在范围：<br>$$<br>n_c + 1 \leq n \leq n_c + d - 1 \tag 9<br>$$<br>因为$n \geq n_c + d$ 和$n_c$的选择冲突，根据式(4)，对于$n\geq 0$,<br>$$<br>\frac{n}{d} &lt; \frac{mn}{2^p} &lt; \frac{n}{d} \frac{n_c + 1}{n_c}<br>$$<br>由四则运算推导得：<br>$$<br>\frac{n}{d} &lt; \frac{mn}{2^p} &lt; \frac{n_c + 1}{d} + \frac{(n - n_c)(n_c + 1)}{d n_c} \tag{10}<br>$$<br>根据(9)，$1\leq n - n_c \leq d - 1$，因此：<br>$$<br>0 &lt; \frac{(n - n_c)(n_c + 1)}{d n_c} \leq \frac{d - 1}{d} \frac{n_c + 1}{n_c}<br>$$<br>因为$n_c &gt; d - 1$ (3b) 并且 $(n_c + 1) &#x2F; n_c $取最大值时$n_c$取最小值，因此有：<br>$$<br>0 &lt; \frac{(n - n_c)(n_c + 1)}{d n_c} \leq \frac{d - 1}{d} \frac{d - 1 + 1}{d - 1} &#x3D; 1<br>$$<br>在(10)式中，$(n_c + 1)&#x2F;d$ 是一个整数，$(n - n_c)(n_c + 1)&#x2F;d n_c$ 小于或者等于1， 因此(10)式变为：<br>$$<br>\lfloor \frac{n}{d} \rfloor \leq \lfloor \frac{mn}{2^p} \rfloor \leq \frac{n_c + 1}{d}<br>$$<br>对于(9)式中的$n$，$\lfloor n&#x2F;d \rfloor &#x3D; (n_c + 1)&#x2F;d$，因此(1a)满足情况$(n_c + 1 \leq n \leq n_c + d - 1)$</p><p>对于$n &lt; 0$, 从(4)式中我们有，因为$m$是一个整数，则：<br>$$<br>\frac{2^p + 1}{d} \leq m &lt; \frac{2^p}{d} \frac{n_c + 1}{n_c}<br>$$<br>乘以$n&#x2F;2^p$后，对于$n&lt;0$有：<br>$$<br>\frac{n}{d} \frac{n_c + 1}{n_c} &lt; \frac{mn}{2^p} \leq \frac{n}{d} \frac{2^p + 1}{2^p}<br>$$<br>或者：<br>$$<br>\lfloor \frac{n}{d} \frac{n_c + 1}{n_c} \rfloor + 1 &lt; \lfloor \frac{mn}{2^p} \rfloor + 1 \leq \lfloor \frac{n}{d} \frac{2^p + 1}{2^p} \rfloor + 1<br>$$<br>根据D2推导得到：<br>$$<br>\lceil \frac{n(n_c + 1) - d n_c + 1}{d n_c}  \rceil + 1 &lt; \lfloor \frac{mn}{2^p} \rfloor + 1 \leq \lceil \frac{n(2^p + 1) - 2^p d + 1}{2^p d} \rceil + 1\<br>\lceil \frac{n(n_c + 1) + 1}{d n_c}  \rceil &lt; \lfloor \frac{mn}{2^p} \rfloor + 1 \leq \lceil \frac{n(2^p + 1) + 1}{2^p d} \rceil<br>$$<br>由于$n + 1 \leq 0$, 右边的不等式可以被缩放，有：<br>$$<br>\lceil \frac{n}{d} + \frac{n + 1}{d n_c}  \rceil &lt; \lfloor \frac{mn}{2^p} \rfloor + 1 \leq \lceil \frac{n}{d} \rceil<br>$$<br>对于 $-n_c \leq n \leq -1 $，<br>$$<br>\frac{-n_c + 1}{d n_c} \leq \frac{n + 1}{d n_c} \leq 0, or\<br>-\frac{1}{d} &lt; \frac{n + 1}{d n_c} \leq 0<br>$$<br>因此根据D4有：<br>$$<br>\lceil \frac{n}{d} + \frac{n + 1}{d n_c} \rceil &#x3D; \lceil \frac{n}{d} \rceil \tag{11}<br>$$<br>因此该情况下满足(1b)</p><p>对于$n &lt; -n_c $, $n$被限制在范围：<br>$$<br>-n_c - d \leq n \leq - n_c - 1 \tag{12}<br>$$<br>从(3a)式可知，$n &lt; -n_c - d$意味着$n &lt; -2^{W - 1}$， 这是不可能的情况。对(11)式的左部进一步运算得到：<br>$$<br>\lceil \frac{-n_c - 1}{d} + \frac{(n + n_c)(n_c + 1) + 1}{d n_c} \rceil \leq \lfloor \frac{mn}{2^p} \rfloor + 1 \leq \lceil \frac{n}{d} \rceil \tag{13}<br>$$<br>对于$-n_c - d + 1 \leq n \leq -n_c - 1$，<br>$$<br>\frac{(-d + 1)(n_c + 1)}{d n_c} + \frac{1}{dn_c} \leq \frac{(n + n_c)(n_c + 1) + 1}{d n_c} \leq \frac{-(n_c + 1) + 1}{d n_c} &#x3D; -\frac{1}{d}<br>$$<br>当$n_c$取最小值时，$(n_c + 1)&#x2F;n_c$取最大值，即$n_c &#x3D; d - 1$，因此有：<br>$$<br>\frac{(-d + 1)(d - 1 + 1)}{d(d-1)} + \frac{1}{d n_c} \leq \frac{(n + n_c)(n_c + 1) + 1}{d n_c} &lt; 0, or\<br>-1 &lt; \frac{(n + n_c)(n_c + 1) + 1}{d n_c} &lt; 0<br>$$<br>对于(13)式，因为$(-n_c - 1)&#x2F;d$是一个整数且它的增量在0到-1之间，则有：<br>$$<br>\frac{-n_c - 1}{d} \leq \lfloor \frac{mn}{2^p} \rfloor + 1 \leq \lceil \frac{n}{d} \rceil<br>$$<br>对于$-n_c - d + 1 \leq n \leq - n_c - 1$<br>$$<br>\lceil \frac{n}{d} \rceil &#x3D; \frac{-n_c - 1}{d}<br>$$<br>因此，$\lfloor mn&#x2F;2^p \rfloor + 1 &#x3D; \lceil n&#x2F;d \rceil $，(1b)式满足情况</p><p>对于最后一种情况，$n_c &#x3D; -n_c - d$，只对部分$d$的值出现，由(3a)可知，$-n_c - d \leq -2^{W - 1}$，所以如果$n$取到这个值，我们一定有$n &#x3D; -n_c - d &#x3D; -2^{W - 1}$, 因此$n_c &#x3D; 2^{W - 1} - d$, 因此，$2^{W - 1} \ mod\ d &#x3D; (n_c + d)\ mod\ d &#x3D; d - 1 $，即$d$除以$2^{W - 1} + 1$</p><p>对于$(n &#x3D; -n_c - d)$, (6)式有解$p &#x3D; W - 1$， 即$p$的最小可能值，<br>$$<br>n_c (d - 2^p\ mod\ d) &#x3D; (2^{W - 1} - d)(d - 2^{W - 1}\ mod\ d)\<br>&#x3D; (2^{W - 1} - d)(d - (d - 1)) &#x3D; 2^{W - 1} - d &lt; 2^{W - 1} &#x3D; 2^p<br>$$<br>由(5)式有：<br>$$<br>m &#x3D; \frac{2^{W - 1} +d - 2^{W - 1}\ mod\ d }{d} &#x3D; \frac{2^{W - 1} + d - (d - 1)}{d} &#x3D; \frac{2^{W - 1} + 1}{d}<br>$$<br>因此：<br>$$<br>\lfloor \frac{mn}{2^n} \rfloor +1 &#x3D; \lfloor \frac{2^{W - 1} + 1}{d} \frac{-2^{W - 1}}{2^{W - 1}} \rfloor + 1 \&#x3D; \lfloor \frac{-2^{W - 1} - 1}{d} \rfloor + 1<br>\&#x3D; \lceil \frac{-2^{W - 1} - d}{d} \rceil + 1\ &#x3D; \lceil \frac{-2^{W - 1}}{d} \rceil &#x3D; \lceil \frac{n}{d} \rceil<br>$$<br>满足(1b)式</p><h3 id="情况2：-d-leq-2"><a href="#情况2：-d-leq-2" class="headerlink" title="情况2：$d \leq -2$"></a>情况2：$d \leq -2$</h3><p>因为有符号除法满足$n&#x2F;(-d) &#x3D; -n&#x2F;d$，因此可以计算$n &#x2F; |d|$来间接得到结果，但如果想要避免使用neg指令的话，也可以进行类似于情况1的推导</p><p>对于$W \geq 3$并且$-2^{W - 1} \leq d \leq -2$，我们希望找到在绝对值上最小的整数$m$和整数$p$使得：<br>$$<br>\lfloor \frac{mn}{2^p} \rfloor &#x3D; \lfloor \frac{n}{d} \rfloor,\quad for\ -2^{W - 1} \leq n \leq 0 \tag{14a}<br>$$</p><p>$$<br>\lfloor \frac{mn}{2^n} \rfloor + 1 &#x3D; \lceil \frac{n}{d} \rceil, \quad for\ 1 \leq n &lt; 2^{W - 1} \tag{14b}<br>$$</p><p>$$<br>-2^W \leq m \leq 0, p \geq W<br>$$</p><p>令$n_c &#x3D; kd + 1, k \in Z_+$, 此时$n_c$是对于$|d|$的可接受的$n$值，因此：<br>$$<br>-2^{W - 1} \leq n_c \leq -2^{W - 1} - d - 1 \tag{15a}<br>$$</p><p>$$<br>n_c \leq d + 1 \tag{15b}<br>$$</p><p>因为(14b)式必须满足$n &#x3D; -d$, 且(14a)式必须满足$n &#x3D; n_c$， 类似于(4)式有：<br>$$<br>\frac{2^p}{d} \frac{n_c - 1}{n_c} &lt; m &lt; \frac{2^p}{d} \tag{16}<br>$$<br>因为$m$式满足(16)式的最大整数，因此它是比$2^p&#x2F;d$小的下一个整数，即：<br>$$<br>m &#x3D; \frac{2^p - d - 2^p\ mod\ d}{d} \tag{17}<br>$$<br>结合此式和(16)式的左部有：<br>$$<br>2^p &gt; n_c (d + 2^p\ mod\ d) \tag{18}<br>$$</p><p>最后，为了把运算限制在$W$字长内，需要做一些额外的处理</p><p>$n_c$能够通过下式计算得到：<br>$$<br>n_c &#x3D;<br>    \begin{cases}<br>    2^{W - 1} - 2^{W - 1}\ mod\ d - 1, \quad\quad\ \ if \ d &gt; 0,\<br>    -2^{W - 1} - (2^{W - 1}+1)\ mod\ d, \quad if\ d &lt; 0\<br>    \end{cases}<br>$$<br>因此有：<br>$$<br>t &#x3D; 2^{W - 1} + \begin{cases}<br>0,\quad if\ d &gt; 0,\<br>1,\quad if\ d &lt; 0<br>\end{cases}\  \tag{19}<br>|n_c| &#x3D; t - 1 - t\ mod\ |d|<br>$$<br>由(6)式和(18)式，$p$能够通过下式得到：<br>$$<br>2^p &gt; |n_c| (|d| - 2^p mod |d|)<br>$$<br>由(5)式和(17)式，$|m|$能够通过下式得到：<br>$$<br>|m| &#x3D; \frac{2^p + |d| - 2^p\ mod\ |d|}{|d|}<br>$$<br>为了不使用双字长计算$2^p\ mod\ |d|$, 可以令$q, r$分别为$2^p &#x2F; |d|, p &#x3D; W - 1$的商和余数，并且$q, r$随着$p$的增加而更新，具体方法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">q = <span class="hljs-number">2</span>*q;<br>r = <span class="hljs-number">2</span>*r;<br><span class="hljs-keyword">if</span>(r &gt;= <span class="hljs-built_in">abs</span>(d)) &#123;<br>    q = q + <span class="hljs-number">1</span>;<br>    r = r - <span class="hljs-built_in">abs</span>(d);<br>&#125;<br></code></pre></td></tr></table></figure><p>由(4)式左部和(16)式右部以及$m$的范围可以得到$q &#x3D; \lfloor 2^p&#x2F;|d| \rfloor &lt; 2^W$，此时$0\leq r &lt; |d|$，两者都在$W$字长内</p><p>接下来，计算$\delta &#x3D; |d| - r$，为了避免(19)式中的双字长乘法，将满足条件的式子重写为：<br>$$<br>\frac{2^p}{|n_c|} &gt; \delta<br>$$<br>为了计算$m$, 有：<br>$$<br>\frac{2^p + |d| - 2^p\ mod\ |d|}{|d|} &#x3D; \lfloor \frac{2^p}{|d|} \rfloor + 1 &#x3D; q + 1<br>$$<br>假设只有$q_1, r_1$能够满足条件，则$2^p&#x2F;|n_c| \leq \delta $可以表述为：<br>$$<br>q_1 &lt; \delta\ |\ (q_1 &#x3D; \delta\ &amp;\ r_1 &#x3D; 0)<br>$$<br>最后，把所有的情况汇总起来，算法可以写成如下形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ms</span> &#123;<br>    <span class="hljs-type">int</span> M; <span class="hljs-comment">// Magic Number</span><br>    <span class="hljs-type">int</span> s; <span class="hljs-comment">// shift amount</span><br>&#125;;<br><br><span class="hljs-comment">// 2 &lt;= d &lt;= 2**31 - 1 or -2**31 &lt;= d &lt;= -2</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ms</span> <span class="hljs-built_in">magic</span>(<span class="hljs-type">int</span> d)<br>&#123;<br>    <span class="hljs-type">int</span> p;<br>    <span class="hljs-type">unsigned</span> ad, anc, delta, q1, r1, q2, r2, t;<br>    <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> two31 = <span class="hljs-number">0x8000&#x27;0000</span>; <span class="hljs-comment">//2**31</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ms</span> = mag;<br>    <br>    ad = <span class="hljs-built_in">abs</span>(d);<br>    t = two31 + ((<span class="hljs-type">unsigned</span>)d &gt;&gt; <span class="hljs-number">31</span>);<br>    anc = t - <span class="hljs-number">1</span> - t%ad; <span class="hljs-comment">// absolute value of nc</span><br>    p = <span class="hljs-number">31</span>;<span class="hljs-comment">// init p</span><br>    q1 = two31/anc;<span class="hljs-comment">// init q1 = 2**p / |nc|</span><br>    r1 = two31 - q1*anc;<span class="hljs-comment">// init r1 = 2**p % |nc|</span><br>    q2 = two31/ad;<span class="hljs-comment">// init q2 = 2**p / |d|</span><br>    r2 = two31 - q2*ad; <span class="hljs-comment">// init r2 = 2**p / |d|</span><br>    <span class="hljs-keyword">do</span><br>    &#123;<br>        p = p + <span class="hljs-number">1</span>;<br>        q1 = <span class="hljs-number">2</span>*q1;<span class="hljs-comment">// update q1 = 2**p / |nc|</span><br>        r1 = <span class="hljs-number">2</span>*r1;<span class="hljs-comment">// update r1 = 2**p % |nc|</span><br>        <span class="hljs-keyword">if</span>(r1 &gt;= anc)<span class="hljs-comment">// must be an unsigned comparison</span><br>        &#123;<br>            q1 = q1 + <span class="hljs-number">1</span>;<br>            r1 = r1 - anc;<br>        &#125;<br>        a2 = <span class="hljs-number">2</span>*q2;<span class="hljs-comment">// update q2 = 2**p / |d|</span><br>        r2 = <span class="hljs-number">2</span>*r2;<span class="hljs-comment">// update r2 = 2**p % |d|</span><br>        <span class="hljs-keyword">if</span>(r2 &gt;= ad)<span class="hljs-comment">// must be an unsigned comparison</span><br>        &#123;<br>            q2 = q2 + <span class="hljs-number">1</span>;<br>            r2 = r2 - ad;<br>        &#125;<br>        delta = ad - r2;<br>    &#125;<span class="hljs-keyword">while</span>(q1 &lt; delta || (q1 == delta &amp;&amp; r1 == <span class="hljs-number">0</span>));<br>    mag.M = q2 + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(d &lt; <span class="hljs-number">0</span>)mag.M = -mag.M;<br>    mag.s = p - <span class="hljs-number">32</span>;<br>    <span class="hljs-keyword">return</span> mag;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>逆向分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>逆向分析</tag>
      
      <tag>汇编</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>全部查找树</title>
    <link href="/2023/01/10/%E5%85%A8%E9%83%A8%E6%9F%A5%E6%89%BE%E6%A0%91/"/>
    <url>/2023/01/10/%E5%85%A8%E9%83%A8%E6%9F%A5%E6%89%BE%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="全部查找树"><a href="#全部查找树" class="headerlink" title="全部查找树"></a>全部查找树</h1><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p>输出所有由数字1~n 组成的二叉搜索树。</p><p>eg:</p><p>n &#x3D; 2</p><p>answer: 1(,2), 2(1)</p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>我们先从所有数字中取出一个作为根节点，那么剩下的数字按大小划分刚好能各自形成一棵二叉树（没有数字的那半用空指针代替）。因此，我们可以用相同的方式产生该根节点的子树的所有情况，最后把左子树和右子树的情况组合起来，每一种组合都是一棵新树，这样，在遍历完根节点的所有情况之后，就可以得到答案。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;Node*&gt; <span class="hljs-title">BuildTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> e)</span></span>&#123;<br>    <span class="hljs-comment">//如果没有可以形成二叉树的数字，则返回空结点</span><br>    <span class="hljs-keyword">if</span>(s &gt; e)<span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;Node*&gt;(<span class="hljs-number">1</span>, <span class="hljs-literal">NULL</span>);<br>    <br>    vector&lt;Node*&gt; trees;<br>    <span class="hljs-comment">//遍历每一个根节点</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = s; i &lt;= e; i++)&#123;<br>        vector&lt;Node*&gt; left_trees = <span class="hljs-built_in">BuildTrees</span>(s, i - <span class="hljs-number">1</span>); <span class="hljs-comment">//所有左子树的情况</span><br>        vector&lt;Node*&gt; right_trees = <span class="hljs-built_in">BuildTrees</span>(i + <span class="hljs-number">1</span>, e);<span class="hljs-comment">//所有右子树的情况</span><br>        <span class="hljs-comment">//将每个左右子树组合起来形成一棵新的二叉树</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; left_trees.<span class="hljs-built_in">size</span>(); j++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; right_trees.<span class="hljs-built_in">size</span>(); k++)&#123;<br>                Node *root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(i, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>                root-&gt;left = left_trees[j];<br>                root-&gt;right = right_trees[k];<br>                trees.<span class="hljs-built_in">push_back</span>(root);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> trees;<br>&#125;<br><br><span class="hljs-function">vector&lt;Node*&gt; <span class="hljs-title">solution</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">BuildTrees</span>(<span class="hljs-number">1</span>, n);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>DFS</tag>
      
      <tag>二叉搜索树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>迷宫问题（1）—— 自动生成迷宫地图</title>
    <link href="/2023/01/10/%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98%EF%BC%881%EF%BC%89/"/>
    <url>/2023/01/10/%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98%EF%BC%881%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="迷宫问题（1）——-自动生成迷宫地图"><a href="#迷宫问题（1）——-自动生成迷宫地图" class="headerlink" title="迷宫问题（1）—— 自动生成迷宫地图"></a>迷宫问题（1）—— 自动生成迷宫地图</h1><p>在我学习数据结构期间，多次遇到使用特定的数据结构来实现走出迷宫的方案，因此兴趣使然，在网上找了一些自动生成迷宫地图的方法，发现基本还是使用的走迷宫时的算法，这里简单地设计一下，主要为了方便今后的代码实现和少写出一些bug。</p><h2 id="迷宫模型的搭建和选择恰当的数据结构"><a href="#迷宫模型的搭建和选择恰当的数据结构" class="headerlink" title="迷宫模型的搭建和选择恰当的数据结构"></a>迷宫模型的搭建和选择恰当的数据结构</h2><p>因为生活中常见的迷宫都有以下特点：</p><ol><li>迷宫一般都是矩形的或者正方形的。</li><li>迷宫一般只有墙作为障碍物，而且迷宫的周围就是一圈墙。</li><li>迷宫中会有死胡同，需要往回走。</li><li>迷宫应保证每一个点都是联通的，即不存在孤岛。</li><li>尽量不要设计回路（可能对某些算法有较大影响）。</li><li>迷宫的路径最好不要太明显，尽量保证有足够多的分支。</li></ol><p>综合以上，我们选择使用二维数组来存储迷宫，并且把每一堵墙和每一个可以到达的位置模拟为数组中的行列坐标，这么做能够保证墙和路的地位是平等的，便于进行处理。至于如何区分两者，设置成数组中不同的值就好（比如map[1] [1] &#x3D; 1 表示通路， map[2] [2] &#x3D; -1 表示墙。</p><p>对于生成迷宫地图的初始地图，这里的设置十分巧妙。</p><p>假设有一片矩形区域，里面整齐排列着m行n列可以行走的位置，但是在这些位置之间，每两个位置都有一堵墙。</p><p>又假设自己是一个矿工，你需要通过打通一些墙来使得起点和终点之间相互连通，同时这些通路满足迷宫的基本特点，这样迷宫就生成了。</p><p>也可以比喻成在一张地图上有许许多多个散点，我们的目的是在不生成回路的前提下，将每两个相邻的散点连接起来，这有点像图的结构了。</p><h2 id="迷宫随机生成算法——DFS"><a href="#迷宫随机生成算法——DFS" class="headerlink" title="迷宫随机生成算法——DFS"></a>迷宫随机生成算法——DFS</h2><p>DFS不仅可以用来走迷宫，它同样可以用来生成迷宫，并且具有以下特点：</p><ol><li>可以打通所有的可到达位置。</li><li>会有一条比较明显的主路。</li><li>不会也不能生成回路（否则会陷入死循环或者打通所有墙）。</li></ol><p>所以，基本思路是这样的：在当前位置寻找相邻的可以连通的位置（没有被打通过，在数组中需要跨越2个单位），在这些位置中随机选取一个（用rand( )函数），打通两个位置之间的墙，并且将当前位置用栈记录下来（或者其他顺序结构），再到达下个位置进行相同的操作。</p><p>如果没有可以连通的点了，就在栈中回溯之前的点，直到找到一个点有可以连通的相邻点，再重复上面的动作。</p><p>结束生成的条件是所有的点都没有可以连通的了，这是栈为空。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DFS</tag>
      
      <tag>迷宫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速幂</title>
    <link href="/2023/01/10/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    <url>/2023/01/10/%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
    
    <content type="html"><![CDATA[<h1 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h1><p>理论基础：<br>$$<br>a^bmod\space c &#x3D; ((a^2)^{b&#x2F;2})mod\space c, (b &#x3D; 0(mod\space 2))<br>\<br>\<br>a^bmod\space c &#x3D; ((a^2)^{b&#x2F;2} \times a)mod\space c, (b &#x3D; 1(mod\space 2))<br>$$<br>可以看作是递归函数，递归出口是b &#x3D; 0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">pow_mod</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> <br>&#123;<br>    <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(b % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> pow_mod((a * a) % c, b / <span class="hljs-number">2</span>， c) % c;<br>    <span class="hljs-keyword">return</span> (pow_mod((a * a) % c, b / <span class="hljs-number">2</span>, c) * a) % c;<br>&#125;<br></code></pre></td></tr></table></figure><p>写成非递归形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">pow_mod</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span> <br>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(b &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span>(b % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)<br>            ans = (ans * a) % c;<span class="hljs-comment">// 这里可以理解为，每次遇到b%2==1时，都会产生一个多余的a, 先把它存储在ans中，最后b=0时，就是(1*a)%c，因此直接输出结果</span><br>        a = (a * a) % c;<br>        b = b / <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>快速上手CS</title>
    <link href="/2023/01/10/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8BCS/"/>
    <url>/2023/01/10/%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8BCS/</url>
    
    <content type="html"><![CDATA[<h1 id="快速上手CS"><a href="#快速上手CS" class="headerlink" title="快速上手CS"></a>快速上手CS</h1><h2 id="常用关键字"><a href="#常用关键字" class="headerlink" title="常用关键字"></a>常用关键字</h2><h3 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h3><p>可以和类、方法、属性、索引器及事件一起使用（成员变量、委托不能使用）</p><p>在<strong>类声明</strong>中使用 abstract 修饰符以指示类只能是其他类的基类</p><p>在<strong>方法或属性声明</strong>中使用 abstract 修饰符以指示此方法或属性不包含实现</p><p><span style="color:blue;font-weight:bold">抽象类特征</span></p><p>1、抽象类<strong>不能实例化</strong></p><p>2、抽象类可以<strong>包含抽象方法和抽象访问器</strong></p><p>3、<strong>不能用 sealed</strong> 修饰符修改抽象类，这意味着该类不能被继承</p><p>4、从抽象类派生的<strong>非抽象类必须包括继承的所有抽象方法和抽象访问器的实现</strong></p><p>5、在抽象类中<strong>可以定义静态方法</strong></p><p><span style="color:blue;font-weight:bold">抽象方法特点</span></p><p>1、抽象方法是隐式的 virtual 方法</p><p>2、<strong>只允许在抽象类中使用</strong>抽象方法声明</p><p>3、因为抽象方法声明不提供实现，所以<strong>没有方法体</strong></p><p>4、实现由override方法提供，它是非抽象类的成员</p><p>5、在抽象方法声明中<strong>使用 static 或 virtual 修饰符是错误的</strong></p><p><span style="color:blue;font-weight:bold">抽象属性特点</span></p><p>1、在静态属性上使用 abstract 修饰符是错误的</p><p>2、在派生类中，通过包括使用 override 修饰符的属性声明可以重写抽象的继承属性</p><p>示例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">A</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> a;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span>[] arr;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ptr</span>()</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-built_in">int</span> b&#123;<span class="hljs-keyword">get</span>;<span class="hljs-keyword">set</span>;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method0</span>()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">event</span> ptr evt;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-built_in">string</span> <span class="hljs-keyword">this</span>[<span class="hljs-built_in">int</span> index]&#123;<span class="hljs-keyword">get</span>;<span class="hljs-keyword">set</span>;&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> c;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span>()</span><br>    &#123;<br>        System.Console.WriteLine(<span class="hljs-string">&quot;method&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>限定一个变量不允许被改变</p><p>1、用于修改字段或局部变量的声明，表示指定的字段或局部变量的值是<strong>常数</strong>，<strong>不能被修改</strong></p><p>2、常数声明的类型指定声明引入的成员类型。常数表达式必须产生具有目标类型或可隐式转换为目标类型的值</p><p>3、常数表达式是在编译时可被完全计算的表达式。因此<strong>不能从一个变量中提取值来初始化常量</strong></p><p>4、常数声明可以声明多个常数</p><p>5、<strong>不允许在常数声明中使用static修饰符</strong>，因为const默认为static</p><p>6、常数可以参与常数表达式：<code>const int c = 5; const int d = c + 10;</code></p><h3 id="others"><a href="#others" class="headerlink" title="others"></a>others</h3><ul><li><p>as: 安全的类型转换</p></li><li><p>is: 检查对象是否与给定的类型兼容</p></li><li><p>base：基类</p></li><li><p>byte: 一个字节</p></li><li><p>checked: 检查数值是否溢出</p></li><li><p>decimal: 128位数据类型，适用于财务和货币计算：<code>decimal myMonney = 99.9m;</code></p></li><li><p>enum：枚举：<code>enum Days&#123;Sun, Mon, Tue&#125;;</code></p></li><li><p>explicit: 强制类型转换</p>  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span><br>&#123;<br>...    <br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">B</span><br>&#123;<span class="hljs-comment">//将A强制转换成B</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">explicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">B</span>(<span class="hljs-params">A a</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> B(a);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>implicit: 隐式转换，方式同explicit</p></li><li><p>try&#x2F;catch&#x2F;throw&#x2F;finally: 用于处理异常，也可以实现多层嵌套内直接跳转到最外层</p></li><li><p>fixed：放置GC重新定位可移动的变量</p></li><li><p>goto：直接跳转到对应标签位置</p></li><li><p>internal：声明的类型或者成员只能在同一程集内访问</p></li><li><p>lock：与线程有关</p></li><li><p>out：类似于ref，但只能用来将值从方法中传出</p></li><li><p>params：可变长参数，在声明方法时参数类型或者个数不确定时使用<code>method(params Object[] objs)</code></p></li><li><p>readonly：动态常量，可在运行时赋值，可以被static修饰</p></li><li><p>sbyte: 有符号字节</p></li><li><p>sealed：被修饰的类或者方法不能被继承或者重写，密封方法必须对基类的虚方法进行重载，不能用来修饰成员变量</p></li><li><p>virtual: 用于修饰方法、属性、索引器或事件声明，并使它们可以在派生类中被重写</p></li><li><p>override：提供从基类继承的成员的新实现，被重写的属性必须是virtual, abstract 或者override的</p><p>  （函数和属性分为虚和非虚，只有虚方法才能被继承重写或者密封）</p></li><li><p>stackalloc: 在堆栈上分配内存块</p></li><li><p>struct: 结构体</p></li><li><p>uint, ulong, ushort: 无符号变量</p></li><li><p>volatile：字段可能被多个并发的执行线程修改</p></li><li><p>operator: 重载运算符</p></li></ul><h2 id="类、接口"><a href="#类、接口" class="headerlink" title="类、接口"></a>类、接口</h2><p>定义类:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> a;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">A</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> b=<span class="hljs-number">0</span></span>)   <span class="hljs-comment">//默认构造函数</span></span><br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        A a = <span class="hljs-keyword">new</span> A(); <span class="hljs-comment">//可以不用传递参数</span><br>    &#125;<br>    ~A()<br>    &#123;<br>        <span class="hljs-comment">//析构函数</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>类的继承：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>: <span class="hljs-title">A</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">B</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> b</span>):<span class="hljs-title">base</span>(<span class="hljs-params">b</span>)   <span class="hljs-comment">//初始化基类</span></span><br>    &#123;<br>        <span class="hljs-keyword">base</span>.a = b;           <span class="hljs-comment">//设置基类的成员</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接口：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">interface</span> <span class="hljs-title">IMyInterface</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">method</span>()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>接口支持多重继承，类不支持</p><h2 id="文件处理"><a href="#文件处理" class="headerlink" title="文件处理"></a>文件处理</h2><h3 id="FileStream类"><a href="#FileStream类" class="headerlink" title="FileStream类"></a>FileStream类</h3><p>用于文件的读写和关闭</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#">FileStream fs = <span class="hljs-keyword">new</span> FileStream(filename, FileMode.Open | Append | Create, FileAccess.Read | Write);<br>fs.WriteByte();                                    <span class="hljs-comment">//写入一个字节</span><br>fs.Write(array, offset, count);                    <span class="hljs-comment">//array-&gt;file</span><br>fs.Read(array, offset, count);                     <span class="hljs-comment">//file-&gt;array</span><br>fs.ReadByte();                                     <span class="hljs-comment">//读一个字节</span><br>fs.Seek(offset, System.IO.SeekOrigin.Current);     <span class="hljs-comment">//移动文件指针</span><br>fs.Dispose();                                      <span class="hljs-comment">//释放资源</span><br></code></pre></td></tr></table></figure><h3 id="StreamReader类"><a href="#StreamReader类" class="headerlink" title="StreamReader类"></a>StreamReader类</h3><p>文本文件读取</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#">StreamReader reader = <span class="hljs-keyword">new</span> StreamReader(filename);<br>reader.Read();<br>reader.ReadLine();<br></code></pre></td></tr></table></figure><h3 id="StreamWriter类"><a href="#StreamWriter类" class="headerlink" title="StreamWriter类"></a>StreamWriter类</h3><p>文本文件写入</p><p>用法类似reader</p><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p><strong>命名空间</strong>的设计目的是提供一种让一组名称与其他名称分隔开的方式。在一个命名空间中声明的类的名称与另一个命名空间中声明的相同的类的名称不冲突。</p><p>常用命名空间：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.IO;                  <span class="hljs-comment">//文件读写</span><br><span class="hljs-keyword">using</span> System.Collections;         <span class="hljs-comment">//集合</span><br><span class="hljs-keyword">using</span> System.Collections.Generic; <span class="hljs-comment">//泛型数据结构</span><br></code></pre></td></tr></table></figure><h2 id="特性和反射"><a href="#特性和反射" class="headerlink" title="特性和反射"></a>特性和反射</h2><p><strong>特性（Attribute）</strong>是用于在运行时传递程序中各种元素（比如类、方法、结构、枚举、组件等）的行为信息的声明性标签。您可以通过使用特性向程序添加声明性信息。一个声明性标签是通过放置在它所应用的元素前面的方括号（[ ]）来描述的。</p><p>特性（Attribute）用于添加元数据，如编译器指令和注释、描述、方法、类等其他信息。.Net 框架提供了两种类型的特性：<em>预定义</em>特性和<em>自定义</em>特性。</p><p>常用特性：</p><p><strong>Conditional</strong></p><p>这个预定义特性<strong>标记了一个条件方法</strong>，其执行依赖于指定的预处理标识符。</p><p>它会引起方法调用的条件编译，取决于指定的值，比如 <strong>Debug</strong> 或 <strong>Trace</strong>。例如，当调试代码时显示变量的值。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEBUG</span><br><span class="hljs-keyword">using</span> System;<br>...<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span>&#123;<br>    [<span class="hljs-meta">Conditional(<span class="hljs-string">&quot;DEBUG&quot;</span>)</span>]<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> msg</span>)</span>&#123;<br>        ...<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span>&#123;<br>        Myclass.Message(<span class="hljs-string">&quot;DEBUG&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//当定义了debug时，输出DEBUG，否则不输出</span><br></code></pre></td></tr></table></figure><p><strong>Obsolete</strong></p><p>这个预定义特性标记了不应被使用的程序实体。它可以让您通知编译器丢弃某个特定的目标元素。例如，当一个新方法被用在一个类中，但是您仍然想要保持类中的旧方法，您可以通过显示一个应该使用新方法，而不是旧方法的消息，来把它标记为 obsolete（过时的）。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#">[<span class="hljs-meta">Obsolete(</span><br><span class="hljs-meta">   message,</span><br><span class="hljs-meta">   iserror</span><br><span class="hljs-meta">)</span>]<br></code></pre></td></tr></table></figure><p>其中：</p><ul><li>参数 <em>message</em>，是一个字符串，描述项目为什么过时以及该替代使用什么。</li><li>参数 <em>iserror</em>，是一个布尔值。如果该值为 true，编译器应把该项目的使用当作一个错误。默认值是 false（编译器生成一个警告）。</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>   [<span class="hljs-meta">Obsolete(<span class="hljs-string">&quot;Don&#x27;t use OldMethod, use NewMethod instead&quot;</span>, true)</span>]<br>   <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OldMethod</span>()</span><br>   &#123;<br>      Console.WriteLine(<span class="hljs-string">&quot;It is the old method&quot;</span>);<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">NewMethod</span>()</span><br>   &#123;<br>      Console.WriteLine(<span class="hljs-string">&quot;It is the new method&quot;</span>);<br>   &#125;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>   &#123;<br>      OldMethod();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><span style="color:blue;font-weight:bold">自定义特性和反射</span></p><p>反射指程序可以访问、检测和修改它本身状态或行为的一种能力。</p><p>程序集包含模块，而模块包含类型，类型又包含成员。反射则提供了封装程序集、模块和类型的对象。</p><p>您可以使用反射动态地创建类型的实例，将类型绑定到现有对象，或从现有对象中获取类型。然后，可以调用类型的方法或访问其字段和属性。</p><p><strong>优缺点</strong></p><p>优点：</p><ul><li>反射提高了程序的灵活性和扩展性。</li><li>降低耦合性，提高自适应能力。</li><li>它允许程序创建和控制任何类的对象，<strong>无需提前硬编码目标类</strong>。</li></ul><p>缺点：</p><ul><li><strong>性能问题</strong>：使用反射基本上是一种解释操作，用于字段和方法接入时要远慢于直接代码。因此反射机制主要应用在对灵活性和拓展性要求很高的系统框架上，普通程序不建议使用。</li><li>使用反射会模糊程序内部逻辑；程序员希望在源代码中看到程序的逻辑，反射却绕过了源代码的技术，因而会带来维护的问题，反射代码比相应的直接代码更复杂。</li></ul><p><strong>用途</strong></p><p>反射（Reflection）有下列用途：</p><ul><li>它允许在运行时<strong>查看特性（attribute）信息</strong>。</li><li>它允许审查集合中的各种类型，以及实例化这些类型。</li><li>它<strong>允许延迟绑定的方法和属性</strong>（property）。</li><li>它允许在运行时创建新类型，然后使用这些类型执行一些任务。</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Reflection;<span class="hljs-comment">//System.Reflection 类的 MemberInfo用于发现与类相关的特性（attribute）。</span><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">BugFixApplication</span><br>&#123;<br>    <span class="hljs-comment">// 一个自定义特性 BugFix 被赋给类及其成员</span><br>    [<span class="hljs-meta">AttributeUsage</span><br><span class="hljs-meta">    #region//定义了特性能被放在那些前面        </span><br><span class="hljs-meta">        (AttributeTargets.Class |//规定了特性能被放在class的前面</span><br><span class="hljs-meta">        AttributeTargets.Constructor |//规定了特性能被放在构造函数的前面</span><br><span class="hljs-meta">        AttributeTargets.Field |//规定了特性能被放在域的前面</span><br><span class="hljs-meta">        AttributeTargets.Method |//规定了特性能被放在方法的前面</span><br><span class="hljs-meta">        AttributeTargets.Property,//规定了特性能被放在属性的前面</span><br><span class="hljs-meta">    #endregion</span><br><span class="hljs-meta">        AllowMultiple = true)</span>]<span class="hljs-comment">//这个属性标记了我们的定制特性能否被重复放置在同一个程序实体前多次。</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DeBugInfo</span> : <span class="hljs-title">System.Attribute</span><span class="hljs-comment">//继承了预定义特性后的自定义特性</span><br>    &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> bugNo;<br>        <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> developer;<br>        <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> lastReview;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> message;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DeBugInfo</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> bg,<span class="hljs-built_in">string</span> dev,<span class="hljs-built_in">string</span> d</span>)<span class="hljs-comment">//构造函数，接收三个参数并赋给对应实例</span></span><br>        &#123;<br>            <span class="hljs-keyword">this</span>.bugNo = bg;<br>            <span class="hljs-keyword">this</span>.developer = dev;<br>            <span class="hljs-keyword">this</span>.lastReview = d;<br>        &#125;<br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span>//定义对应的调用，返回对应值value</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> BugNo<br>        &#123;<br>            <span class="hljs-keyword">get</span> <br>            &#123;<br>                <span class="hljs-keyword">return</span> bugNo;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Developer<br>        &#123;<br>            <span class="hljs-keyword">get</span><br>            &#123;<br>                <span class="hljs-keyword">return</span> developer;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> LastReview<br>        &#123;<br>            <span class="hljs-keyword">get</span><br>            &#123;<br>                <span class="hljs-keyword">return</span> lastReview;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//前面有public string message;</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Message<span class="hljs-comment">//定义了可以通过Message = &quot;&quot;,来对message进行赋值。</span><br>                             <span class="hljs-comment">//因为不在构造函数中，所以是可选的</span><br>        &#123;<br>            <span class="hljs-keyword">get</span><br>            &#123;<span class="hljs-keyword">return</span> message;&#125;<br>            <span class="hljs-keyword">set</span><br>            &#123;message = <span class="hljs-keyword">value</span>;&#125;<br>        &#125;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 这部分可以简写如下</span><br><span class="hljs-comment">         * public string Message&#123;get;set;&#125;</span><br><span class="hljs-comment">        */</span><br>    &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>    [<span class="hljs-meta">DeBugInfo(45, <span class="hljs-string">&quot;Zara Ali&quot;</span>, <span class="hljs-string">&quot;12/8/2012&quot;</span>,</span><br><span class="hljs-meta">         Message = <span class="hljs-string">&quot;Return type mismatch&quot;</span>)</span>]<br>    [<span class="hljs-meta">DeBugInfo(49, <span class="hljs-string">&quot;Nuha Ali&quot;</span>, <span class="hljs-string">&quot;10/10/2012&quot;</span>,</span><br><span class="hljs-meta">         Message = <span class="hljs-string">&quot;Unused variable&quot;</span>)</span>]<span class="hljs-comment">//前面定义时的AllowMultiple=ture允许了多次使用在同一地方</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span><br>    &#123;<br>        <span class="hljs-keyword">protected</span> <span class="hljs-built_in">double</span> length;<br>        <span class="hljs-keyword">protected</span> <span class="hljs-built_in">double</span> width;<span class="hljs-comment">//定义两个受保护的（封装）的成员变量</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Rectangle</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> l,<span class="hljs-built_in">double</span> w</span>)<span class="hljs-comment">//构造函数，对两个成员变量进行初始化，公开的</span></span><br>        &#123;<br>            length = l;<br>            width = w;<br>        &#125;<br><br>        [<span class="hljs-meta">DeBugInfo(55, <span class="hljs-string">&quot;Zara Ali&quot;</span>, <span class="hljs-string">&quot;19/10/2012&quot;</span>,</span><br><span class="hljs-meta">             Message = <span class="hljs-string">&quot;Return type mismatch&quot;</span>)</span>]<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> <span class="hljs-title">GetArea</span>()</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> length * width;<br>        &#125;<br><br>        [<span class="hljs-meta">DeBugInfo(56, <span class="hljs-string">&quot;Zara Ali&quot;</span>, <span class="hljs-string">&quot;19/10/2012&quot;</span>)</span>]<span class="hljs-comment">//因为message是可选项，所以可以不给出</span><br>                                                 <span class="hljs-comment">//不给出即为null，为空白</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Display</span>()</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;Length: &#123;0&#125;&quot;</span>, length);<br>            Console.WriteLine(<span class="hljs-string">&quot;Width:&#123;0&#125;&quot;</span>, width);<br>            Console.WriteLine(<span class="hljs-string">&quot;Area:&#123;0&#125;&quot;</span>, GetArea());<span class="hljs-comment">//常规打印</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title">ExecuteRectangle</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)<span class="hljs-comment">//程序入口</span></span><br>        &#123;<br>            Rectangle r = <span class="hljs-keyword">new</span> Rectangle(<span class="hljs-number">4.5</span>, <span class="hljs-number">7.5</span>);<span class="hljs-comment">//实例化</span><br>            r.Display();<span class="hljs-comment">//执行打印长、宽、面积</span><br><br>            Type type = <span class="hljs-keyword">typeof</span>(Rectangle);<span class="hljs-comment">//让type对应这个Rectangle类</span><br>            <span class="hljs-comment">// 遍历 Rectangle 类的特性</span><br>            <span class="hljs-keyword">foreach</span> (Object attributes <span class="hljs-keyword">in</span> type.GetCustomAttributes(<span class="hljs-literal">false</span>))<span class="hljs-comment">//遍历Rectangle的所有特性</span><br>            &#123;<br>                DeBugInfo dbi = (DeBugInfo)attributes;<span class="hljs-comment">//强制转换</span><br>                <span class="hljs-keyword">if</span>(<span class="hljs-literal">null</span> != dbi)<span class="hljs-comment">//dbi非空</span><br>                &#123;<br>                    Console.WriteLine(<span class="hljs-string">&quot;Bug on: &#123;0&#125;&quot;</span>, dbi.BugNo);<br>                    Console.WriteLine(<span class="hljs-string">&quot;Developer: &#123;0&#125;&quot;</span>, dbi.Developer);<br>                    Console.WriteLine(<span class="hljs-string">&quot;Last REviewed: &#123;0&#125;&quot;</span>, dbi.LastReview);<br>                    Console.WriteLine(<span class="hljs-string">&quot;Remarks: &#123;0&#125;&quot;</span>, dbi.Message);<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 遍历方法特性</span><br>            <span class="hljs-keyword">foreach</span> (MethodInfo m <span class="hljs-keyword">in</span> type.GetMethods())<span class="hljs-comment">//遍历Rectangle类下的所有方法</span><br>            &#123;<br>                <span class="hljs-keyword">foreach</span> (Attribute a <span class="hljs-keyword">in</span> m.GetCustomAttributes(<span class="hljs-literal">true</span>))<span class="hljs-comment">//遍历每个方法的特性，参数为true时表示继承子类的特性</span><br>                &#123;<br>                    DeBugInfo dbi = a <span class="hljs-keyword">as</span> DeBugInfo;<span class="hljs-comment">//通过 object 声明对象，是用了装箱和取消装箱的概念.</span><br>                                                   <span class="hljs-comment">//也就是说 object 可以看成是所有类型的父类。</span><br>                                                   <span class="hljs-comment">//因此 object 声明的对象可以转换成任意类型的值。</span><br>                                                   <span class="hljs-comment">//通过拆装箱代替强制转换</span><br>                    <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> !=dbi)<span class="hljs-comment">//同理打印</span><br>                    &#123;<br>                        Console.WriteLine(<span class="hljs-string">&quot;BugFixApplication no: &#123;0&#125;,for Method: &#123;1&#125;&quot;</span>, dbi.BugNo, m.Name);<br>                        Console.WriteLine(<span class="hljs-string">&quot;Developer:&#123;0&#125;&quot;</span>, dbi.Developer);<br>                        Console.WriteLine(<span class="hljs-string">&quot;Last Reviewed: &#123;0&#125;&quot;</span>, dbi.LastReview);<br>                        Console.WriteLine(<span class="hljs-string">&quot;Remarks: &#123;0&#125;&quot;</span>, dbi.Message);<br>                    &#125;<br>                &#125;<br>            &#125;<br>            Console.ReadKey();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>属性（Property）是域（Field）的扩展，且可使用相同的语法来访问。它们使用 <strong>访问器（accessors）</strong> 让私有域的值可被读写或操作。</p><p>实例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> a&#123;<span class="hljs-keyword">get</span>;&#125;              <span class="hljs-comment">//外界內界都是只读</span><br><span class="hljs-built_in">int</span> a&#123;<span class="hljs-keyword">get</span>;<span class="hljs-keyword">set</span>;&#125;                 <span class="hljs-comment">//內界可读可写</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> a&#123;<span class="hljs-keyword">get</span>;<span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>;&#125;  <span class="hljs-comment">//外界可读，內界可写</span><br><br><span class="hljs-comment">//属性可以被继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>    &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-built_in">int</span> Age &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> : <span class="hljs-title">Person</span><br>    &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Code &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125; = <span class="hljs-string">&quot;N.A&quot;</span>;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125; = <span class="hljs-string">&quot;N.A&quot;</span>;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">int</span> Age &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125; = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="委托和事件"><a href="#委托和事件" class="headerlink" title="委托和事件"></a>委托和事件</h2><h3 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h3><p>C# 中的委托（Delegate）类似于 C 或 C++ 中函数的指针。<strong>委托（Delegate）</strong> 是存有对某个方法的引用的一种引用类型变量。引用可在运行时被改变。</p><p>声明和实例化委托：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-built_in">int</span> <span class="hljs-title">MyDelegate</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> s</span>)</span>;<br>MyDelegate del1 = <span class="hljs-keyword">new</span> MyDelegate(str);<br></code></pre></td></tr></table></figure><p><span style="color:blue;font-weight:bold">委托的多播</span></p><p>委托对象可<strong>使用 “+” 运算符进行合并</strong>。一个合并委托调用它所合并的两个委托。<strong>只有相同类型的委托可被合并</strong>。**”-“ 运算符可用于从合并的委托中移除组件委托**。使用委托的这个有用的特点，您可以创建一个委托被调用时要调用的方法的调用列表。这被称为委托的 <strong>多播（multicasting）</strong>，也叫组播。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-function"><span class="hljs-built_in">delegate</span> <span class="hljs-built_in">int</span> <span class="hljs-title">NumberChanger</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> n</span>)</span>;<br><span class="hljs-keyword">namespace</span> <span class="hljs-title">DelegateAppl</span><br>&#123;<br>   <span class="hljs-keyword">class</span> <span class="hljs-title">TestDelegate</span><br>   &#123;<br>      <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> num = <span class="hljs-number">10</span>;<br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">AddNum</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> p</span>)</span><br>      &#123;<br>         num += p;<br>         <span class="hljs-keyword">return</span> num;<br>      &#125;<br><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">MultNum</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> q</span>)</span><br>      &#123;<br>         num *= q;<br>         <span class="hljs-keyword">return</span> num;<br>      &#125;<br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">getNum</span>()</span><br>      &#123;<br>         <span class="hljs-keyword">return</span> num;<br>      &#125;<br><br>      <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>      &#123;<br>         <span class="hljs-comment">// 创建委托实例</span><br>         NumberChanger nc;<br>         NumberChanger nc1 = <span class="hljs-keyword">new</span> NumberChanger(AddNum);<br>         NumberChanger nc2 = <span class="hljs-keyword">new</span> NumberChanger(MultNum);<br>         nc = nc1;<br>         nc += nc2;<br>         <span class="hljs-comment">// 调用多播</span><br>         nc(<span class="hljs-number">5</span>);<br>         Console.WriteLine(<span class="hljs-string">&quot;Value of Num: &#123;0&#125;&quot;</span>, getNum());<br>         Console.ReadKey();<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>委托可以作为函数的参数被函数内部调用</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.IO;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">DelegateAppl</span><br>&#123;<br>   <span class="hljs-keyword">class</span> <span class="hljs-title">PrintString</span><br>   &#123;<br>      <span class="hljs-keyword">static</span> FileStream fs;<br>      <span class="hljs-keyword">static</span> StreamWriter sw;<br>      <span class="hljs-comment">// 委托声明</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printString</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> s</span>)</span>;<br><br>      <span class="hljs-comment">// 该方法打印到控制台</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteToScreen</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> str</span>)</span><br>      &#123;<br>         Console.WriteLine(<span class="hljs-string">&quot;The String is: &#123;0&#125;&quot;</span>, str);<br>      &#125;<br>      <span class="hljs-comment">// 该方法打印到文件</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WriteToFile</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> s</span>)</span><br>      &#123;<br>         fs = <span class="hljs-keyword">new</span> FileStream(<span class="hljs-string">&quot;c:\\message.txt&quot;</span>, FileMode.Append, FileAccess.Write);<br>         sw = <span class="hljs-keyword">new</span> StreamWriter(fs);<br>         sw.WriteLine(s);<br>         sw.Flush();<br>         sw.Close();<br>         fs.Close();<br>      &#125;<br>      <span class="hljs-comment">// 该方法把委托作为参数，并使用它调用方法</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendString</span>(<span class="hljs-params">printString ps</span>)</span><br>      &#123;<br>         ps(<span class="hljs-string">&quot;Hello World&quot;</span>);<br>      &#125;<br>      <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>      &#123;<br>         printString ps1 = <span class="hljs-keyword">new</span> printString(WriteToScreen);<br>         printString ps2 = <span class="hljs-keyword">new</span> printString(WriteToFile);<br>         sendString(ps1);<br>         sendString(ps2);<br>         Console.ReadKey();<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以使用匿名方法创建委托实例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#">NumberChanger nc = <span class="hljs-built_in">delegate</span>(<span class="hljs-built_in">int</span> x)<br>&#123;<br>   Console.WriteLine(<span class="hljs-string">&quot;Anonymous Method: &#123;0&#125;&quot;</span>, x);<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p><strong>事件（Event）</strong> 基本上说是一个用户操作，如按键、点击、鼠标移动等等，或者是一些提示信息，如系统生成的通知。应用程序需要在事件发生时响应事件。例如，中断。C# 中使用事件机制实现线程间的通信。</p><p><span style="color:blue;font-weight:bold">通过事件使用委托</span></p><p>事件在类中声明且生成，且通过使用同一个类或其他类中的委托与事件处理程序关联。包含事件的类用于发布事件。这被称为 <strong>发布器（publisher）</strong> 类。其他接受该事件的类被称为 <strong>订阅器（subscriber）</strong> 类。事件使用 <strong>发布-订阅（publisher-subscriber）</strong> 模型。</p><p><strong>发布器（publisher）</strong> 是一个包含事件和委托定义的对象。事件和委托之间的联系也定义在这个对象中。发布器（publisher）类的对象调用这个事件，并通知其他的对象。</p><p><strong>订阅器（subscriber）</strong> 是一个接受事件并提供事件处理程序的对象。在发布器（publisher）类中的委托调用订阅器（subscriber）类中的方法（事件处理程序）。</p><p><span style="color:blue;font-weight:bold">声明事件</span></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BoilerLogHandler</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> status</span>)</span>;  <span class="hljs-comment">//先声明委托</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> BoilerLogHandler BoilerEventLog;          <span class="hljs-comment">//基于委托定义事件</span><br></code></pre></td></tr></table></figure><p>实例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">namespace</span> <span class="hljs-title">SimpleEvent</span><br>&#123;<br>  <span class="hljs-keyword">using</span> System;<br>  <span class="hljs-comment">/***********发布器类***********/</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">EventTest</span><br>  &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">NumManipulationHandler</span>()</span>;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> NumManipulationHandler ChangeNum;<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnNumChanged</span>()</span><br>    &#123;<br>      <span class="hljs-keyword">if</span> ( ChangeNum != <span class="hljs-literal">null</span> )<br>      &#123;<br>        ChangeNum(); <span class="hljs-comment">/* 事件被触发 */</span><br>      &#125;<span class="hljs-keyword">else</span> &#123;<br>        Console.WriteLine( <span class="hljs-string">&quot;event not fire&quot;</span> );<br>        Console.ReadKey(); <span class="hljs-comment">/* 回车继续 */</span><br>      &#125;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">EventTest</span>()</span><br>    &#123;<br>      <span class="hljs-built_in">int</span> n = <span class="hljs-number">5</span>;<br>      SetValue( n );<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetValue</span>(<span class="hljs-params"> <span class="hljs-built_in">int</span> n </span>)</span><br>    &#123;<br>      <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">value</span> != n )<br>      &#123;<br>        <span class="hljs-keyword">value</span> = n;<br>        OnNumChanged();<br>      &#125;<br>    &#125;<br>  &#125;<br><br><br>  <span class="hljs-comment">/***********订阅器类***********/</span><br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">subscribEvent</span><br>  &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printf</span>()</span><br>    &#123;<br>      Console.WriteLine( <span class="hljs-string">&quot;event fire&quot;</span> );<br>      Console.ReadKey(); <span class="hljs-comment">/* 回车继续 */</span><br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">/***********触发***********/</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MainClass</span><br>  &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>      EventTest e = <span class="hljs-keyword">new</span> EventTest(); <span class="hljs-comment">/* 实例化对象,第一次没有触发事件 */</span><br>      subscribEvent v = <span class="hljs-keyword">new</span> subscribEvent(); <span class="hljs-comment">/* 实例化对象 */</span><br>      e.ChangeNum += <span class="hljs-keyword">new</span> EventTest.NumManipulationHandler( v.printf ); <span class="hljs-comment">/* 注册 */</span><br>      e.SetValue( <span class="hljs-number">7</span> );<br>      e.SetValue( <span class="hljs-number">11</span> );<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合（Collection）类是专门用于数据存储和检索的类。这些类提供了对栈（stack）、队列（queue）、列表（list）和哈希表（hash table）的支持。大多数集合类实现了相同的接口。</p><p>集合（Collection）类服务于不同的目的，如为元素动态分配内存，基于索引访问列表项等等。这些类创建 Object 类的对象的集合。在 C# 中，Object 类是所有数据类型的基类。</p><p>常用集合：</p><ul><li>ArrayList：可被单独索引的有序集合</li><li>Hashtable：可以使用键来访问集合中的元素</li><li>SortedList：可以使用键和索引来访问列表中的项</li><li>Stack：堆栈</li><li>Queue: 队列</li><li>BitArray: 点阵列，使用值1和0来表示二进制数组，当您需要存储位，但是事先不知道位数时，则使用点阵列。您可以使用<strong>整型索引</strong>从点阵列集合中访问各项，索引从零开始</li></ul><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p><strong>泛型（Generic）</strong> 允许您延迟编写类或方法中的编程元素的数据类型的规范，直到实际在程序中使用它的时候。换句话说，泛型允许您编写一个可以与任何数据类型一起工作的类或方法。</p><p>您可以通过数据类型的替代参数编写类或方法的规范。当编译器遇到类的构造函数或方法的函数调用时，它会生成代码来处理指定的数据类型。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyGenericArray</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>    <span class="hljs-keyword">private</span> T[] array;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyGenericArray</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> size</span>)</span><br>    &#123;<br>        array = <span class="hljs-keyword">new</span> T[size + <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getItem</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> index</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> array[index];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setItem</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> index, T <span class="hljs-keyword">value</span></span>)</span><br>    &#123;<br>        array[index] = <span class="hljs-keyword">value</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><span style="color:blue;font-weight:bold">泛型特性</span></p><ul><li>它有助于您最大限度地重用代码、保护类型的安全以及提高性能。</li><li>您可以创建泛型集合类。.NET 框架类库在 <em>System.Collections.Generic</em> 命名空间中包含了一些新的泛型集合类。您可以使用这些泛型集合类来替代 <em>System.Collections</em> 中的集合类。</li><li>您可以创建自己的<strong>泛型接口、泛型类、泛型方法、泛型事件和泛型委托</strong>。</li><li>您可以对泛型类进行约束以访问特定数据类型的方法。</li><li><strong>关于泛型数据类型中使用的类型的信息可在运行时通过使用反射获取</strong>。</li></ul><p><span style="color:blue;font-weight:bold">常用泛型</span></p><ul><li>Dictionary: 键和值的集合</li><li><strong>HashSet</strong>： 值的集合</li><li>LinkedList： 双重链接列表</li><li><strong>List</strong>：可通过索引访问的对象的强类型列表</li><li>Queue：队列</li><li>SortedDictionary：根据键进行排序的键&#x2F;值对的集合</li><li>SortedList：同上</li><li>SortedSet：表示按排序顺序维护的对象的集合</li><li>Stack：栈</li></ul>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>接水问题-短板效应</title>
    <link href="/2023/01/10/%E6%8E%A5%E6%B0%B4%E9%97%AE%E9%A2%98-%E7%9F%AD%E6%9D%BF%E6%95%88%E5%BA%94/"/>
    <url>/2023/01/10/%E6%8E%A5%E6%B0%B4%E9%97%AE%E9%A2%98-%E7%9F%AD%E6%9D%BF%E6%95%88%E5%BA%94/</url>
    
    <content type="html"><![CDATA[<h1 id="接水问题-短板效应"><a href="#接水问题-短板效应" class="headerlink" title="接水问题-短板效应"></a>接水问题-短板效应</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在一个二维坐标系中竖立了很多根柱子（从0~n），这些柱子各有一个高度，每两个柱子能形成一个容器，底是距离，高是短的那根柱子，求最大接水量。</p><p><img src="/2023/01/10/%E6%8E%A5%E6%B0%B4%E9%97%AE%E9%A2%98-%E7%9F%AD%E6%9D%BF%E6%95%88%E5%BA%94/image-20201120205412425.png" alt="image-20201120205412425"></p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>双指针法：头尾指针各一，每次移动矮的那个，直到两者重合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">maxValue</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> height.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i &lt; j)&#123;<br>        ans = Integer.max(ans, (j - i) * Integer.min(height[i], height[j]));<br>        <span class="hljs-keyword">if</span>(height[i] &gt; height[j])&#123;<br>            --j;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            i++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>原因：如果动高的那根柱子，那么由于容器变短了，而高度变矮或者不变，接的水一定变少了，所以每次移动矮的那根柱子才有效。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>和等于K的子数组</title>
    <link href="/2023/01/10/%E5%92%8C%E7%AD%89%E4%BA%8EK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <url>/2023/01/10/%E5%92%8C%E7%AD%89%E4%BA%8EK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="和等于K的子数组"><a href="#和等于K的子数组" class="headerlink" title="和等于K的子数组"></a>和等于K的子数组</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定一个整数数组，返回子数组的个数，这些子数组的和为K。</p><p><img src="/2023/01/10/%E5%92%8C%E7%AD%89%E4%BA%8EK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/image-20201125174349534.png" alt="image-20201125174349534"></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>法一：可以使用DP来解决，因为dp[i][j] &#x3D; dp[0][j] - dp[0][i]，其中dp表示下标i+1到下标i之间的和。这种算法的时间复杂度为$O(n^2)$。</p><p>法二：采用字典（Map）才存储每个值出现的次数</p><p>这种方法只需要经历一次遍历，问题的核心是求sum[i][j] &#x3D;&#x3D; k，而根据公式sum[i][j] &#x3D; sum[0][i] + sum[0][j]可知，如果把 j 作为遍历的指针，而把sum[0][i]存储在字典中，那么当sum[0][j] - k &#x3D; sum[0][i]时，我们就找到了结果，并且结果的个数取决于字典中键等于sum[0][i]的个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">subarraySum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, sum = <span class="hljs-number">0</span>;<br>        HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>            sum += nums[i];<br>            <span class="hljs-keyword">if</span>(map.containsKey(sum - k))&#123;<br>                count += map.get(sum - k);<br>            &#125;<br>            map.put(sum, map.getOrDefault(sum, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字典</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机系统基础</title>
    <link href="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机系统基础"><a href="#计算机系统基础" class="headerlink" title="计算机系统基础"></a>计算机系统基础</h1><h2 id="第一章-计算机系统概述"><a href="#第一章-计算机系统概述" class="headerlink" title="第一章 计算机系统概述"></a>第一章 计算机系统概述</h2><h3 id="1-计算机基本执行过程"><a href="#1-计算机基本执行过程" class="headerlink" title="1. 计算机基本执行过程"></a>1. 计算机基本执行过程</h3><h4 id="1-1-冯·诺依曼机基本结构"><a href="#1-1-冯·诺依曼机基本结构" class="headerlink" title="1.1 冯·诺依曼机基本结构"></a>1.1 冯·诺依曼机基本结构</h4><p>绝大部分通用计算机的硬件基本组成仍然就有冯·诺依曼结构特征</p><p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20200915183606178.png" alt="image-20200915183606178"></p><p>图解：</p><ul><li>主存储器（主存，内存）：存放指令和数据</li><li>算术逻辑部件（ALU）：进行算术逻辑运算的核心部件，可以对输入端A和B进行不同的运算，得到结果F</li><li>控制部件（CU，控制器）：自动逐条取出指令并进行译码（将二进制的操作码翻译成对应的操作）</li><li>通用寄存器（GPRs）：临时存放从主存取来的数据或者运算结果</li><li>标志寄存器（SF）：存储ALU运算产生的标志信息</li><li>指令寄存器（IR）：临时保存从主存取出的指令</li><li>程序计数器（PC）：自动按序读取主存中的指令，并且在执行指令的过程当中计算出下一条指令的地址并保存</li><li>中央处理器（CPU）：通常把控制部件、运算部件和各类寄存器互连组成的电路</li><li>主存单元地址：主存中每个单元的编号（地址）</li><li>总线：连接不同部件进行信息传输的介质</li><li>主存地址寄存器（MAR）：CPU送到地址线的主存地址先存放在这里 （MAR只会从CPU内部取地址，而不会从内存中取）</li><li>主存数据寄存器（MDR）：发送到或者从数据线取来的信息放在这里（包括指令和数据，双向过程，分别对应load 和 store）</li></ul><h4 id="1-2-程序和指令的执行过程"><a href="#1-2-程序和指令的执行过程" class="headerlink" title="1.2 程序和指令的执行过程"></a>1.2 程序和指令的执行过程</h4><p>指令的概念：用0&#x2F;1表示的序列，指示CPU完成一个特定操作。</p><p>常见指令：</p><ul><li>load</li><li>store</li><li>add</li><li>mov</li></ul><p>指令通常被分为若干字段，一般为<strong>操作码字段</strong>和<strong>地址码字段</strong></p><p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20200915182038345.png" alt="image-20200915182038345"></p><p>在模型机上执行 $z &#x3D; x + y$ 过程:</p><p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20200915182818825.png" alt="image-20200915182818825"></p><p><strong>程序执行过程：</strong></p><ol><li><p>根据PC取指令</p></li><li><p>指令译码，PC&lt;-PC + 1 </p></li><li><p>取操作数并执行</p></li><li><p>送结果</p></li><li><p>循环1-4</p></li></ol><p>图示：</p><p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20200915183903180.png" alt="image-20200915183903180"></p><p>指令各执行阶段还包含<strong>微操作</strong>，需要相应的<strong>控制信号</strong>：</p><p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20200915184007449.png" alt="image-20200915184007449"></p><p><strong>时钟信号</strong>：在每条指令的执行过程中，所包含的微操作具有先后顺序关系，需要定时信号进行定时。</p><p><strong>时钟周期</strong>：时钟信号的一个宽度</p><h3 id="2-程序的开发和运行"><a href="#2-程序的开发和运行" class="headerlink" title="2. 程序的开发和运行"></a>2. 程序的开发和运行</h3><h4 id="2-1-程序设计语言和翻译程序"><a href="#2-1-程序设计语言和翻译程序" class="headerlink" title="2.1 程序设计语言和翻译程序"></a>2.1 程序设计语言和翻译程序</h4><ul><li><p>机器语言，机器指令：0&#x2F;1</p></li><li><p>汇编语言，汇编指令：方便阅读和编写，需要汇编成机器语言</p></li><li><p>高级语言：阅读性和编写性更好，需要翻译</p></li><li><p>翻译程序：</p><ul><li>汇编器（assembler）：汇编语言-》机器语言</li><li>解释器（interpreter）：逐条翻译成机器语言</li><li>编译器（compiler）：源程序-》汇编语言或机器语言目标程序</li></ul><p>  <img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20200915184700179.png" alt="image-20200915184700179"></p></li></ul><h4 id="2-2-从源程序到可执行文件"><a href="#2-2-从源程序到可执行文件" class="headerlink" title="2.2 从源程序到可执行文件"></a>2.2 从源程序到可执行文件</h4><p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20200915184807690.png" alt="image-20200915184807690"></p><ul><li><p>预处理阶段：嵌入include文件，宏展开</p></li><li><p>编译阶段</p></li><li><p>汇编阶段</p></li><li><p>链接阶段：将多个<strong>可重定位目标文件</strong>(.o .obj) 和<strong>标准函数库</strong>中的可重定位目标文件合并成为一个可执行文件.</p><p>  如hello.o + printf.o -&gt; hello.exe</p></li></ul><p>可执行文件的启动和执行：</p><p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20200915185150735.png" alt="image-20200915185150735"></p><p>概括：</p><ol><li>shell程序会将.&#x2F;hello的每一个字符逐一读取到CPU寄存器中，再通过存数操作存储到主存的缓存中</li><li>shell调用操作系统内核中的服务例程，加载磁盘中的hello.exe到存储器</li><li>逐一执行程序指令</li><li>将结果打印到显示器上</li></ol><h3 id="3-计算机系统的层次结构"><a href="#3-计算机系统的层次结构" class="headerlink" title="3. 计算机系统的层次结构"></a>3. 计算机系统的层次结构</h3><h4 id="3-1-计算机系统抽象层次的转换"><a href="#3-1-计算机系统抽象层次的转换" class="headerlink" title="3.1 计算机系统抽象层次的转换"></a>3.1 计算机系统抽象层次的转换</h4><p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20200915190310257.png" alt="image-20200915190310257"></p><p>上层结构是下层结构的抽象，下层是上层的环境。</p><p><strong>指令体系结构（ISA）：</strong></p><ul><li>定义了一台计算机可以执行的<strong>所有指令</strong>的集合</li><li>每条指令规定了计算机<strong>执行什么操作</strong>（如不同ISA规定的乘法指令所消耗的时钟周期数不同）</li><li>所处理的操作数<strong>存放的地址空间</strong>和<strong>操作数类型</strong></li></ul><p>更详细的规定如下：</p><ul><li><p>可执行的指令的集合，包括<strong>指令格式</strong>、<strong>操作种类</strong>以及每种操作对应的操作数的相应规定；</p></li><li><p>指令可以接受的<strong>操作数的类型</strong>；</p></li><li><p>操作数所能存放的寄存器组的结构，包括每个<strong>寄存器的名称、编号、长度和用途</strong>；</p></li><li><p>操作数所能存放的<strong>存储空间的大小和编址方式</strong>；</p></li><li><p>操作数在存储空间存放时按照<strong>大端还是小端方式存放</strong>；</p></li><li><p>指令获取操作数的方式，即<strong>寻址方式</strong>；</p></li><li><p>指令执行过程的控制方式，包括<strong>程序计数器</strong>、<strong>条件码定义</strong>等。</p></li></ul><h4 id="3-2-计算机系统的不同用户"><a href="#3-2-计算机系统的不同用户" class="headerlink" title="3.2 计算机系统的不同用户"></a>3.2 计算机系统的不同用户</h4><p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20200915192155617.png" alt="image-20200915192155617"></p><h3 id="4-计算机系统性能评价（重点）"><a href="#4-计算机系统性能评价（重点）" class="headerlink" title="4. 计算机系统性能评价（重点）"></a>4. 计算机系统性能评价（重点）</h3><h4 id="4-1-计算机性能的定义"><a href="#4-1-计算机性能的定义" class="headerlink" title="4.1 计算机性能的定义"></a>4.1 计算机性能的定义</h4><ul><li>吞吐率：单位时间完成工作量，相当于带宽</li><li>响应时间：从作业提交到作业完成所用的时间，类似执行时间，包含CPU时间和其他时间（如IO操作，磁盘读取）</li><li>CPU时间：CPU用于本程序执行的时间</li><li>系统性能：包括CPU性能和其他性能</li><li>CPU性能：只包含CPU执行时间</li><li>时钟周期：时钟信号的宽度(clock cycle)，一条指令可能需要多个时钟周期来完成</li><li>时钟频率：CPU的主频（clock rate），时钟周期的倒数</li><li><strong>CPI</strong>（Cycles Per Instruction）执行一条指令所需的周期数</li></ul><p>$$<br>程序总时钟周期数&#x3D;\sum\limits_{j&#x3D;1}^{n}(CPI_{i}\times C_{i})<br>$$</p><p>CPI可用$F_{i}$（第i种指令在程序中所占比例）表示：<br>$$<br>CPI &#x3D; \sum\limits_{j&#x3D;1}^{n}(CPI_{i}\times F_{i}) &#x3D; 程序总时钟周期数\div 程序总指令条数<br>$$<br>但是CPI并不是衡量CPU性能的唯一标准，因为不同CPU的时钟周期也可能不相同。</p><p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20200915194024533.png" alt="image-20200915194024533"></p><h2 id="第二章-数据的机器级表示和处理"><a href="#第二章-数据的机器级表示和处理" class="headerlink" title="第二章 数据的机器级表示和处理"></a>第二章 数据的机器级表示和处理</h2><h3 id="1-数制和编码"><a href="#1-数制和编码" class="headerlink" title="1. 数制和编码"></a>1. 数制和编码</h3><h4 id="1-1-进制数之间的转换"><a href="#1-1-进制数之间的转换" class="headerlink" title="1.1 进制数之间的转换"></a>1.1 进制数之间的转换</h4><p>常见的二进制长度：</p><ul><li><p>1byte：8位二进制，可表示的无符号数范围:</p><p>  0000 0000 ~ 1111 1111 即 0 ~ $2^{8} - 1$。</p></li><li><p>unsigned int: 4个字节，表示范围：</p><p>  0000 0000H ~ FFFF FFFFH 即 0 ~ 4294967295</p></li></ul><h4 id="1-2-整数的表示"><a href="#1-2-整数的表示" class="headerlink" title="1.2 整数的表示"></a>1.2 整数的表示</h4><p>无符号整数和有符号整数的区别：</p><ul><li>无符号整数，默认使用所有二进制位来存储实际数据。对于32整型，其长度为0~$2^{32}-1$。</li><li>有符号整数，最高位（MSB）或者最低位（LSB）作为符号位，因此表示范围比无符号少，对于32位整型，其长度为$-2^{31}$~$2^{31}-1$。</li></ul><p>不同的编译器对于数据类型的判断是不一样的。</p><p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20200922200609296.png" alt="image-20200922200609296"></p><h4 id="1-3-浮点数的表示"><a href="#1-3-浮点数的表示" class="headerlink" title="1.3 浮点数的表示"></a>1.3 浮点数的表示</h4><p>浮点数的IEEE 754 标准：</p><p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20200922200749034.png" alt="image-20200922200749034"></p><p>对于32位单精度格式：</p><p>尾数为23位，其中有一个隐藏位1在小数点之前。</p><p>eg：一个浮点数的尾数为1011 1100 1110 0000 … , 则其实际的尾数为1.1011 1100 1110 0000…</p><p>阶码为8位，采用移码的形式，其中偏置常数为127，可表示的阶数的范围为（1~254）- 127（0和全1有特殊意义）。</p><p>符号位1位，判断符号。</p><p><strong>浮点数的解释：</strong></p><p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20200922202152498.png" alt="image-20200922202152498"></p><p>记忆：</p><p>在尾数为全0的情况下，阶码的两个极限（0和255）分别表示0和无穷大，正负看符号位</p><p>当尾数不为0时：</p><ul><li>阶数为255，则为无定义数</li><li>阶数为0，则尾数失去隐藏位1，然后向0过渡。</li></ul><p>当浮点数和整数的长度相同时，他们表示的数的个数没有改变（每一个二进制数唯一对应一个真值），但是浮点数的范围扩大了，所以浮点数越大，两个相邻二进制数的真值的差值越大，即尾数后面的数字被计算机忽略掉了。</p><h3 id="2-数据的基本运算"><a href="#2-数据的基本运算" class="headerlink" title="2. 数据的基本运算"></a>2. 数据的基本运算</h3><h4 id="2-1-二进制位的计算"><a href="#2-1-二进制位的计算" class="headerlink" title="2.1 二进制位的计算"></a>2.1 二进制位的计算</h4><p><strong>按位运算和逻辑运算</strong></p><ul><li><p>按位运算 :</p><p>   二进制的每一位数字逐个进行运算。常见的有: I , &amp;, ~, ^(异或)。</p><p>  按位运算常用于进行<strong>掩码</strong>操作，可以提取重要的位，然后对这些位进行置1，清0，或者测试该位是否为1或0.</p></li><li><p>逻辑运算：</p><p>  非数值运算，其操作数只有两种逻辑：True 和 False。常见的有：||, &amp;&amp;, !。</p></li></ul><p><strong>左移运算和右移运算</strong></p><ul><li><p>逻辑移位：</p><p>  移位后缺失的位直接补0。</p></li><li><p>算术移位：</p><p>  右移时，最高位会根据符号位进行补充，以保证带符号数的符号不会变化，其他情况移位后缺失的位直接补0。</p></li></ul><p><strong>位扩展运算和位截断运算</strong></p><p><strong>0扩展和符号扩展</strong>：分别对于有符号数和无符号数而言</p><p><strong>位截断</strong>：直接舍去多出来的位数，截断具有一定的风险，因为可能导致数据精度或者符号发生变化，也可能彻底改变数值。</p><h4 id="2-2-数据的存储"><a href="#2-2-数据的存储" class="headerlink" title="2.2 数据的存储"></a>2.2 数据的存储</h4><p>最低有效位（LSB）：数字的最低位</p><p>最高有效位（MSB）：数字的最高位</p><p>大端方式：数据的最高有效位存储在小地址单元中，IBM采用这种方式</p><p>小端方式：数据的最低有效位存储在小地址单元中，Intel使用，“低对低，高对高”，低字节对应低地址。</p><h4 id="2-3-整数加减运算"><a href="#2-3-整数加减运算" class="headerlink" title="2.3 整数加减运算"></a>2.3 整数加减运算</h4><p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20201003153252707.png" alt="image-20201003153252707"></p><p>无符号整数和带符号整数的加减运算电路是完全一样的，都在整数加减运算器中实现。</p><p>MUX是一个二路选择器，Sub控制信号会告诉MUX此时所做的是减法运算，那么MUX会选择把Y按位取反后进行输出，同时，控制端Sub作为低位进位送到加法器。当Sub为1时做减法，实现x-y &#x3D; X + $\overline{Y}$ + 1, 当Sub为1时做加法，实现x + y &#x3D; X + Y。</p><p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20201003154205880.png" alt="image-20201003154205880"></p><p>加法器本身无法判断数据是否溢出，所以需要通过输出得到的标志寄存器来判断。</p><ul><li><p>OF: </p><p>  用在有符号数的加减法中，为1则表示溢出</p><p>  常见溢出情形：</p><p>  两个正数相加（一个正数减一个负数）变成负数，此时$C_n&#x3D;0,C_{n-1}&#x3D;1$，OF&#x3D;1，发生溢出</p><p>  两个负数相加（一个负数减一个正数）变成正数，此时$C_n&#x3D;1,C_{n-1}&#x3D;0$，OF&#x3D;1，发生溢出</p></li><li><p>SF：</p><p>  直接取最高位的数字，1表示负数</p></li><li><p>ZF：</p><p>0表示该数不为0,1表示该数为0</p></li><li><p>CF：</p><p>  用在无符号的加减法中，做加法时，为1表示需要进位，做减法时，为1表示需要借位</p><p>  判断的标准是输入位（减法为1，加法为0） 异或 输出位（第n + 1位）</p></li></ul><p>无符号数加法公式：</p><p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20201003155925133.png" alt="image-20201003155925133"></p><p>无符号数减法公式：$[-y]_补&#x3D;2^n-y$</p><p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20201003160107226.png" alt="image-20201003160107226"></p><p>带符号数加法公式：</p><p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20201003160356453.png" alt="image-20201003160356453"></p><p>带符号数减法公式：</p><p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20201003160416124.png" alt="image-20201003160416124"></p><p>可以类比于小时的运算规则。</p><p><strong>总结</strong></p><p>在机器级层次上，<strong>并不区分操作数是什么类型</strong>，只是编译器根据高级语言程序中的类型定义对机器数进行不同的解释而已。</p><p>有些语言为了避免无符号和有符号的麻烦就不支持无符号类型，比如Java</p><h4 id="2-4-整数的乘除运算"><a href="#2-4-整数的乘除运算" class="headerlink" title="2.4 整数的乘除运算"></a>2.4 整数的乘除运算</h4><p><strong>整数乘法</strong></p><p>尽管两个n位整数相乘会得到一个2n位 的整数，但是在许多高级语言中高n位的数据会被截断，因此整数的乘法可能产生溢出问题。</p><p><strong>溢出判断</strong></p><ul><li>对于<strong>n位无符号整数</strong>而言，如果高n为全为0，则没有发生溢出；</li><li>对于<strong>n位带符号整数</strong>而言，如果高n位全部等于低n位的最高位，则没有发生溢出；</li></ul><p>另一种人为的判断方式是，假设x * y &#x3D; p, 只要验证p &#x2F; y 是否等于 x 即可确认是否发生了溢出 。</p><p><strong>整数除法</strong></p><p>只有在<strong>最小数除以-1</strong>时才会发生溢出，除法由于需要试商的缘故，所以耗费的时钟周期会很多。</p><h4 id="2-5-常量的乘除运算"><a href="#2-5-常量的乘除运算" class="headerlink" title="2.5 常量的乘除运算"></a>2.5 常量的乘除运算</h4><p><strong>乘法运算</strong></p><p>由于一次乘法运算需要10个左右的时钟周期，因此编译器在处理常量的乘除运算时，会用移位，加法和减法来代替乘法运算，这样可以 大大缩短时钟周期，例如x * 20 &#x3D;&gt; (x &lt;&lt; 4) + (x &lt;&lt; 2)。</p><p><strong>除法运算</strong></p><ul><li>无符号整数：直接逻辑右移，高位补0，商朝0方向舍入。</li><li>有符号整数：如果为正数，则处理方法同无符号整数；如果是负数，如果直接移位的话，商会朝着远离0的方向舍入，此时需要加上偏移量$2^k - 1$（k是移位数），这样，当舍去的二进制位全零时不会受到影响；当舍去的二进制位不为全零时，被除数偏移后一定会发生进位，此时再向右移位得到的结果就是朝0方向舍入的商了。</li></ul><h4 id="2-6-浮点数运算"><a href="#2-6-浮点数运算" class="headerlink" title="2.6 浮点数运算"></a>2.6 浮点数运算</h4><h5 id="2-6-1-加减运算"><a href="#2-6-1-加减运算" class="headerlink" title="2.6.1 加减运算"></a>2.6.1 加减运算</h5><ol><li><p><strong>对阶</strong></p><p> 对阶的目的是使两个数的阶相等，以便位数可以相加相减。</p><p> <strong>对阶的原则</strong>：小阶向大阶看齐，阶小的尾数右移，右移的位数等于两个阶的差的绝对值</p><p> 注意：在采用IEEE754标准时，需要将隐含的1右移到小数部分</p><p> <strong>阶差的计算公式</strong><br> $$<br> [E_x - E_y]_补 &#x3D; [E_x]_移 + [-[E_y]_移]_补<br> $$<br> 例：</p><p> <img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20201013231713394.png" alt="image-20201013231713394"></p></li><li><p><strong>尾数加减和规格化</strong></p><p> 对阶之后需要对尾数进行加减，得到的结果如果不符合标准需要进行左规和右规。</p><p> <strong>左规</strong>：遇到结果为0.0…01bbb的情况，让阶码逐次减1，直到整数部分为1。如果数据本身是0，则不需要处理</p><p> <strong>右规</strong>：尾数右移一位，阶码加一</p></li><li><p><strong>尾数的舍入处理</strong></p><p> 为了保证计算具有更高的精度，IEEE754标准规定所有浮点数运算的中间结果右边都必须至少保留两位<strong>附加位</strong>，即保护位和舍入位。</p><p> 附加位的作用：用以保护对阶时右移的位或运算的中间结果</p><p> 就近舍入的默认方式：如果附加位小于1&#x2F;2，截断；如果大于1&#x2F;2，进位；等于1&#x2F;2，取最近的偶数。</p><p> <img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20201013233853594.png" alt="image-20201013233853594"></p></li><li><p><strong>阶码溢出判断</strong></p><p> <strong>阶码上溢</strong>：阶码为全1，此时产生异常或者把结果置为无穷大。</p><p> <strong>阶码下溢</strong>：阶码全为0，此时结果为非规格化形式，如果也不能表示则近似为0。</p></li></ol><p>可以总结如下：</p><p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20201013234831279.png" alt="image-20201013234831279"></p><p>​    </p><p>​    </p><p>​    </p><h2 id="第三章-程序的转换及机器级表示"><a href="#第三章-程序的转换及机器级表示" class="headerlink" title="第三章 程序的转换及机器级表示"></a>第三章 程序的转换及机器级表示</h2><p>计算机的指令有微指令，机器指令和伪（宏）指令之分。</p><p>微指令：微程序级指令，属于微体系结构，硬件范畴</p><p>宏指令：由若干机器指令组成的序列，软件范畴</p><p>机器指令：位于两者之间，可由汇编语言来表示，属于指令集体系结构（ISA）</p><p>他们分别对应着计算机系统的层次结构中的中间三个结构。</p><h3 id="1-程序转换概述"><a href="#1-程序转换概述" class="headerlink" title="1. 程序转换概述"></a>1. 程序转换概述</h3><h4 id="1-1-机器指令及汇编指令"><a href="#1-1-机器指令及汇编指令" class="headerlink" title="1.1 机器指令及汇编指令"></a>1.1 机器指令及汇编指令</h4><p>机器语言程序是一个由若干条机器指令组成的序列。</p><p>汇编语言程序将机器语言中的操作码或者操作数转换为汇编助记符。</p><p>操作码字段：指出指令的操作性质</p><p>立即数字段：指出操作数或者偏移量</p><p>寄存器编号字段：给出操作数或操作数地址所在的寄存器编号。</p><h4 id="1-2-指令集体系结构"><a href="#1-2-指令集体系结构" class="headerlink" title="1.2 指令集体系结构"></a>1.2 指令集体系结构</h4><p>Instruction Set Architecture，ISA，对使用硬件的软件屏蔽底层硬件的实现细节，将物理上的计算机硬件抽象成一个逻辑上的虚拟计算机，成为<strong>机器语言级虚拟机</strong>。</p><blockquote><p>正因为不同的硬件其指令集体系可能不同，因此同一个程序在不同的系统中运行时不一定能够兼容。可理解为在虚拟机A上运行的程序不能再虚拟机B上运行，但是Java程序不同，Java天生就运行在自己的虚拟机中，它不需要依赖于每个计算机的指令集体系，因此可以一次编译，到处运行。</p></blockquote><p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20201028000222620.png" alt="image-20201028000222620"></p><h4 id="1-3-生成机器代码的过程"><a href="#1-3-生成机器代码的过程" class="headerlink" title="1.3 生成机器代码的过程"></a>1.3 生成机器代码的过程</h4><ol><li>预处理：展开include和宏</li><li>编译：将c文件编译成汇编语言程序，使用的是AT&amp;T格式，目的操作数在右而源操作数在左。</li><li>汇编：将汇编程序转变成机器语言程序，一般是.o文件，可通过objdump -d filename进行反汇编</li><li>链接：将多个可重定位目标文件以及库函数链接起来，形成可执行文件</li></ol><p><strong>AT&amp;T格式：</strong></p><p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20201028163025532.png" alt="image-20201028163025532"></p><p><strong>可执行文件的存储器映像</strong></p><p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20201028164024259.png" alt="image-20201028164024259"></p><h3 id="2-IA-32指令系统概述"><a href="#2-IA-32指令系统概述" class="headerlink" title="2. IA-32指令系统概述"></a>2. IA-32指令系统概述</h3><h4 id="2-1-数据类型及其格式"><a href="#2-1-数据类型及其格式" class="headerlink" title="2.1 数据类型及其格式"></a>2.1 数据类型及其格式</h4><p>IBA规范中C语言基本数据类型和IA-32操作数长度之间的对应关系。</p><p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20201028163347300.png" alt="image-20201028163347300"></p><h4 id="2-2-寄存器组织和寻址方式"><a href="#2-2-寄存器组织和寻址方式" class="headerlink" title="2.2 寄存器组织和寻址方式"></a>2.2 寄存器组织和寻址方式</h4><p>IA-32指令的操作数有三类：立即数，寄存器操作数，存储器操作数</p><p><strong>定点寄存器</strong>：没有专门用途的可以存放各类定点操作数的寄存器。</p><p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20201028164056724.png" alt="image-20201028164056724"></p><p><strong>通用寄存器编号</strong></p><p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20201028164325127.png" alt="image-20201028164325127"></p><p><strong>寻址方式</strong></p><p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20201028164134080.png" alt="image-20201028164134080"></p><p>对于数组元素的访问一般采用“基址加比例变址”的寻址方式。</p><h4 id="2-3-机器指令格式"><a href="#2-3-机器指令格式" class="headerlink" title="2.3 机器指令格式"></a>2.3 机器指令格式</h4><p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20201028164422271.png" alt="image-20201028164422271"></p><h3 id="3-常用指令类型及其操作（重点）"><a href="#3-常用指令类型及其操作（重点）" class="headerlink" title="3. 常用指令类型及其操作（重点）"></a>3. 常用指令类型及其操作（重点）</h3><h4 id="3-1-传送指令"><a href="#3-1-传送指令" class="headerlink" title="3.1 传送指令"></a>3.1 传送指令</h4><ul><li>通用数据传送指令：<ul><li>MOV</li><li>MOVS：符号扩展</li><li>MOVZ：0扩展</li><li>XCHG</li><li>PUSH</li><li>POP</li></ul></li><li>地址传送指令：<ul><li>LEA（Load Effect Address）：将源操作数的存储地址送到目的寄存器中</li></ul></li><li>标志传送指令：<ul><li>pushf：将标志寄存器的内容压栈</li><li>popf：将栈顶内容送到标志寄存器</li></ul></li></ul><h4 id="3-2-定点算术运算指令"><a href="#3-2-定点算术运算指令" class="headerlink" title="3.2 定点算术运算指令"></a>3.2 定点算术运算指令</h4><p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20201028165255577.png" alt="image-20201028165255577"></p><ul><li><p>减法指令：后一个数减前一个数</p></li><li><p>比较指令</p><p>  类似使用SUB指令，置标志位后再接条件转移指令或者条件设置指令。</p></li><li><p>乘法指令</p><ol><li>只给出SRC，则另一个源操作数隐含在累加器AL&#x2F;AX&#x2F;EAX中，结果存放在<strong>2n位</strong>。</li><li>给出DST和SRC，结果放在<strong>n位</strong>DST中。</li><li>给出REG，SRC，IMM，则将SRC和立即数IMM相乘，结果存放在<strong>n位</strong>REG中。</li></ol><p>  关于乘法指令<strong>标志位</strong>的设置：</p><ul><li><p>对于MUL指令：</p><p>  若高位全为0，则OF和CF皆为0，否则皆为1</p></li><li><p>对于IMUL指令：</p><p>  若高位全为0或者1，并且等于低位中的最高位，则OF和CF全为0，否则全为1</p></li></ul></li><li><p>除法指令</p><p>  指令中只会明显指出除数，用累加器AL&#x2F;AX&#x2F;EAX指出被除数</p><p>  以8位除数为例，被除数被储存在AX寄存器中，商送回AL，余数在AH中（商在低位余在高）。</p></li></ul><h4 id="3-3-按位运算指令"><a href="#3-3-按位运算指令" class="headerlink" title="3.3 按位运算指令"></a>3.3 按位运算指令</h4><ul><li><p>逻辑运算指令</p><p>  仅NOT指令不影响标志位，其他指令执行后，OF&#x3D;CF&#x3D;0，ZF和SF根据结果判断</p><ul><li>NOT</li><li>AND</li><li>OR</li><li>XOR</li><li>TEST：根据两个操作数相与的结果来设置条件标志，<strong>常用于需检测某种条件但是不能改变原操作数的场合</strong>。</li></ul></li><li><p>移位指令</p><ul><li>SHL</li><li>SHR</li><li>SAL</li><li>SAR</li><li>ROL</li><li>ROR</li><li>RCL：带进位循环左移，将CF作为操作数的一部分循环左移</li><li>RCR</li></ul></li></ul><h4 id="3-4-控制转移指令"><a href="#3-4-控制转移指令" class="headerlink" title="3.4 控制转移指令"></a>3.4 控制转移指令</h4><p><strong>直接转移</strong>：转移的目标地址作为立即数直接出现在指令的机器码中</p><p><strong>间接转移</strong>：转移的目标地址间接存储在某一寄存器或存储单元中</p><p>在IA-32指令系统中，所有<strong>段内直接转移</strong>都是<strong>相对转移</strong>，所有<strong>段内间接转移或者段间转移</strong>都是<strong>绝对转移</strong>。</p><p><strong>条件转移指令</strong></p><p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20201028172009852.png" alt="image-20201028172009852"></p><p>对于带符号数可以这样判断：根据SF直接得出结果符号，在根据OF判断结果是否正确，若结果不正确则实际的大小判断要反过来</p><p>例如，SF&#x3D;1表示a-b结果是负的，本来应该是a&lt;b，但是OF&#x3D;1表示结果是错的，所以实际a&gt;b。</p><p><strong>条件设置指令</strong></p><p>将条件标志组合得到的条件值设置到一个8位通用寄存器中，其设置的条件值与上表中的转移条件值完全一样。</p><p><strong>调用和返回指令</strong></p><ul><li>CALL DST：返回地址RA入栈，转到DST处执行</li><li>RET：从栈中取出返回地址RA，转到RA处执行</li></ul><h4 id="3-5-x87浮点处理指令"><a href="#3-5-x87浮点处理指令" class="headerlink" title="3.5 x87浮点处理指令"></a>3.5 x87浮点处理指令</h4><p>IA-32有两种浮点处理架构：浮点协处理器架构、MMX发展而来的SSE指令集架构</p><p>x87FPU有一个浮点寄存器栈，深度为8，每个浮点寄存器有80位。</p><p>浮点数装入指令（FLD）float load：将存储单元中的浮点数装入到浮点寄存器的栈顶ST(0)，无论是flds(float装入)还是fldl(double装入)都要先转换为80位扩展精度格式后再装入栈顶ST(0)。</p><p>FST(float store)：浮点数存储指令，将浮点数装入到浮点寄存器栈的栈顶ST(0)。</p><p>FSTP：同上，但是会将该数据弹出栈</p><p>由于浮点寄存器的宽度为80位，因此需要先将80位扩展精度格式转换为32位或64位后，再存储到指定存储单元中，这可能会造成<strong>精度丢失</strong>。</p><h4 id="3-6-MMX-x2F-SSE指令集"><a href="#3-6-MMX-x2F-SSE指令集" class="headerlink" title="3.6 MMX&#x2F;SSE指令集"></a>3.6 MMX&#x2F;SSE指令集</h4><p>一个处理浮点数的指令集，提高了多媒体、图形图像等方面的处理能力。</p><h3 id="4-C语言的机器级表示"><a href="#4-C语言的机器级表示" class="headerlink" title="4. C语言的机器级表示"></a>4. C语言的机器级表示</h3><h4 id="4-1-过程调用的机器级表示"><a href="#4-1-过程调用的机器级表示" class="headerlink" title="4.1 过程调用的机器级表示"></a>4.1 过程调用的机器级表示</h4><p>IA-32中用于过程调用的指令：CALL和RET</p><p>为了支持嵌套和递归调用，通常利用栈来保存返回地址，入口参数和过程内部定义的非静态局部变量。</p><p>CALL在跳转之前会将返回地址压栈，RET在返回之前会从栈中取出返回地址。</p><p><span style="color:blue; font-weight:bold; font-size:20px">过程调用执行步骤</span></p><p>令P为调用者（caller），Q为被调用者（callee）。</p><ol><li>P将入口参数（实参）放到Q能访问到的地方。</li><li>P将返回地址存到特定地方，然后将控制转移到Q。</li><li>Q保存P的现场，并为自己的非静态局部变量分配空间。（准备阶段）</li><li>执行Q的过程体（函数体）。</li><li>Q恢复P的现场，并释放局部变量所占用的空间。（结束阶段）</li><li>Q取出返回地址，将控制转移到P。</li></ol><p>原因：调用者和被调用者公用一套通用寄存器，因此被调用者不能破坏原有寄存器的内容，需要先保存到栈中。</p><p><strong>现场</strong>：通用寄存器中原先的值</p><p><span style="color:blue;font-weight:bold">IA-32的寄存器使用规定</span></p><p><strong>调用者保存寄存器</strong>：EAX，EDX，ECX（ADC），P在<strong>转到Q之前</strong>先保存他们的值，并在Q返回后先回复他们的值再使用。Q能够直接使用他们。</p><p><strong>被调用者保存寄存器</strong>：EBX，ESI，EDI，Q必须在使用他们之前先将他们的值保存到栈中，并在返回P之前恢复它们的值。</p><p><span style="color:blue;font-weight:bold">IA-32的栈，栈帧及其结构</span></p><p><strong>需要压入栈中的内容</strong>：过程的入口参数，返回地址，被保存寄存器的值，被调用过程中的非静态局部变量。</p><p><strong>栈帧</strong>：为每个过程分配的栈区，一个栈由若干个栈帧组成。<strong>每个栈帧从EBP的旧值开始，到返回地址结束</strong></p><p><strong>帧指针寄存器</strong>：存放每个栈帧的起始位置，当前栈帧的范围在EBP和ESP指向的内存地址之间。在过程执行时，<strong>栈指针</strong>会不断移动，而<strong>帧指针</strong>可以固定不变。</p><p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20201101093210811.png" alt="image-20201101093210811"></p><p><span style="color:red;font-weight:bold">注意</span>：参数是倒着放的！</p><p>ESP+8总是指向第一个参数，之后的参数在此基础上每个+4。</p><p><span style="color:blue;font-weight:bold">变量的作用域和生存周期</span></p><p>非静态局部变量只在Q执行过程中有效，当Q返回P后，这些变量的内存都会被释放。它们的生存周期也只在该栈帧被分配的时间内。</p><p>C语言的<strong>外部参照型变量</strong>和<strong>静态变量</strong>被分配在静态数据区，具有“全局生存期”。</p><p>例：</p><p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20201214101423371.png" alt="image-20201214101423371"></p><p>该函数在执行过程中栈帧的使用情况如下：</p><p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20201214101757827.png" alt="image-20201214101757827"></p><p><strong>leave指令功能</strong>：</p><p><code>movl %ebp, %esp</code></p><p><code>popl %ebp</code></p><p>将esp指向ebp的旧值，弹出ebp，即栈帧回到上一个函数，此时esp指向返回地址，通过ret返回到上一个函数的代码段。</p><hr><p><span style="color:blue;font-weight:bold">递归过程调用</span></p><p>求自然数之和的递归函数例子：</p><p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20201214103228355.png" alt="image-20201214103228355"></p><p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20201214103333816.png" alt="image-20201214103333816"></p><p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20201214103947127.png" alt="image-20201214103947127"></p><p>递归的过程如图所示：</p><p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20201214104510925.png" alt="image-20201214104510925"></p><p>递归调用的缺点：</p><p>对于栈的开销很大，容易发生栈溢出。</p><p><span style="color:blue;font-weight:bold">非静态局部变量的存储分配</span></p><p>对于非静态局部变量的分配顺序，C标准规范中没有规定必须是按顺序从大地址到小地址还是反过来，因此属于<strong>未定义行为</strong>。</p><p>对不同变量的地址进行除&#x3D;&#x3D;和!&#x3D;之外的关系运算属于未定义行为，如<code>if(&amp;var1 &lt; &amp;var2)</code>会报错。</p><h4 id="4-2-选择语句的机器级表示"><a href="#4-2-选择语句的机器级表示" class="headerlink" title="4.2 选择语句的机器级表示"></a>4.2 选择语句的机器级表示</h4><p><span style="color:blue;font-weight:bold">if-else语句的机器级表示</span></p><p>大多结合<code>cmp, jmp</code>和标号来实现</p><p><span style="color:blue;font-weight:bold">switch语句的机器级表示</span></p><p>switch可以直接跳转到某个条件处的语句执行，而不需要一一测试条件。</p><p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20201214110055734.png" alt="image-20201214110055734"></p><p>但是，当case的条件值相差较大时，编译器依然会生成分段跳转代码</p><p><span style="color:blue;font-weight:bold">循环结构的机器级表示</span></p><p>略</p><h3 id="5-复杂数据类型的分配和访问"><a href="#5-复杂数据类型的分配和访问" class="headerlink" title="5. 复杂数据类型的分配和访问"></a>5. 复杂数据类型的分配和访问</h3><h4 id="5-1-数组的分配和访问"><a href="#5-1-数组的分配和访问" class="headerlink" title="5.1 数组的分配和访问"></a>5.1 数组的分配和访问</h4><p>数组是数据集合，因而一定被放置在存储器中。</p><p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20201218101927030.png" alt="image-20201218101927030"></p><p><strong>注意：</strong>指针类型的大小与操作系统的位数有关</p><p>数组元素和指针变量的表达式计算示例</p><p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20201218102020375.png" alt="image-20201218102020375"></p><h4 id="5-2-结构体数据的分配和访问"><a href="#5-2-结构体数据的分配和访问" class="headerlink" title="5.2 结构体数据的分配和访问"></a>5.2 结构体数据的分配和访问</h4><p>指向结构体的指针就是其第一个字节的地址</p><p>结构体变量通常采用<strong>按地址传递</strong>的方式</p><h4 id="5-3-联合体数据的分配和访问"><a href="#5-3-联合体数据的分配和访问" class="headerlink" title="5.3 联合体数据的分配和访问"></a>5.3 联合体数据的分配和访问</h4><p>联合体各个成员共享储存空间，分配给它的存储空间总是按照最大数据长度成员所需的空间大小为目标</p><p>利用联合体数据结构，可以实现对相同序列进行不同数据类型的解释</p><h4 id="5-4-数据的对齐"><a href="#5-4-数据的对齐" class="headerlink" title="5.4 数据的对齐"></a>5.4 数据的对齐</h4><p>在8字节宽的存储器机制下，访问数据的效率较高，因此需要进行数据的对齐。</p><p>i386 System V ABI 中对齐策略规定：</p><p>short地址是2的倍数</p><p>int, float, double和指针类型地址都是4的倍数</p><br><p>ABI规范只定义了变量的对齐方式，而没有定义变量的分配顺序，编译器可以自由决定使用何种顺序来分配变量。</p><p>i386 System V ABI对结构体有如下对齐方式要求：</p><ol><li>整个结构体的对齐方式与最严格的成员相同</li><li>每个成员<strong>在满足其对齐方式的前提下</strong>，取最小的可用位置作为在结构体中的偏移量，可能<strong>内部插空</strong></li><li>结构体大小为对齐边界长度的整数倍，可能<strong>尾部插空</strong></li></ol><p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20201218103529440.png" alt="image-20201218103529440"></p><h3 id="6-越界访问和缓冲区溢出"><a href="#6-越界访问和缓冲区溢出" class="headerlink" title="6. 越界访问和缓冲区溢出"></a>6. 越界访问和缓冲区溢出</h3><h4 id="6-1-缓冲区溢出"><a href="#6-1-缓冲区溢出" class="headerlink" title="6.1 缓冲区溢出"></a>6.1 缓冲区溢出</h4><p>在访问数组时发生超越数组存储区的越界访问，通常把这种存储区看成是一个缓冲区，这种超越数组存储区范围的访问称为<strong>缓冲区溢出</strong>。</p><h4 id="6-2-缓冲区溢出攻击"><a href="#6-2-缓冲区溢出攻击" class="headerlink" title="6.2 缓冲区溢出攻击"></a>6.2 缓冲区溢出攻击</h4><p>将恶意代码段的首地址作为返回地址覆盖地写到原先正确的返回地址处，在ret指令执行后就会转到该段代码执行</p><p>防范方法：</p><ol><li><p>用辅助攻击帮助查漏，如使用grep来搜索源代码中容易产生漏洞的库函数，或用fault injection差错</p></li><li><p>地址空间随机化ASLR：将加载程序时生成的代码段、静态数据段、堆区、动态库和栈区各部分的首地址进行随机化处理，使每次启动时，程序各段被加载到不同地址起始处</p></li><li><p>栈破坏检测：<strong>在函数准备阶段</strong>，在其栈帧中缓冲区底部与保存寄存器之间（如<strong>buffer[15]<strong>与保留的</strong>EBP</strong>之间）加入一个随机生成的特定值；<strong>在函数恢复阶段</strong>，在恢复寄存器并返回到调用函数前，先检查该值是否被改变。若改变则程序异常中止。<strong>因为插入在栈帧中的特定值是随机生成的，所以攻击者很难猜测出它是什么</strong></p></li><li><p>可执行代码区域的限制：通过将程序栈区和堆区设置为不可执行，从而使得攻击者不可能执行被植入在输入缓冲区的代码，这种技术也被称为<strong>非执行的缓冲区技术</strong></p></li></ol><h3 id="7-兼容IA-32的64位系统"><a href="#7-兼容IA-32的64位系统" class="headerlink" title="7. 兼容IA-32的64位系统"></a>7. 兼容IA-32的64位系统</h3><h4 id="7-1-x86-64的基本特点"><a href="#7-1-x86-64的基本特点" class="headerlink" title="7.1 x86-64的基本特点"></a>7.1 x86-64的基本特点</h4><ol><li><p><span style="color:blue">更多的通用寄存器个数</span></p><p> 增加了8个64位寄存器R8~R15，可以作为8位寄存器(R8B ~ R15B)，16位寄存器(R8W ~ R15W)，32位寄存器(R8D ~ R15D)。</p></li><li><p><span style="color:blue">比IA-32具有更长的通用寄存器位数</span></p><p> 所有通用寄存器被扩展到了64位，RAX,RBX,RCX,RDX, RBP,RSP,RSI,RDI，并且EBP,ESP,ESI,EDI的低8位可以使用，分别为BPL,SPL,SIL,DIL（注意是3个字母，区别AL,BL等）</p></li><li><p><span style="color:blue">字长从32位变成64位，逻辑地址相应变化</span></p></li><li><p><span style="color:blue">对于long double型数据</span>，虽然还是采用IA-32相同的80为扩展精度格式，但分配的存储空间从12字节扩展为16字节，从4B对齐改为16B对齐，但使用时都只会用到低10字节</p></li><li><p><span style="color:blue">过程调用时</span>，如果入口参数只有6个以内的整型变量和指针型变量，通常采用通用寄存器而不是栈来传递。</p></li><li><p><span style="color:blue">128位的XMM寄存器</span>从8个增加到16个，浮点操作采用基于SSE的面向XMM的指令集</p></li></ol><h4 id="7-2-x86-64的基本指令和对齐"><a href="#7-2-x86-64的基本指令和对齐" class="headerlink" title="7.2 x86-64的基本指令和对齐"></a>7.2 x86-64的基本指令和对齐</h4><p>当指令中的操作数为存储器操作数时，其基址寄存器或者变址寄存器必须是64位寄存器。（因为地址是64位的）</p><p><strong>数据传送指令</strong></p><p><code>movabsq</code>：将64位立即数(abs)送到64位通用寄存器中</p><p><code>movq</code>：传送一个64位的四字</p><p><code>movsbq, movswq, movslq</code>：符号扩展</p><p><code>movzbq, movzwq, movzlq</code>：零扩展</p><p><code>leaq</code>：将有效地址加载到64位寄存器</p><p><code>pushq, popq</code>：压栈，出栈</p><p><code>movl</code>：在传送32位寄存器内容的同时，<strong>将目的寄存器的高32位自动清零</strong>，也因此<code>movl</code>相当于<code>movzlq</code>指令</p><p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20201218111213016.png" alt="image-20201218111213016"></p><p><strong>算术逻辑运算指令</strong></p><p><code>addq, subq, imulq(带符号整数相乘), mulq, orq, incq, decq, negq, notq, salq </code></p><p><strong>数据对齐</strong></p><p>任何K字节宽的基本类型数据和指针类型数据的起始地址<strong>一定是K的倍数</strong></p><p>long, double型数据和指针变量都必须按8字节对齐；long double型数据必须按16字节边界对齐</p><h4 id="7-3-x86-64的过程调用"><a href="#7-3-x86-64的过程调用" class="headerlink" title="7.3 x86-64的过程调用"></a>7.3 x86-64的过程调用</h4><p>可以不用栈指针寄存器RBP作为栈帧底部，而是使用RSP作为基址寄存器来访问栈帧中的信息</p><p>传送入口参数的寄存器依次为RDI,RSI,RDX,RCX,R8,R9（6个），返回参数放在RAX中</p><p>调用者保存寄存器为R10，R11，被调用者保存寄存器为RBX，RBPR12，R13，R14，R15</p><p>RSP用于指向栈顶元素</p><p>RIP用于指向正在执行或者即将执行的命令</p><p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20201218112102346.png" alt="image-20201218112102346"></p><h4 id="7-4-x86-64的浮点数操作与SIMD指令"><a href="#7-4-x86-64的浮点数操作与SIMD指令" class="headerlink" title="7.4 x86-64的浮点数操作与SIMD指令"></a>7.4 x86-64的浮点数操作与SIMD指令</h4><p>浮点运算采用基于SSE的面向XMM寄存器的SIMD指令，浮点数放在128位的XMM寄存器中，不再放在寄存器栈中。</p><h2 id="第四章-程序的链接"><a href="#第四章-程序的链接" class="headerlink" title="第四章 程序的链接"></a>第四章 程序的链接</h2><h3 id="1-编译、汇编和链接"><a href="#1-编译、汇编和链接" class="headerlink" title="1. 编译、汇编和链接"></a>1. 编译、汇编和链接</h3><h4 id="1-1-编译和汇编"><a href="#1-1-编译和汇编" class="headerlink" title="1.1 编译和汇编"></a>1.1 编译和汇编</h4><p>预处理：对头文件的包含，宏定义的扩展，条件编译的选择，“gcc -E main.c -o main.i”或“cpp main.c -o main.i”</p><p>编译：对源程序进行词法分析、语法分析和语义分析，并进行优化和存储分配，最终把C语言源程序翻译成汇编语言程序。对应指令为“gcc -S main.i -o main.s”</p><p>汇编：将编译生成的汇编语言代码转换为机器语言代码，不能确定每条指令或者每个数据最终的地址，需要进行重定位。对应指令为“gcc -c main.c -o main.o”</p><h4 id="1-2-可执行目标文件的生成"><a href="#1-2-可执行目标文件的生成" class="headerlink" title="1.2 可执行目标文件的生成"></a>1.2 可执行目标文件的生成</h4><p>将所有关联的可重定位目标文件组合起来，以生成一个可执行文件。”ld -o test main.o test.o”，ld是静态链接指令</p><p>可重定位目标文件的代码总是从0开始，而可执行文件的代码在虚拟地址空间产生</p><p><span style="color:blue">可重定位目标文件合成可执行目标文件</span>需要以下两步：</p><ol><li><p>符号解析</p><p> 将每个<strong>符号的引用</strong>与一个确定的<strong>符号定义</strong>相关联。符号包括<strong>全局静态变量名</strong>和<strong>函数名</strong>。<span style="color:red">非静态局部变量不是符号。</span></p><p> 编译器会将所有符号存放在可重定位目标文件的符号表中。</p></li><li><p>重定位</p><p>代码区和数据区都是从0地址开始的。链接器需要将不同模块中相同的节合并起来生成一个单独的节，并进行虚拟地址空间划分来重新确定位置。重新确定代码和数据的地址并更新指令中被引用符地址号叫做<strong>重定位</strong>。</p></li></ol><p>链接的好处：实现“模块化”，方便编写，建立函数库；每个模块分开编译，提高开发效率。</p><h3 id="2-目标文件格式"><a href="#2-目标文件格式" class="headerlink" title="2. 目标文件格式"></a>2. 目标文件格式</h3><p>目标代码：将编译器或汇编器处理源代码后生成的机器语言目标代码</p><p>目标文件：存放目标代码的文件</p><h4 id="2-1-ELF目标文件格式"><a href="#2-1-ELF目标文件格式" class="headerlink" title="2.1 ELF目标文件格式"></a>2.1 ELF目标文件格式</h4><p>目标文件包含<strong>机器代码</strong>、<strong>数据</strong>、<strong>重定位信息</strong>和<strong>调试信息</strong>。</p><p>ELF（Executable and Linkable Format）：可执行可链接格式，由UNIX操作系统使用</p><p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20201218222521056.png" alt="image-20201218222521056"></p><p>节：ELF文件中具有相同特征的最小可处理信息单位</p><p>代码节(.text)、只读数据节(.rodata)、已初始化全局数据节(.data)、未初始化全局数据节(.bss)。</p><p>段：描述目标文件中的节如何映射到存储空间的段中，可以将多个节合并后映射到同一个段，如.data和.bss映射到可读可写数据段中。</p><p><strong>节头表</strong>：包含文件中各个节的说明信息。有每个节的名字和大小之类的信息。<span style="color:red">可重定位目标文件一定要有节头表。</span></p><p><strong>程序头表</strong>：指示系统如何创建进程的存储器映像。<span style="color:red">可执行文件和共享库文件必须要有程序头表。</span></p><h4 id="2-2-可重定位目标文件格式"><a href="#2-2-可重定位目标文件格式" class="headerlink" title="2.2 可重定位目标文件格式"></a>2.2 可重定位目标文件格式</h4><p>总体结构如下：</p><p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20201218223240634.png" alt="image-20201218223240634"></p><ol><li><p>ELF头</p><p> 位于目标文件的起始位置，包含文件结构的说明信息。共52个字节，仅ELF头在文件中具有固定的位置，其他部分由ELF头和节头表指出。</p><p> e_shoff指出节头表在文件中的偏移量</p><p> 使用”readelf -h main.o”对文件进行解析</p></li><li><p>节</p><p> ELF文件中的主体信息，包含了链接过程中所使用的目标代码信息，包括指令，数据，符号表和重定位信息等。</p><p> <strong>.text</strong>:目标代码</p><p> <strong>.rodata</strong>:只读数据，如printf中的格式串，开关语句(switch-case)的跳转表</p><p> <strong>.data</strong>:已初始化全局变量</p><p> <strong>.bss</strong>:未初始化全局变量。无须在目标文件中分配用于保存值的空间，仅仅是一个占位符</p><p> <strong>.symlab</strong>:符号表，程序中定义的函数和全局静态变量名都是符号</p><p> <strong>.rel.text</strong>:.text节相关的可重定位信息。当目标文件组合时，指令中的引用操作数地址信息或者跳转目标指令位置信息都要被修改。一般调用外部函数或者引用全局变量的指令中的地址字段需要被修改。</p><p> <strong>.rel.data</strong>:.data节相关可重定位信息。</p><p> .debug:调试用符号表。</p><p> .line:行号和.text节之间的映射。</p><p> .strlab:字符串表，包括.symlab节和.debug节中的符号以及节头表中的节名</p></li><li><p>节头表</p><p> 由若干个表项组成，每个表描述相应的一个节的节名，在文件中的偏移，大小，访问属性，对齐方式等。</p><p> 使用<code>readelf -S test.o</code>来解析文件得到如下结果</p><p> <img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20201219103828989.png" alt="image-20201219103828989"></p><p> 将该信息映射到文件结构中：</p><p> <img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20201219104013139.png" alt="image-20201219104013139"></p></li></ol><h4 id="2-3-可执行目标文件格式"><a href="#2-3-可执行目标文件格式" class="headerlink" title="2.3 可执行目标文件格式"></a>2.3 可执行目标文件格式</h4><p>ELF可执行目标文件由ELF头、程序头表、节头表和不同的节组成。</p><p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20201219104926204.png" alt="image-20201219104926204"></p><p>程序头表：将可执行文件中连续的、具有相同访问属性的代码和数据段映射到存储空间（通常是虚拟地址空间）中，程序头表用于描述这种映射关系。</p><p>32位程序头表具有以下数据结构：</p><p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20210204165601527.png" alt="image-20210204165601527"></p><p>使用<code>readelf -l filename</code>指令显示可执行文件的程序头表信息：</p><p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20210204165933629.png" alt="image-20210204165933629"></p><h4 id="2-4-可执行文件的存储映像"><a href="#2-4-可执行文件的存储映像" class="headerlink" title="2.4 可执行文件的存储映像"></a>2.4 可执行文件的存储映像</h4><p>可执行文件到虚拟地址空间的映射是建立存储映像的过程。</p><p>i386 System V ABI规定，<strong>只读代码段</strong>总是映射到从虚拟地址0x8048000开始的一段区域，<strong>可读写数据段</strong>映射到只读代码段后面按4KB对齐的高地址上，<strong>运行时堆</strong>则在可读写数据段后面4KB对齐的高地址处，<strong>运行时用户栈</strong>则是从用户空间的最大地址往低地址方向生长。</p><p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20210204170744122.png" alt="image-20210204170744122"></p><h3 id="3-符号表和符号解析"><a href="#3-符号表和符号解析" class="headerlink" title="3. 符号表和符号解析"></a>3. 符号表和符号解析</h3><h4 id="3-1-符号和符号表"><a href="#3-1-符号和符号表" class="headerlink" title="3.1 符号和符号表"></a>3.1 符号和符号表</h4><p>全局符号：非静态函数名和被定义为不带static属性的全局变量名</p><p>外部符号：在其他模块定义的外部函数名和外部变量名</p><p>本地符号：带static属性的函数名和全局变量名</p><p>ELF文件中包含的符号表中每个表项具有以下数据结构：</p><p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20210204172245845.png" alt="image-20210204172245845"></p><p>另外，st_other显示符号可见性，st_shndx指出符号所在节在节头表中的索引。</p><p>可通过<code>readelf -s main.o</code>查看符号表：</p><p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20210204172636470.png" alt="image-20210204172636470"></p><h4 id="3-2-符号解析"><a href="#3-2-符号解析" class="headerlink" title="3.2 符号解析"></a>3.2 符号解析</h4><p>全局符号的强弱特性：</p><p><strong>强符号</strong>：函数名和已初始化的全局变量名</p><p><strong>弱符号</strong>：未初始化的全局变量名</p><p>链接器处理符号的规则如下：</p><ol><li>强符号不能多次定义。</li><li>强符号覆盖同名弱符号。</li><li>多个弱符号任选一个。</li></ol><p><strong>符号解析过程：</strong></p><p>链接器在进行符号解析时需要维护3个集合：</p><p>集合E指被合并到一起的组成可执行文件的所有<strong>目标文件集合</strong></p><p>集合U是<strong>未解析符号集合</strong></p><p>集合D是当前为止已经加入到E的所有目标文件中<strong>定义符号的集合</strong></p><ol><li>对每个输入文件f，若为目标文件，将f加入到E，并修改U，D</li><li>若为库文件，则匹配U中符号和f中各目标模块定义的符号</li><li>若往D中加入一个已存在的符号，或者扫描完所有输入文件时U非空，则链接器报错</li></ol><h4 id="3-3-与静态库的链接"><a href="#3-3-与静态库的链接" class="headerlink" title="3.3 与静态库的链接"></a>3.3 与静态库的链接</h4><p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20210204173732706.png" alt="image-20210204173732706"></p><h3 id="4-重定位"><a href="#4-重定位" class="headerlink" title="4. 重定位"></a>4. 重定位</h3><p>重定位的目的是<strong>在符号解析的基础上</strong>将所有关联的目标模块合并，并确定运行时<strong>每个定义符号</strong>在虚拟空间中的地址，<strong>重定位引用的地址</strong>。</p><ol><li>节和定义符号的重定位。合并所有节</li><li>引用符号的重定位。其中重定位信息放在.rel.text和rel.data中，告知链接器目标文件中哪些引用符号需要重定位，所引用的是哪个定义符号等</li></ol><p><strong>重定位信息</strong></p><p>表项数据结构如下：</p><p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20210204174548970.png" alt="image-20210204174548970"></p><p>r_offset指出需重定位的位置相对节起始位置偏移量。</p><p>r_info包含符号索引和重定位类型，其中r_sym指出符号在符号表中的位置，r_type分为PC（下条指令地址）相对寻址和绝对地址。</p><p>重定位表信息可通过<code>readelf -r main.o</code>来显示。</p><p>IA-32 中转移目标地址（即有效地址）计算公式为：转移目标地址 &#x3D;PC+ 偏移地址</p><p>PC相对地址方式下的重定位值计算公式为：ADDR(r_sym) - ((ADDR(.text) + r_offset) - init)</p><p>绝对地址可直接加算</p><p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20210204183433618.png" alt="image-20210204183433618"></p><h3 id="5-动态链接"><a href="#5-动态链接" class="headerlink" title="5. 动态链接"></a>5. 动态链接</h3><p>特性：</p><ol><li>共享性：代码段在内存中只存在一份副本，不需要将代码合并到生成文件中去</li><li>动态性：只在使用它的程序被加载或者执行时才加载到内存，因而在共享库更新后并不需要重新对程序进行链接</li></ol><p>生成指令：<code>gcc -shared -fPIC -o mylib.so myproc1.c myproc2.c</code></p><p>-fPIC(Position-Independent Code): 位置无关代码，即共享库代码与位置无关。</p><h4 id="5-1-程序加载时的动态链接"><a href="#5-1-程序加载时的动态链接" class="headerlink" title="5.1 程序加载时的动态链接"></a>5.1 程序加载时的动态链接</h4><p>生成可执行文件指令：<code>gcc -o myproc main.c ./mylib.so</code></p><p><img src="/2023/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/image-20210204183941910.png" alt="image-20210204183941910"></p><h4 id="5-2-程序运行时的动态链接"><a href="#5-2-程序运行时的动态链接" class="headerlink" title="5.2 程序运行时的动态链接"></a>5.2 程序运行时的动态链接</h4><p>指令：<code>gcc -rdynamic -o myproc main.c -ldl</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;dlfcn.h&gt;</span>  <span class="hljs-comment">/* 声明动态链接器接口 */</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">void</span> *handle;<br>    <span class="hljs-type">void</span> (*myfunc1)();<br>    <span class="hljs-type">char</span> *error;<br>    <br>    <span class="hljs-comment">/* 动态装入包含函数myfunc1()的共享库文件 */</span><br>    handle = dlopen(<span class="hljs-string">&quot;./mylib.so&quot;</span>, RTLD_LAZY);   <span class="hljs-comment">//延迟绑定：外部符号引用不在加载时重定位，而是在第一次调用时重定位</span><br>    <span class="hljs-keyword">if</span>(!handle) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;%s\n&quot;</span>, dlerror());<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">/* 获得一个指向函数myfunc1()的指针 */</span><br>    myfunc1 =  dlsym(handle, <span class="hljs-string">&quot;myfunc1&quot;</span>);<br>    <span class="hljs-keyword">if</span>((error = dlerror()) != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;%s\n&quot;</span>, error);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">/* 现在可以像调用其他函数一样调用函数myfunc1() */</span><br>    myfunc1();<br>    <br>    <span class="hljs-comment">/* 关闭（卸载）共享库文件 */</span><br>    <span class="hljs-keyword">if</span>(dlclose(handle) &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;%s\n&quot;</span>, dlerror());<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>二叉搜索树&amp;AVL树&amp;红黑树</title>
    <link href="/2023/01/10/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91&amp;AVL%E6%A0%91&amp;%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <url>/2023/01/10/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91&amp;AVL%E6%A0%91&amp;%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉搜索树-amp-AVL树-amp-红黑树"><a href="#二叉搜索树-amp-AVL树-amp-红黑树" class="headerlink" title="二叉搜索树&amp;AVL树&amp;红黑树"></a>二叉搜索树&amp;AVL树&amp;红黑树</h1><h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><blockquote><p>二叉搜索树，顾名思义，就是便于进行搜索的二叉树，对于每一个子树来说，其左子树的值必定小于根节点的值，其右子树的值必定大于根节点的值，二叉搜索树的性质如下：</p><ol><li>左子树关键字 &lt; 根节点关键字 &lt; 右子树关键字</li><li>查找元素的平均时间复杂度是O(log n)，但最坏时间复杂度可以达到O(n)，也就是所有子树只有一个分支。</li><li>对二叉搜索树进行一次<strong>中序遍历</strong>，得到的是一个从小到大的键值排序。</li><li>对二叉搜索树进行插入操作时，必定是插入到叶子结点。</li></ol></blockquote><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>基本思路：如果需要查找的键值等于根节点，则更新它；如果小于根节点键值，递归查找左子树；大于同理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ElemType;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> K(n) ((n) ? (n)-&gt;key : 0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> H(n) ((n) ? (n)-&gt;height : 0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> L(n) (n-&gt;lchild)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> R(n) (n-&gt;rchild)</span><br><br><span class="hljs-comment">//树的结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    ElemType key;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> *lchild, *rchild;<br>    <span class="hljs-type">int</span> height;<br>&#125; Node;<br><br><span class="hljs-comment">//用于比较键值的函数，主要是考虑到可扩展性强，比如稍作修改就能够根据字符串的字典序比较了</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cmp_key</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> a - b; &#125;<br><br><span class="hljs-function">Node *<span class="hljs-title">get_new_node</span><span class="hljs-params">(ElemType key)</span></span><br><span class="hljs-function"></span>&#123;<br>    Node *s = (Node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Node));<br>    s-&gt;height = <span class="hljs-number">1</span>;<br>    s-&gt;key = key;<br>    s-&gt;lchild = s-&gt;rchild = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br><br><span class="hljs-comment">//查找函数，如果没有找到返回-1</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(Node *root, ElemType key,Node *x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">cmp_key</span>(root-&gt;key, key) == <span class="hljs-number">0</span>)&#123;<br>        (*x) = (*root);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">cmp_key</span>(root-&gt;key, key) &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">search</span>(root-&gt;lchild,key,x);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">search</span>(root-&gt;rchild,key,x);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>插入的新结点要么更新现有结点，要么插入到叶节点，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Node *<span class="hljs-title">insert</span><span class="hljs-params">(Node *root, ElemType key)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">get_new_node</span>(key);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">cmp_key</span>(key, root-&gt;key) == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> root;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">cmp_key</span>(key, root-&gt;key) &lt; <span class="hljs-number">0</span>)<br>        root-&gt;lchild = <span class="hljs-built_in">insert</span>(root-&gt;lchild, key);<br>    <span class="hljs-keyword">else</span> &#123;<br>        root-&gt;rchild = <span class="hljs-built_in">insert</span>(root-&gt;rchild, key);<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：由于插入的结点可能是根节点，所以需要返回这个被修改过的或者更新过的根节点的地址，使该根节点的前一个结点能够存储到它的地址。</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除的操作较为复杂，需要分如下情况讨论：</p><ol><li>删除叶子结点：直接删除</li><li>删除的结点只有一个分支：将该分支替换待删除的结点</li><li>删除的结点有两个分支：寻找该结点的前驱或者后继结点，将该问题转化成问题2（<em>前驱</em>：小于当前结点的最大结点，也就是左子树的最右结点；<em>后继</em>：大于当前结点的最小结点，也就是右子树的最左结点）</li></ol><br><p><strong>下面将以前驱结点替换待删除结点为例，分析第3种删除操作:</strong></p><br><p><img src="/2023/01/10/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91&AVL%E6%A0%91&%E7%BA%A2%E9%BB%91%E6%A0%91/search_insert1.png" alt="insert"></p><center>初始状态</center><p><img src="/2023/01/10/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91&AVL%E6%A0%91&%E7%BA%A2%E9%BB%91%E6%A0%91/search_insert2.png" alt="insert"></p><center>将根节点替换为前驱结点</center><p><img src="/2023/01/10/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91&AVL%E6%A0%91&%E7%BA%A2%E9%BB%91%E6%A0%91/search_insert3.png" alt="insert"></p><center>像步骤二一样删除前驱结点</center><br><p>能够这样替换的原因是该前驱结点一定比右子树的所有结点键值小<strong>（性质1）</strong>，而且是左子树中键值最大的那个，因此可以放置在该位置。后继结点的替换同理。</p><blockquote><p>代码如下：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//寻找前驱结点</span><br><span class="hljs-function">Node *<span class="hljs-title">predecessor</span><span class="hljs-params">(Node *root)</span></span><br><span class="hljs-function"></span>&#123;<br>    Node *temp = root-&gt;lchild;<br>    <span class="hljs-keyword">while</span> (temp-&gt;rchild != <span class="hljs-literal">NULL</span>) &#123;<br>        temp = temp-&gt;rchild;<br>    &#125;<br>    <span class="hljs-keyword">return</span> temp;<br>&#125;<br><br><span class="hljs-function">Node *<span class="hljs-title">erase</span><span class="hljs-params">(Node *root, ElemType key)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">cmp_key</span>(key, root-&gt;key) &lt; <span class="hljs-number">0</span>)<br>        root-&gt;lchild = <span class="hljs-built_in">erase</span>(root-&gt;lchild, key);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">cmp_key</span>(key, root-&gt;key) &gt; <span class="hljs-number">0</span>)<br>        root-&gt;rchild = <span class="hljs-built_in">erase</span>(root-&gt;rchild, key);<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//没有分支和只有一个分支可以看作是一种情况</span><br>        <span class="hljs-keyword">if</span> (root-&gt;lchild == <span class="hljs-literal">NULL</span> || root-&gt;rchild == <span class="hljs-literal">NULL</span>) &#123;<br>            Node *temp = root-&gt;lchild ? root-&gt;lchild : root-&gt;rchild;<br>            <span class="hljs-built_in">free</span>(root);<br>            root = temp;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Node *temp = <span class="hljs-built_in">predecessor</span>(root);<br>            root-&gt;key = temp-&gt;key;<br>            root-&gt;lchild = <span class="hljs-built_in">erase</span>(root-&gt;lchild, temp-&gt;key);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h2><p>AVL树是建立在二叉搜索树之上的平衡树，它具有以下性质：</p><h3 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h3><blockquote><ol><li>继承搜索二叉树的所有性质</li><li>对于任意一个结点来说，它的左子树和右子树高度的差值不会超过1</li><li>AVL树最坏情况下的查找时间复杂度也只有O(log n)的程度，相较于二叉搜索树大大降低(O(n))</li></ol></blockquote><p>对于性质3，原因在于相同高度下，二叉搜索树最坏只能存储H个结点，而AVL树能够存储至少 $ 1.6^H $个结点。</p><blockquote><p>这里可以根据斐波那契数列的通项公式推导，假设一颗层数为H的AVL树最少存储low(H)个结点，则<br>$$<br>low(H) &#x3D; 1 + low(H - 1) + low(H - 2)<br>$$<br>经过推导大约为 $ 1.6^H $个结点。</p></blockquote><p>正是因为每一次的插入和删除都可能破坏AVL树的平衡性<strong>（性质2）</strong>，因此需要对四种失衡类型进行讨论。</p><h3 id="失衡类型"><a href="#失衡类型" class="headerlink" title="失衡类型"></a>失衡类型</h3><p>主要有以下4种：</p><p><img src="/2023/01/10/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91&AVL%E6%A0%91&%E7%BA%A2%E9%BB%91%E6%A0%91/LL.png" alt="LL"></p><br><p><img src="/2023/01/10/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91&AVL%E6%A0%91&%E7%BA%A2%E9%BB%91%E6%A0%91/LR.png" alt="LR"></p><br><p><img src="/2023/01/10/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91&AVL%E6%A0%91&%E7%BA%A2%E9%BB%91%E6%A0%91/RL.png" alt="RL"></p><br><p><img src="/2023/01/10/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91&AVL%E6%A0%91&%E7%BA%A2%E9%BB%91%E6%A0%91/RR.png" alt="RR"></p><blockquote><p>在解决平衡性问题之前，还需要引入左旋和右旋的概念。</p></blockquote><h3 id="左旋和右旋"><a href="#左旋和右旋" class="headerlink" title="左旋和右旋"></a>左旋和右旋</h3><p><strong>左旋</strong>：将右子树的根节点替换当前根节点，同时将右子树的左子树与根节点的右子树交换。</p><p>示意图如下：</p><p><img src="/2023/01/10/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91&AVL%E6%A0%91&%E7%BA%A2%E9%BB%91%E6%A0%91/left_rotate.png" alt="left_rotate"></p><br><p><strong>右旋</strong>：将左子树的根节点替换当前根节点，同时将左子树的右子树与根节点的左子树交换。</p><p>示意图如下：</p><p><img src="/2023/01/10/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91&AVL%E6%A0%91&%E7%BA%A2%E9%BB%91%E6%A0%91/right_rotate.png" alt="right"></p><br><h3 id="维持平衡性"><a href="#维持平衡性" class="headerlink" title="维持平衡性"></a>维持平衡性</h3><p>以上四种失衡类型中，共有两组平衡方案：</p><p>一、 LL型 和 RR型</p><p>对于LL型失衡，只需要对失衡结点采用右旋操作即可恢复平衡。</p><p><img src="/2023/01/10/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91&AVL%E6%A0%91&%E7%BA%A2%E9%BB%91%E6%A0%91/LL_right.png" alt="LL_right"></p><p>证明如下：</p><blockquote><p>假设第n个结点的高度为<strong>H(n)</strong>, 则 <strong>H(K2) &#x3D; H(K3) - 2,H(K7) &#x3D; H(K4) ( - 1)</strong> ( <em>这里表示 K7的高度小于1个 K4 的高度或者两者相等</em> ) ; 左旋之后，只有两个结点的高度发生了变化， 即 K1 和 K3，这时<strong>H(K7) &#x3D; H(K4) ( - 1) &#x3D; H(K3) - 1 ( - 1) &#x3D; H(K2) + 1 ( - 1)</strong>(<em>注：这里的K3是未旋转之前的 K3，旋转后的 K3用 K3’ 来表示</em> ), 因此结点K1是平衡的；</p><p>再考察结点K3‘，<strong>H(K1) &#x3D; 1 + H(K7) &#x3D; 1 + H(K4) ( - 1)</strong>,因此结点 K3’ 也是平衡的。</p></blockquote><br><p>对于RR型失衡  ，只需要对失衡结点采用左旋操作即可恢复平衡，在此不再赘述。</p><br><p>二、LR型 和 RL型</p><p>对于LR型失衡，需要先对失衡结点的左子树进行一次左旋，再对失衡结点进行一次右旋。</p><p><img src="/2023/01/10/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91&AVL%E6%A0%91&%E7%BA%A2%E9%BB%91%E6%A0%91/LR_left_right.png" alt="LR"></p><p>证明比较困难，等我读了论文再回来填坑。</p><p>RL型失衡进行反向操作。</p><br><p>相关代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update_height</span><span class="hljs-params">(Node *root)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span>;<br>    root-&gt;height =<br>        ((<span class="hljs-built_in">H</span>(<span class="hljs-built_in">L</span>(root))) &gt; (<span class="hljs-built_in">H</span>(<span class="hljs-built_in">R</span>(root))) ? (<span class="hljs-built_in">H</span>(<span class="hljs-built_in">L</span>(root))) : (<span class="hljs-built_in">H</span>(<span class="hljs-built_in">R</span>(root)))) + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function">Node *<span class="hljs-title">left_rotate</span><span class="hljs-params">(Node *root)</span></span><br><span class="hljs-function"></span>&#123;<br>    Node *temp = <span class="hljs-built_in">R</span>(root);<br>    <span class="hljs-built_in">R</span>(root) = <span class="hljs-built_in">L</span>(temp);<br>    <span class="hljs-built_in">L</span>(temp) = root;<br>    <span class="hljs-built_in">update_height</span>(root);<br>    <span class="hljs-built_in">update_height</span>(temp);<br>    <span class="hljs-keyword">return</span> temp;<br>&#125;<br><br><span class="hljs-function">Node *<span class="hljs-title">right_rotate</span><span class="hljs-params">(Node *root)</span></span><br><span class="hljs-function"></span>&#123;<br>    Node *temp = <span class="hljs-built_in">L</span>(root);<br>    <span class="hljs-built_in">L</span>(root) = <span class="hljs-built_in">R</span>(temp);<br>    <span class="hljs-built_in">R</span>(temp) = root;<br>    <span class="hljs-built_in">update_height</span>(root);<br>    <span class="hljs-built_in">update_height</span>(temp);<br>    <span class="hljs-keyword">return</span> temp;<br>&#125;<br><br><span class="hljs-function">Node *<span class="hljs-title">maintain</span><span class="hljs-params">(Node *root)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(<span class="hljs-built_in">H</span>(<span class="hljs-built_in">L</span>(root)) - <span class="hljs-built_in">H</span>(<span class="hljs-built_in">R</span>(root))) &lt;= <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> root;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">H</span>(<span class="hljs-built_in">L</span>(root)) &gt; <span class="hljs-built_in">H</span>(<span class="hljs-built_in">R</span>(root))) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">H</span>(<span class="hljs-built_in">R</span>(<span class="hljs-built_in">L</span>(root))) &gt; <span class="hljs-built_in">H</span>(<span class="hljs-built_in">L</span>(<span class="hljs-built_in">L</span>(root)))) &#123;<br>            root-&gt;lchild = <span class="hljs-built_in">left_rotate</span>(root-&gt;lchild);<br>        &#125;<br>        root = <span class="hljs-built_in">right_rotate</span>(root);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">H</span>(<span class="hljs-built_in">L</span>(<span class="hljs-built_in">R</span>(root))) &gt; <span class="hljs-built_in">H</span>(<span class="hljs-built_in">R</span>(<span class="hljs-built_in">R</span>(root)))) &#123;<br>            root-&gt;rchild = <span class="hljs-built_in">right_rotate</span>(root-&gt;rchild);<br>        &#125;<br>        root = <span class="hljs-built_in">left_rotate</span>(root);<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><br><span class="hljs-function">Node *<span class="hljs-title">insert</span><span class="hljs-params">(Node *root, ElemType key)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">get_new_node</span>(key);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">cmp_key</span>(key, root-&gt;key) == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> root;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">cmp_key</span>(key, root-&gt;key) &lt; <span class="hljs-number">0</span>)<br>        root-&gt;lchild = <span class="hljs-built_in">insert</span>(root-&gt;lchild, key);<br>    <span class="hljs-keyword">else</span> &#123;<br>        root-&gt;rchild = <span class="hljs-built_in">insert</span>(root-&gt;rchild, key);<br>    &#125;<br>    <span class="hljs-built_in">update_height</span>(root);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">maintain</span>(root);<br>&#125;<br><br><span class="hljs-function">Node *<span class="hljs-title">predecessor</span><span class="hljs-params">(Node *root)</span></span><br><span class="hljs-function"></span>&#123;<br>    Node *temp = root-&gt;lchild;<br>    <span class="hljs-keyword">while</span> (temp-&gt;rchild != <span class="hljs-literal">NULL</span>) &#123;<br>        temp = temp-&gt;rchild;<br>    &#125;<br>    <span class="hljs-keyword">return</span> temp;<br>&#125;<br><br><span class="hljs-function">Node *<span class="hljs-title">erase</span><span class="hljs-params">(Node *root, ElemType key)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">cmp_key</span>(key, root-&gt;key) &lt; <span class="hljs-number">0</span>)<br>        root-&gt;lchild = <span class="hljs-built_in">erase</span>(root-&gt;lchild, key);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">cmp_key</span>(key, root-&gt;key) &gt; <span class="hljs-number">0</span>)<br>        root-&gt;rchild = <span class="hljs-built_in">erase</span>(root-&gt;rchild, key);<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (root-&gt;lchild == <span class="hljs-literal">NULL</span> || root-&gt;rchild == <span class="hljs-literal">NULL</span>) &#123;<br>            Node *temp = root-&gt;lchild ? root-&gt;lchild : root-&gt;rchild;<br>            <span class="hljs-built_in">free</span>(root);<br>            root = temp;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Node *temp = <span class="hljs-built_in">predecessor</span>(root);<br>            root-&gt;key = temp-&gt;key;<br>            root-&gt;lchild = <span class="hljs-built_in">erase</span>(root-&gt;lchild, temp-&gt;key);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">update_height</span>(root);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">maintain</span>(root);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>基本思路：模仿二叉搜索树的插入和删除操作，但是在操作完成后需要根据树高判断是否平衡，如果不平衡则判断类型后通过左右旋调整至平衡状态。</p></blockquote><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p><strong>介绍</strong>：</p><blockquote><p>红黑树(Red-black tree) 是一种自平衡二叉查找树， 它的结构比较复杂， 但它的操作有着良好的最坏情况运行时间， 它可以在O(log n) 时间内完成查找、插入和删除，这里的n的树中元素的数目。</p></blockquote><h3 id="重要性质"><a href="#重要性质" class="headerlink" title="重要性质"></a>重要性质</h3><blockquote><ol><li>结点是黑色或者红色。</li><li>根节点一定是黑色。</li><li>所有叶子结点一定是黑色。（用NIL来表示，就是一般二叉树中的NULL结点，不过具有颜色）</li><li><strong>每个红色结点必须有两个黑色的子节点（从每个叶子到根的所有路径上不可能有两个连续的红色结点）。</strong></li><li><strong>从任一结点到其每个叶子的所有简单路径都包含相同数目的结点。</strong></li></ol></blockquote><br><p>这些约束保证了红黑树的关键特性：从根节点到叶子节点的最长可能路径不会多有最短可能路径的两倍长。(因为在相同黑色结点的情况下，最长的路径是红黑交替的情况)</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><br><p>​在理解红黑树的插入和删除操作之前，需要熟悉AVL树中的左旋和右旋操作，这些依然会再红黑树中使用到；除此之外，红黑树还会涉及结点颜色的变化，但总体而言，红黑树插入和删除的最坏时间复杂度相较AVL树降低了，但最坏查找时间会略有增加。</p><br><h3 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h3><blockquote><p>注意：</p><ul><li>性质1和性质3总是保持着。</li><li>性质4只在增加红色节点、重绘黑色节点为红色，或做旋转时受到威胁。</li><li>性质5只在增加黑色节点、重绘红色节点为黑色，或做旋转时受到威胁。</li></ul><br></blockquote><p>插入操作的所有流程如下图：</p><br><p><img src="/2023/01/10/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91&AVL%E6%A0%91&%E7%BA%A2%E9%BB%91%E6%A0%91/rb_insert_flow.png" alt="insert_flow"></p><br><p><strong>为什么插入结点默认为红色？</strong></p><p>因为如果插入黑色结点，红黑树的平衡一定会被破坏<strong>（主要影响性质5）</strong>，但如果插入红色结点，<strong>性质5</strong>不会受到影响，并且便于调整，因此一般选择将插入结点初始化为红色。</p><br><blockquote><p> 下面将逐个来分析以上的几种情况：</p></blockquote><br><p><strong>父亲结点是黑色</strong></p><p>可以直接插入，因为不会影响到平衡。</p><br><p><strong>父亲结点是红色</strong></p><p>此时插入红色结点将破坏<strong>性质4</strong>，因此需要根据叔叔结点的颜色再做调整，使红黑树重新达到平衡。</p><br><ol><li><p><strong>叔叔结点是红色</strong></p><p>调整方法如下：</p><p><img src="/2023/01/10/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91&AVL%E6%A0%91&%E7%BA%A2%E9%BB%91%E6%A0%91/rb_uncle_red.png" alt="u_r"></p><br><p>直接将父亲(F)结点和叔叔(U)结点的颜色变为黑色，再将祖父结点(G)的颜色变为红色，这样到达1-5叶子结点的路径上黑色结点个数并没有发生变化(主要分析通过上面三角形的三个顶点的路径)。</p><br></li><li><p><strong>叔叔结点是黑色</strong></p><p>根据孩子结点的不同，又要分成4中情况：</p><ul><li><strong>LL型和RR型</strong></li></ul><br><p><img src="/2023/01/10/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91&AVL%E6%A0%91&%E7%BA%A2%E9%BB%91%E6%A0%91/rb_uncle_black1.png" alt="u_b1"></p><br><p>这种情况很可能并不是直接插入进来的，而是经过其他插入调整后形成的形状，但我们依然要把它调整成平衡的。如上图所示，在对祖父结点进行右旋操作以后，将新的根节点变红，新的左右结点变成黑色，(或者反过来)，因为插入操作并没有破坏<strong>性质5</strong>，因此在解决掉<strong>性质4</strong>的冲突以后，红黑树重新达到平衡。RR型变换同理。</p><br><ul><li><strong>LR型和RL型</strong></li></ul><br><p><img src="/2023/01/10/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91&AVL%E6%A0%91&%E7%BA%A2%E9%BB%91%E6%A0%91/rb_uncle_black2.png" alt="r_u_b2"></p><br><p>这种情况需要先将父亲结点左旋，转化成LL型，再对LL型进行相应操作，可以证明调整后<strong>性质5</strong>依然是满足的。RL型变换同理。</p><br></li></ol><blockquote><p>附上一份代码：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Node *<span class="hljs-title">insert_maintain</span><span class="hljs-params">(Node *root)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">has_red</span>(root))<span class="hljs-keyword">return</span> root;<br>    <span class="hljs-type">int</span> flag = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">C</span>(<span class="hljs-built_in">L</span>(root)) == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">has_red</span>(<span class="hljs-built_in">L</span>(root))) flag = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">C</span>(<span class="hljs-built_in">R</span>(root)) == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">has_red</span>(<span class="hljs-built_in">R</span>(root))) flag = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(flag == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> root;<br><br>    <span class="hljs-comment">//uncle is black;</span><br>    <span class="hljs-keyword">if</span>(flag == <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-built_in">C</span>(<span class="hljs-built_in">R</span>(root)) == <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">C</span>(<span class="hljs-built_in">R</span>(<span class="hljs-built_in">L</span>(root))) == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">L</span>(root) = <span class="hljs-built_in">left_rotate</span>(<span class="hljs-built_in">L</span>(root));<br>        &#125;<br>        root = <span class="hljs-built_in">right_rotate</span>(root);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(flag == <span class="hljs-number">2</span> &amp;&amp; <span class="hljs-built_in">C</span>(<span class="hljs-built_in">L</span>(root)) == <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">C</span>(<span class="hljs-built_in">L</span>(<span class="hljs-built_in">R</span>(root))) == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">R</span>(root) = <span class="hljs-built_in">right_rotate</span>(<span class="hljs-built_in">R</span>(root));<br>        &#125;<br>        root = <span class="hljs-built_in">left_rotate</span>(root);<br>    &#125;<br><br>    <span class="hljs-built_in">C</span>(root) = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">C</span>(<span class="hljs-built_in">L</span>(root)) = <span class="hljs-built_in">C</span>(<span class="hljs-built_in">R</span>(root)) = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><br>Node *__insert(Node *root, ElemType key)&#123;<br>    <span class="hljs-keyword">if</span>(root == NIL)<span class="hljs-keyword">return</span> <span class="hljs-built_in">get_new_node</span>(key);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">cmp_key</span>(root-&gt;key, key) == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> root;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">cmp_key</span>(key, root-&gt;key) &lt; <span class="hljs-number">0</span>)&#123;<br>        root-&gt;lchild = __insert(root-&gt;lchild, key);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">cmp_key</span>(key, root-&gt;key) &gt; <span class="hljs-number">0</span>)&#123;<br>        root-&gt;rchild = __insert(root-&gt;rchild, key);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">insert_maintain</span>(root);<br>&#125;<br><br><span class="hljs-function">Node *<span class="hljs-title">insert</span><span class="hljs-params">(Node *root,ElemType key)</span></span>&#123;<br>    root = __insert(root,key);<br>    root-&gt;color = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h3><blockquote><p>删除操作要比插入更加复杂一些，但主要是对删除后形成的双重黑结点处理。</p></blockquote><p>第一步操作与二叉查找树的删除方法是一样的，如果待删除结点有两个度，则寻找它的前驱或者后继结点替换之，再删除替换点；如果只有一个度（只有叶子结点就任取其中一个作为根节点的度），就将该结点的颜色叠加到根节点（红色+黑色&#x3D;黑色， 黑色+黑色&#x3D;双重黑），再做第二步调整。</p><p>先附上流程图：</p><p><img src="/2023/01/10/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91&AVL%E6%A0%91&%E7%BA%A2%E9%BB%91%E6%A0%91/delete_flow1.png" alt="d_f1"></p><p>如果上一步没有产生双重黑结点，则第二步平衡忽略，否则，进入第二步调整，消除双重黑结点。</p><p>流程图如下：</p><p><img src="/2023/01/10/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91&AVL%E6%A0%91&%E7%BA%A2%E9%BB%91%E6%A0%91/delete_flow2.png" alt="d_f2"></p><p>(真的是很复杂了… …)</p><br><blockquote><p> 下面将根据流程图罗列出的各种情况依次讨论：</p></blockquote><p>如果根节点的孩子结点没有双重黑，则不用处理。</p><p>在有<strong>双重黑</strong>的情况下：</p><ol><li><p><strong>兄弟结点为红色</strong></p><p>根据兄弟结点的位置进行相应旋转（在左则右旋，在右则左旋），并且将根节点和兄弟结点颜色互换，这样就转化成了兄弟结点为黑色的情况。</p><p><img src="/2023/01/10/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91&AVL%E6%A0%91&%E7%BA%A2%E9%BB%91%E6%A0%91/brother_red.png" alt="b_r"></p><p>变换以后，到达1~4的路径上的黑色结点个数未改变，可以进行下一步调整。</p><br></li><li><p><strong>兄弟结点为黑色</strong></p><ul><li><p><strong>兄弟结点的孩子都为黑</strong></p><p>将双重黑结点颜色降为黑色，同时其兄弟结点的颜色叠加到根节点。</p><p><img src="/2023/01/10/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91&AVL%E6%A0%91&%E7%BA%A2%E9%BB%91%E6%A0%91/brother_black_2bc.png" alt="brother_black_2bc"></p><p>因为第二层黑色同时降低一层，因此平衡未改变，之后再对根节点降黑。</p><br></li><li><p><strong>兄弟结点有一个孩子颜色为红</strong></p><ul><li><p><strong>LL型和RR型</strong></p><p>这里以RR型为例，直接将根节点左旋，然后新的根节点保持与原来根节点一样的颜色（<strong>绿色表示颜色未知</strong>），新的孩子结点变为黑色。</p><p><img src="/2023/01/10/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91&AVL%E6%A0%91&%E7%BA%A2%E9%BB%91%E6%A0%91/brother_black_1bc_RR.png" alt="brother_black_RR"></p><p>可以证明，到达1-5路径上的黑色结点数目没有变化。LL型同理。</p><br></li><li><p><strong>LR型和RL型</strong></p><p>以RL型为例，将兄弟结点右旋，并且颜色调整成RR型，就可以重复上面的步骤了。</p><p><img src="/2023/01/10/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91&AVL%E6%A0%91&%E7%BA%A2%E9%BB%91%E6%A0%91/bb_RL.png" alt="bb_RL"></p><p>LR型同理。</p></li></ul></li></ul></li></ol><br><p>至此，红黑树的全部操作就完成了，最后附上删除操作的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Node *<span class="hljs-title">predecessor</span><span class="hljs-params">(Node *root)</span> </span>&#123;<br>    Node *temp = root-&gt;lchild;<br>    <span class="hljs-keyword">while</span> (temp-&gt;rchild != NIL) temp = temp-&gt;rchild;<br>    <span class="hljs-keyword">return</span> temp;<br>&#125;<br><br><span class="hljs-function">Node *<span class="hljs-title">erase_maintain</span><span class="hljs-params">(Node *root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">C</span>(<span class="hljs-built_in">L</span>(root)) != <span class="hljs-number">2</span> &amp;&amp; <span class="hljs-built_in">C</span>(<span class="hljs-built_in">R</span>(root)) != <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> root;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">hasRed</span>(root)) &#123;<br>        <span class="hljs-type">int</span> flag = <span class="hljs-number">0</span>;<br>        root-&gt;color = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">C</span>(<span class="hljs-built_in">L</span>(root)) == <span class="hljs-number">0</span>) root = <span class="hljs-built_in">right_rotate</span>(root), flag = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">C</span>(<span class="hljs-built_in">R</span>(root)) == <span class="hljs-number">0</span>) root = <span class="hljs-built_in">left_rotate</span>(root), flag = <span class="hljs-number">2</span>;<br>        root-&gt;color = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">1</span>) root-&gt;rchild = <span class="hljs-built_in">erase_maintain</span>(root-&gt;rchild);<br>        <span class="hljs-keyword">else</span> root-&gt;lchild = <span class="hljs-built_in">erase_maintain</span>(root-&gt;lchild);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">C</span>(<span class="hljs-built_in">L</span>(root)) == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">C</span>(<span class="hljs-built_in">R</span>(root)) = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">hasRed</span>(<span class="hljs-built_in">L</span>(root))) &#123;<br>            <span class="hljs-built_in">C</span>(root) += <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">C</span>(<span class="hljs-built_in">L</span>(root)) -= <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">C</span>(<span class="hljs-built_in">L</span>(<span class="hljs-built_in">L</span>(root))) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">C</span>(<span class="hljs-built_in">L</span>(root)) = <span class="hljs-number">0</span>;<br>            root-&gt;lchild = <span class="hljs-built_in">left_rotate</span>(root-&gt;lchild);<br>            <span class="hljs-built_in">C</span>(<span class="hljs-built_in">L</span>(root)) = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-built_in">C</span>(<span class="hljs-built_in">L</span>(root)) = <span class="hljs-built_in">C</span>(root);<br>        root = <span class="hljs-built_in">right_rotate</span>(root);<br>        <span class="hljs-built_in">C</span>(<span class="hljs-built_in">L</span>(root)) = <span class="hljs-built_in">C</span>(<span class="hljs-built_in">R</span>(root)) = <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">C</span>(<span class="hljs-built_in">L</span>(root)) = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">hasRed</span>(<span class="hljs-built_in">R</span>(root))) &#123;<br>            <span class="hljs-built_in">C</span>(root) += <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">C</span>(<span class="hljs-built_in">R</span>(root)) -= <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">C</span>(<span class="hljs-built_in">R</span>(<span class="hljs-built_in">R</span>(root))) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">C</span>(<span class="hljs-built_in">R</span>(root)) = <span class="hljs-number">0</span>;<br>            root-&gt;rchild = <span class="hljs-built_in">right_rotate</span>(root-&gt;rchild);<br>            <span class="hljs-built_in">C</span>(<span class="hljs-built_in">R</span>(root)) = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-built_in">C</span>(<span class="hljs-built_in">R</span>(root)) = <span class="hljs-built_in">C</span>(root);<br>        root = <span class="hljs-built_in">left_rotate</span>(root);<br>        <span class="hljs-built_in">C</span>(<span class="hljs-built_in">L</span>(root)) = <span class="hljs-built_in">C</span>(<span class="hljs-built_in">R</span>(root)) = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><br>Node *__erase(Node *root, <span class="hljs-type">int</span> key) &#123;<br>    <span class="hljs-keyword">if</span> (root == NIL) <span class="hljs-keyword">return</span> root;<br>    <span class="hljs-keyword">if</span> (key &lt; root-&gt;key) &#123;<br>        root-&gt;lchild = __erase(root-&gt;lchild, key);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &gt; root-&gt;key) &#123;<br>        root-&gt;rchild = __erase(root-&gt;rchild, key);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (root-&gt;lchild == NIL || root-&gt;rchild == NIL) &#123;<br>            Node *temp = root-&gt;lchild == NIL ? root-&gt;rchild : root-&gt;lchild;<br>            temp-&gt;color += root-&gt;color;<br>            <span class="hljs-built_in">free</span>(root);<br>            <span class="hljs-keyword">return</span> temp;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Node *temp = <span class="hljs-built_in">predecessor</span>(root);<br>            root-&gt;key = temp-&gt;key;<br>            root-&gt;lchild = __erase(root-&gt;lchild, temp-&gt;key);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">erase_maintain</span>(root);<br>&#125;<br><br><span class="hljs-function">Node *<span class="hljs-title">erase</span><span class="hljs-params">(Node *root, <span class="hljs-type">int</span> key)</span> </span>&#123;<br>    root = __erase(root, key);<br>    root-&gt;color = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉搜索树</tag>
      
      <tag>AVL树</tag>
      
      <tag>红黑树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树的路径和</title>
    <link href="/2023/01/10/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <url>/2023/01/10/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉树的路径和"><a href="#二叉树的路径和" class="headerlink" title="二叉树的路径和"></a>二叉树的路径和</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定一个二叉树和一个整数sum，求二叉树中的一条连续的路径，使该路径上结点的和等于sum。</p><p><img src="/2023/01/10/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%B7%AF%E5%BE%84%E5%92%8C/image-20201127131154062.png" alt="image-20201127131154062"></p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>这题和前面的一个题“和等于K的子数组”非常相似，因为他们都是采用<strong>哈希表</strong>来存储数据，然后通过间接的方法求得一段连续的值的和。</p><p>思路如下：</p><p>因为所求的结果是一段连续的路径，因此可以通过<strong>求差值的方法</strong>来判断该路径是否符合要求。因此，在先序遍历二叉树的时候，记录下每个路径的和出现的次数，这样，当我们处于某条路径时，如果该路径的和减去sum的值再哈希表中，说明我们曾经走过一条路径，该路径的和等于上述差值，而当前路径和该路径之间的路径就是一个解，通过这种方法就能在线性时间内找到所要求的答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> sum)</span> &#123;<br>    HashMap&lt;Integer, Integer&gt; preSum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>    preSum.put(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> helper(root, <span class="hljs-number">0</span>, sum, preSum);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> currSum, <span class="hljs-type">int</span> target, HashMap&lt;Integer, Integer&gt; preSum)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    currSum += root.val;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> preSum.getOrDefault(currSum - target, <span class="hljs-number">0</span>);<br>    preSum.put(currSum, preSum.getOrDefault(currSum, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>    <br>    res += helper(root.left, currSum, target, preSum) + helper(root.right, currSum, target, preSum);<br>    preSum.put(currSum, preSum.get(currSum) - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>哈希表的功能和数组很相似，能够很快地查找到一些我们曾经求得的有用的值，这样，如果答案能够通过当前的值和旧值间接求出，那么哈希表能够发挥很大的作用。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二叉树</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>队列和广度优先搜索</title>
    <link href="/2023/01/10/%E9%98%9F%E5%88%97&amp;%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    <url>/2023/01/10/%E9%98%9F%E5%88%97&amp;%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="队列和广度优先搜索"><a href="#队列和广度优先搜索" class="headerlink" title="队列和广度优先搜索"></a>队列和广度优先搜索</h1><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列是一种特殊的线性表，因为它只能从一端插入，一端删除，即先进先出的效果，类似于现实中的排队。</p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><blockquote><ol><li>先进先出</li><li>一般从队头入队，队尾出队</li><li>空队列：front &#x3D; rear</li></ol></blockquote><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>由于队列中的元素只能从队头出，队尾进，因此如果不是特殊情况，采用顺序数组队列会浪费很多空间，并且它的使用也是有限制的（出队以后，队头之前的位置无法再被利用，而如果一直进队的话，数组总会被很快消耗完），因此可以考虑采用循环数组，将出队后的位置重新利用起来。</p><p>一般而言，循环队列的基本操作和特点如下：</p><blockquote><ol><li>队满：front &#x3D; (rear + 1) % MAX_SIZE</li><li>队空：front &#x3D; rear</li><li>插入元素：rear &#x3D; (rear + 1) % MAX_SIZE</li><li>删除元素：front &#x3D; (front + 1) % MAX_SIZE</li></ol></blockquote><p>其中MAX_SIZE是存放该队列的数组长度</p><p><img src="/2023/01/10/%E9%98%9F%E5%88%97&%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/circle_qu_full.png" alt="img"></p><center>队列为满时的情况</center><br><p>整体代码不算很难，但是要注意每次改变front 和 rear 的值时， 必须整除MAX_SIZE，以保证不会出现指针越界的情况。</p><p>代码如下（看看就好，跑不起来的）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//circle_queue.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> F(qu) (qu-&gt;front)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> R(qu) (qu-&gt;rear)</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ElemType;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_SIZE 10   <span class="hljs-comment">//定义最大队列长度</span></span><br><br><span class="hljs-comment">/** </span><br><span class="hljs-comment">* 此队列中，头结点默认指向队列头部的元素，尾指针指向队列尾部元素的下一个空格</span><br><span class="hljs-comment">* 任何指针移动时，都必须要整除队列长度以保证不会越界</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">c_queue</span><br>&#123;<br>    <span class="hljs-comment">/* data */</span><br>    ElemType data[MAX_SIZE];<br>    <span class="hljs-type">int</span> front;<br>    <span class="hljs-type">int</span> rear;<br>&#125;C_Queue;<br><br><span class="hljs-function">C_Queue *<span class="hljs-title">init_circle_queue</span><span class="hljs-params">(C_Queue *qu)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">push</span><span class="hljs-params">(C_Queue *qu,ElemType *x)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">(C_Queue *qu)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_front</span><span class="hljs-params">(C_Queue *qu,ElemType *x)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">isfull</span><span class="hljs-params">(C_Queue *qu)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">isempty</span><span class="hljs-params">(C_Queue *qu)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">destory_circle_queue</span><span class="hljs-params">(C_Queue *qu)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">(C_Queue *qu)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//circle_queue.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;c_queue.h&quot;</span></span><br><br><span class="hljs-function">C_Queue *<span class="hljs-title">init_circle_queue</span><span class="hljs-params">(C_Queue *qu)</span></span>&#123;<br>    qu = (C_Queue*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(C_Queue));<br>    qu-&gt;front = qu-&gt;rear = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> qu;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">isfull</span><span class="hljs-params">(C_Queue *qu)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> qu-&gt;front == (qu-&gt;rear + <span class="hljs-number">1</span>) % MAX_SIZE;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">isempty</span><span class="hljs-params">(C_Queue *qu)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> qu-&gt;front == qu-&gt;rear;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">push</span><span class="hljs-params">(C_Queue *qu,ElemType *x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isfull</span>(qu))&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;The queue is full!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    qu-&gt;data[qu-&gt;rear] = (*x);<br>    qu-&gt;rear = (qu-&gt;rear + <span class="hljs-number">1</span>) % MAX_SIZE;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">(C_Queue *qu)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isempty</span>(qu))&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;The queue is empty!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    qu-&gt;front = (qu-&gt;front + <span class="hljs-number">1</span>) % MAX_SIZE;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_front</span><span class="hljs-params">(C_Queue *qu,ElemType *x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isempty</span>(qu))&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;The queue is empty!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    (*x) = qu-&gt;data[qu-&gt;front, MAX_SIZE];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">destory_circle_queue</span><span class="hljs-params">(C_Queue *qu)</span></span>&#123;<br>    <span class="hljs-built_in">free</span>(qu);<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">(C_Queue *qu)</span></span>&#123;<br>    <span class="hljs-type">int</span> i = qu-&gt;front;<br>    <span class="hljs-keyword">while</span>(i != qu-&gt;rear)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, qu-&gt;data[i]);<br>        i = (i + <span class="hljs-number">1</span>) % MAX_SIZE;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h3><p>链式队列的数据结构十分类似于链表，因此将链表加上头、尾指针后，就变成了链式队列。</p><p><strong>基本操作</strong></p><ol><li><p><strong>结点结构</strong></p><p>结点中包含需要存储的数据和下一个结点的指针就行。也可以将头尾结点指针包装起来。</p></li><li><p><strong>插入</strong></p><p>先分析一般情况：当尾指针不为空时，直接将新结点插入到尾指针后面，再将尾指针指向这个新结点就好。</p><p>当尾指针为空：此时队列中无元素，将头尾指针指向这个新结点就好。</p></li><li><p><strong>删除</strong></p><p>也是先要分情况：当队列为空时，报错</p><p>队列较长：先把头指针保留下来，将头指针后移，再释放原先的头指针。</p><p>但是当队列只有一个元素时，最好还要保证尾指针不会变成野指针，因此做特殊情况处理，释放后将头尾指针指向空。</p></li><li><p><strong>销毁队列</strong></p><p>先判断队列是否为空，若不为空则从头结点开始依次释放（可以调用删除函数，也可以循环）。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//l_queue.h</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ElemType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    ElemType data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> *next;<br>&#125;QNode;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">queue</span>&#123;<br>    QNode *front;<br>    QNode *rear;<br>&#125;Queue;<br><br><span class="hljs-function">Queue *<span class="hljs-title">init</span><span class="hljs-params">(Queue *qu)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">isempty</span><span class="hljs-params">(Queue *qu)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">push</span><span class="hljs-params">(Queue *qu, ElemType *x)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">(Queue *qu)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_front</span><span class="hljs-params">(Queue *qu, ElemType *x)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">destory_queue</span><span class="hljs-params">(Queue *qu)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">disp_queue</span><span class="hljs-params">(Queue *qu)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//l_queue.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;l_queue.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> D(qu) (qu-&gt;data)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> F(qu) (qu-&gt;front)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> R(qu) (qu-&gt;rear)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N(qu) (qu-&gt;next)</span><br><br><span class="hljs-function">Queue *<span class="hljs-title">init</span><span class="hljs-params">(Queue *qu)</span></span>&#123;<br>    qu = (Queue*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Queue));<br>    qu-&gt;front = qu-&gt;rear = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> qu;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">isempty</span><span class="hljs-params">(Queue *qu)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> qu-&gt;front == <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">push</span><span class="hljs-params">(Queue *qu, ElemType *x)</span></span>&#123;<br>    QNode *s = (QNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(QNode));<br>    s-&gt;next = <span class="hljs-literal">NULL</span>;<br>    s-&gt;data = (*x);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">R</span>(qu) == <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">F</span>(qu) = <span class="hljs-built_in">R</span>(qu) = s;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    qu-&gt;rear-&gt;next = s;<br>    qu-&gt;rear = s;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">(Queue *qu)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isempty</span>(qu))&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The queue is empty!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    QNode *tmp = <span class="hljs-built_in">F</span>(qu);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">F</span>(qu) == <span class="hljs-built_in">R</span>(qu))&#123;<br>        <span class="hljs-built_in">free</span>(<span class="hljs-built_in">F</span>(qu));<br>        <span class="hljs-built_in">F</span>(qu) = <span class="hljs-built_in">R</span>(qu) = <span class="hljs-literal">NULL</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">F</span>(qu) = <span class="hljs-built_in">N</span>(<span class="hljs-built_in">F</span>(qu));<br>        <span class="hljs-built_in">free</span>(tmp);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_front</span><span class="hljs-params">(Queue *qu, ElemType *x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isempty</span>(qu))&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The queue is empty!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;  <br>    (*x) = <span class="hljs-built_in">D</span>(<span class="hljs-built_in">F</span>(qu));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">destory_queue</span><span class="hljs-params">(Queue *qu)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">F</span>(qu) != <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">pop</span>(qu);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">disp_queue</span><span class="hljs-params">(Queue *qu)</span></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;queue:\n&quot;</span>);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">F</span>(qu) == <span class="hljs-literal">NULL</span>)<span class="hljs-keyword">return</span> ;<br>    QNode *p = <span class="hljs-built_in">F</span>(qu);<br>    <span class="hljs-keyword">while</span>(p != <span class="hljs-built_in">R</span>(qu))&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, <span class="hljs-built_in">D</span>(p));<br>        p = <span class="hljs-built_in">N</span>(p);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">D</span>(p));<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="广度优先搜索（BFS）"><a href="#广度优先搜索（BFS）" class="headerlink" title="广度优先搜索（BFS）"></a>广度优先搜索（BFS）</h2><p><strong>概念</strong>：广度优先搜索类似于一种横向式的搜索，对于它遇到的每一个合适的结点，都将放入考虑范围内，并且根据顺序依次访问，所以广度优先搜索常用于<strong>寻找最短路径</strong>。</p><h3 id="图结构中的BFS遍历"><a href="#图结构中的BFS遍历" class="headerlink" title="图结构中的BFS遍历"></a>图结构中的BFS遍历</h3><p>大致过程如下：首先访问初始点v，接着访问顶点v的所有未被访问过的邻接点v1，v2… 然后按照次序访问每一个未被访问过的顶点，直到找到所需要的顶点。由于始终优先访问最先被接触到的结点，因此适合用队列来实现。</p><p>通过下面的示意图能够很清晰的明白过程了。</p><p><img src="/2023/01/10/%E9%98%9F%E5%88%97&%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/bfs_graph.png" alt="bfs_gra"></p><br><p>大致的代码思路如下（该代码需要图的基本算法）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//graph_basic.h</span><br><br><span class="hljs-comment">/** </span><br><span class="hljs-comment">* 以邻接表的方式构建图</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ElemType;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_SIZE 100</span><br><br><span class="hljs-comment">//声明边结点</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">anode</span>&#123;<br>    <span class="hljs-comment">//ElemType data;</span><br>    <span class="hljs-type">int</span> vertex;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">anode</span> *next;  <span class="hljs-comment">//指向下一个边结点</span><br>    <span class="hljs-type">int</span> weight;<br>&#125;ANode;<br><br><span class="hljs-comment">//声明头结点</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">vnode</span>&#123;<br>    ANode *firstarc;   <span class="hljs-comment">//指向第一个边结点</span><br>    <span class="hljs-type">int</span> isnode;<br>&#125;VNode;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">graph</span>&#123;<br>    VNode adj_list[MAX_SIZE];   <span class="hljs-comment">//邻接表</span><br>    <span class="hljs-type">int</span> edges;<br>    <span class="hljs-type">int</span> vertices;<br>&#125;AdjGraph;<br><br><span class="hljs-function">AdjGraph *<span class="hljs-title">init_with_file</span><span class="hljs-params">(AdjGraph *G, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* filename)</span></span>; <span class="hljs-comment">//使用文件来初始化图</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(AdjGraph *G, <span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v, <span class="hljs-type">int</span> w)</span></span>;  <span class="hljs-comment">//插入结点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">destory_graph</span><span class="hljs-params">(AdjGraph *G)</span></span>;  <span class="hljs-comment">//销毁表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">disp_adjlist</span><span class="hljs-params">(AdjGraph *G)</span></span>;  <span class="hljs-comment">//显示邻接表</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//BFS.c</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;graph_basic.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;l_queue.h&quot;</span></span><br><br><span class="hljs-comment">//通过bfs寻找结点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(AdjGraph *G, <span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span></span>&#123;<br>    <span class="hljs-comment">//初始化容器</span><br>    Queue *qu = <span class="hljs-built_in">init</span>(qu);<br>    <span class="hljs-type">int</span> visited[MAX_SIZE] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <br>    <span class="hljs-comment">//添加首个结点到队列中</span><br>    <span class="hljs-built_in">push</span>(qu, &amp;u);<br>    visited[u] = <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-comment">//处理队列中的每一个结点</span><br>    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isempty</span>(qu))&#123;<br>        <span class="hljs-type">int</span> tmp;<br>        <span class="hljs-built_in">get_front</span>(qu, &amp;tmp);   <span class="hljs-comment">//取出队列头部结点</span><br>        <br>        <span class="hljs-comment">//找到答案，返回</span><br>        <span class="hljs-keyword">if</span>(tmp == v)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;find!\n&quot;</span>);<br>            <span class="hljs-built_in">destory_queue</span>(qu);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">//在邻接表中寻找合适的结点</span><br>        ANode *p = G-&gt;adj_list[tmp].firstarc;<br>        <span class="hljs-keyword">while</span>(p != <span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-type">int</span> goal = p-&gt;vertex;<br>            <span class="hljs-keyword">if</span>(visited[goal] == <span class="hljs-number">0</span>)&#123;<br>                visited[goal] = <span class="hljs-number">1</span>;<br>                <span class="hljs-built_in">push</span>(qu, &amp;goal);<br>            &#125;<br>            p = p-&gt;next;<br>        &#125;<br>        <span class="hljs-built_in">undel_pop</span>(qu);   <span class="hljs-comment">//当前结点处理完毕，从队列中弹出当前结点</span><br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;not find!\n&quot;</span>);<br>    <span class="hljs-built_in">destory_queue</span>(qu);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">//寻找最短路径</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">find_shortest_path</span><span class="hljs-params">(AdjGraph *G, <span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span></span>&#123;<br>    <span class="hljs-comment">//init</span><br>    Queue *qu = <span class="hljs-built_in">init</span>(qu);<br>    <span class="hljs-type">int</span> visited[MAX_SIZE] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <br>    <span class="hljs-comment">//处理首个结点</span><br>    <span class="hljs-built_in">push</span>(qu, &amp;u);<br>    visited[u] = <span class="hljs-number">1</span>;<br>    qu-&gt;front-&gt;parent = <span class="hljs-literal">NULL</span>;<br>    <br>    <span class="hljs-comment">//处理队列中的结点</span><br>    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isempty</span>(qu))&#123;<br>        <span class="hljs-type">int</span> tmp;<br>        <span class="hljs-built_in">get_front</span>(qu, &amp;tmp);  <span class="hljs-comment">//取出头结点</span><br>        <br>        <span class="hljs-comment">//找到目标则输出答案</span><br>        <span class="hljs-keyword">if</span>(tmp == v)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;find! Road:\n&quot;</span>);<br>            QNode *t = qu-&gt;front;<br>            <span class="hljs-keyword">while</span>(t-&gt;parent != <span class="hljs-literal">NULL</span>)&#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&lt;-&quot;</span>,t-&gt;data);<br>                t = t-&gt;parent;<br>            &#125;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,t-&gt;data);<br>            <span class="hljs-built_in">destory_queue</span>(qu);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">//在邻接表中寻找合适的结点</span><br>        ANode *p = G-&gt;adj_list[tmp].firstarc;<br>        <span class="hljs-keyword">while</span>(p != <span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-type">int</span> goal = p-&gt;vertex;<br>            <span class="hljs-keyword">if</span>(visited[goal] == <span class="hljs-number">0</span>)&#123;<br>                visited[goal] = <span class="hljs-number">1</span>;<br>                <span class="hljs-built_in">push</span>(qu, &amp;goal);<br>                qu-&gt;rear-&gt;parent = qu-&gt;front;<br>            &#125;<br>            p = p-&gt;next;<br>        &#125;<br>        <br>        <span class="hljs-built_in">undel_pop</span>(qu);  <span class="hljs-comment">//非删除式弹出结点，目的在于保留路径</span><br>    &#125;<br>    <br>    <span class="hljs-comment">//所有结点都遍历过了仍然没有找到</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;not find!\n&quot;</span>);<br>    <span class="hljs-built_in">destory_queue</span>(qu);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="广义BFS"><a href="#广义BFS" class="headerlink" title="广义BFS"></a>广义BFS</h3><p>从广义上来说，BFS也是一种很常见的搜索方式，即处理完手里的所有情况之后，再去处理产生的新情况，下面是BFS寻找最小数值的伪代码。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function">BFS <span class="hljs-title">function</span><span class="hljs-params">(params: root, target)</span></span><br><span class="hljs-function">init hash_table visited</span><br><span class="hljs-function">init a queue <span class="hljs-comment">//storing the type of root</span></span><br><span class="hljs-function">init step </span>= <span class="hljs-number">0</span> <span class="hljs-comment">//record minimum value from root to target</span><br>add root to queue, visited<br><span class="hljs-comment">//BFS</span><br><span class="hljs-keyword">while</span> queue <span class="hljs-keyword">not</span> empty:<br>step++ <span class="hljs-comment">//having walked one step</span><br>init size = queue.size <span class="hljs-comment">//the number of elements prepare to iterate next</span><br>loop size times:<br>init current node = queue.front<br><span class="hljs-keyword">if</span> cur == target:<br><span class="hljs-keyword">return</span> step<br><span class="hljs-keyword">else</span>:<br><span class="hljs-keyword">for</span> every suitable neighbors in cur: <span class="hljs-comment">//most times mean not visited,not overedges and so on</span><br>add each to queue, visited<br>remove cur from queue<br><span class="hljs-comment">//not found</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BFS</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆排序&amp;优先队列</title>
    <link href="/2023/01/10/%E5%A0%86%E6%8E%92%E5%BA%8F&amp;%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    <url>/2023/01/10/%E5%A0%86%E6%8E%92%E5%BA%8F&amp;%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="堆排序-amp-优先队列"><a href="#堆排序-amp-优先队列" class="headerlink" title="堆排序&amp;优先队列"></a>堆排序&amp;优先队列</h1><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="堆排序原理"><a href="#堆排序原理" class="headerlink" title="堆排序原理"></a>堆排序原理</h3><blockquote><p><strong>堆是一颗具有特定性质的二叉树。</strong><br><strong>堆的性质</strong>：</p><ol><li>堆中所有结点的值必须大于或者等于(或小于等于)其孩子结点的值；</li><li>堆是一颗完全二叉树。</li></ol><p><strong>二叉堆</strong>：<br>在二叉堆中，每个结点最多有两个孩子结点，二叉堆一般分为 <em>二叉最小堆</em>  和 <em>二叉最大堆</em><br><br></p></blockquote><h3 id="堆排序函数"><a href="#堆排序函数" class="headerlink" title="堆排序函数"></a>堆排序函数</h3><p>下面以最小堆为例列举实现二叉堆需要的函数</p><h4 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//头文件</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXN 1001</span><br><br><span class="hljs-comment">//自定义元素类型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ElemType;<br><br><span class="hljs-comment">//最小堆的顺序表</span><br><span class="hljs-type">int</span> SizeOfHeap = <span class="hljs-number">0</span>;<br>ElemType Heap[MAXN];<br><br></code></pre></td></tr></table></figure><h4 id="插入堆函数"><a href="#插入堆函数" class="headerlink" title="插入堆函数"></a>插入堆函数</h4><p>先将插入的结点放在二叉树的末尾，然后根据优先级与其双亲结点进行比较，如果优先级高于双亲结点则将他们交换，直到重新形成二叉堆。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(ElemType x)</span></span>&#123;<br>    <span class="hljs-comment">//首先插入到最后一个位置</span><br>    <span class="hljs-type">int</span> index = ++SizeOfHeap;<br>    <span class="hljs-comment">//向上调整</span><br>    <span class="hljs-keyword">while</span>(index &gt; <span class="hljs-number">1</span>)&#123;  <span class="hljs-comment">//只有i&gt;1时才有父节点</span><br>        <span class="hljs-type">int</span> IndexOfParent = index / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(Heap[IndexOfParent] &lt;= x)&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        Heap[index] = Heap[IndexOfParent];<br>        index = IndexOfParent;<br>    &#125;<br>    Heap[index] = x;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>图解</strong></p><p><img src="/2023/01/10/%E5%A0%86%E6%8E%92%E5%BA%8F&%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/heap_insert1.png" alt="insert"></p><center><font size="4">初始堆</font></center><p><img src="/2023/01/10/%E5%A0%86%E6%8E%92%E5%BA%8F&%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/heap_insert2.png" alt="insert1"></p><center><font size="4">插入新结点并向上调整</font></center><p><img src="/2023/01/10/%E5%A0%86%E6%8E%92%E5%BA%8F&%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/heap_insert3.png" alt="insert2"></p><center><font size="4">继续向上调整</font></center><p><img src="/2023/01/10/%E5%A0%86%E6%8E%92%E5%BA%8F&%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/heap_insert4.png" alt="insert3"></p><center><font size="4">插入完成</font></center><h4 id="删除最值函数"><a href="#删除最值函数" class="headerlink" title="删除最值函数"></a>删除最值函数</h4><p>先临时保存一份最值，然后将最后一个结点放到根节点，依次向下移动结点直到二叉堆平衡。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//删除操作</span><br><span class="hljs-function">ElemType <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//获取最值</span><br>    ElemType result = Heap[<span class="hljs-number">1</span>];<br>    <span class="hljs-comment">//相当于将最后一个结点放到根节点</span><br>    ElemType x = Heap[SizeOfHeap];<br>    <span class="hljs-type">int</span> index = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//一定要有子节点</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">2</span> * index &lt;= SizeOfHeap)&#123;<br>        <span class="hljs-type">int</span> LSonIndex = <span class="hljs-number">2</span> * index;<br>        <span class="hljs-type">int</span> RSonIndex = <span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//比较儿子结点的最值</span><br>        <span class="hljs-type">int</span> MinIndex = LSonIndex;<br>        <span class="hljs-keyword">if</span>(RSonIndex &lt;= SizeOfHeap &amp;&amp; Heap[RSonIndex] &lt; Heap[MinIndex])&#123;<br>            MinIndex = RSonIndex;<br>        &#125;<br>        <span class="hljs-comment">//如果没有颠倒就结束</span><br>        <span class="hljs-keyword">if</span>(Heap[MinIndex] &gt;= x)&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        Heap[index] = Heap[MinIndex];<br>        index = MinIndex;<br>    &#125;<br>    Heap[index] = x;<br>    SizeOfHeap--;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>图解</strong></p><p><img src="/2023/01/10/%E5%A0%86%E6%8E%92%E5%BA%8F&%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/heap_pop1.png"></p><center>初始堆</center><br><br><p><img src="/2023/01/10/%E5%A0%86%E6%8E%92%E5%BA%8F&%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/heap_pop2.png" alt="pop"></p><center>将尾结点移动到根节点</center><br><br><p><img src="/2023/01/10/%E5%A0%86%E6%8E%92%E5%BA%8F&%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/heap_pop3.png" alt="pop"></p><center>平衡二叉堆</center><br><br><h4 id="获取堆顶元素"><a href="#获取堆顶元素" class="headerlink" title="获取堆顶元素"></a>获取堆顶元素</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//获取堆顶元素</span><br><span class="hljs-function">ElemType <span class="hljs-title">GetTop</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> Heap[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure><br><br><h4 id="创建空堆"><a href="#创建空堆" class="headerlink" title="创建空堆"></a>创建空堆</h4><p>使用一个数组来创建空堆</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Build_Heap</span><span class="hljs-params">(<span class="hljs-type">int</span> data[],<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-comment">//创建一个空堆</span><br>    SizeOfHeap = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)&#123;<br>        <span class="hljs-built_in">push</span>(data[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><blockquote><p>优先队列也是一种队列，不过优先队列的出队顺序是按照优先级来的</p><p>如果最小的键值元素拥有最高的优先级，那么这种优先队列叫做<em>升序优先队列</em>, 相反，如果最大键值元素具有最高的优先级，这种优先队列叫做<em>降序优先队列</em>。</p><p>优先队列的基本操作类似于二叉堆的基本操作。</p></blockquote><h3 id="优先队列的应用"><a href="#优先队列的应用" class="headerlink" title="优先队列的应用"></a>优先队列的应用</h3><ul><li>数据压缩：Huffman 算法</li><li>最短路径：Dijkstra算法</li><li>最小生成树：Prim算法</li><li>事件驱动仿真：顾客排队算法</li><li>选择问题：查找第k个最小元素</li><li>… …</li></ul><h3 id="优先队列的实现比较"><a href="#优先队列的实现比较" class="headerlink" title="优先队列的实现比较"></a>优先队列的实现比较</h3><table><thead><tr><th>实现</th><th>插入</th><th>删除</th><th>寻找最小值</th></tr></thead><tbody><tr><td>无序数组</td><td>1</td><td>n</td><td>n</td></tr><tr><td>无序链表</td><td>1</td><td>n</td><td>n</td></tr><tr><td>有序数组</td><td>n</td><td>1</td><td>1</td></tr><tr><td>有序链表</td><td>n</td><td>1</td><td>1</td></tr><tr><td>二叉搜索树</td><td>log n（平均）</td><td>log n（平均）</td><td>log n（平均）</td></tr><tr><td>平衡二叉搜索树</td><td>log n</td><td>log n</td><td>log n</td></tr><tr><td>二叉堆</td><td>log n</td><td>log n</td><td>1</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>优先队列</tag>
      
      <tag>堆排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>递增矩阵搜索</title>
    <link href="/2023/01/10/%E9%80%92%E5%A2%9E%E7%9F%A9%E9%98%B5%E6%90%9C%E7%B4%A2/"/>
    <url>/2023/01/10/%E9%80%92%E5%A2%9E%E7%9F%A9%E9%98%B5%E6%90%9C%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="递增矩阵搜索"><a href="#递增矩阵搜索" class="headerlink" title="递增矩阵搜索"></a>递增矩阵搜索</h1><p class="note note-primary">动态规划</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>写一个高效地算法来查找递增矩阵中的一个值。</p><p>这个矩阵有以下特性：</p><ul><li>从左到右数值是递增的</li><li>从上到下数值也是递增的</li></ul></blockquote><p>例如：</p><table><thead><tr><th>1</th><th>2</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>3</td><td>6</td><td>7</td><td>8</td></tr><tr><td>9</td><td>10</td><td>13</td><td>14</td></tr><tr><td>11</td><td>12</td><td>15</td><td>16</td></tr></tbody></table><p>当待查找数值为11时，函数返回true</p><p>当待查找数值为17时，函数返回false</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>由于右上角的元素有很好的性质，其左边的元素都小于它，其下面的元素都大于它，因此可以利用不等式的传递性来快速排除某一行或列的元素，直到遇到目标值或者走到边界，这个过程是根据当前坐标与目标值的大小关系一步步推进的。</p><p>左下角的元素作为初始坐标同理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix, <span class="hljs-type">int</span> target)</span></span>&#123;<br>    <span class="hljs-comment">//m,n为矩阵的行和列</span><br>    <span class="hljs-type">int</span> m = matrix.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span>(m == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">int</span> n = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br><br>    <span class="hljs-comment">//初始坐标为最右上角的元素</span><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = n - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i &lt; m &amp;&amp; j &gt;= <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">if</span>(matrix[i][j] == target)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(matrix[i][j] &gt; target)&#123;<br>            j--;                         <span class="hljs-comment">//坐标向左移动，因为右边元素全大于target</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            i++;                         <span class="hljs-comment">//坐标向下移动，因为上面元素全小于target</span><br>        &#125;<br>        <span class="hljs-comment">//走到边界意味着没有符合条件的点</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>层次结构存储系统</title>
    <link href="/2023/01/10/%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/01/10/%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="层次结构存储系统"><a href="#层次结构存储系统" class="headerlink" title="层次结构存储系统"></a>层次结构存储系统</h1><h2 id="按存取方式分类"><a href="#按存取方式分类" class="headerlink" title="按存取方式分类"></a>按存取方式分类</h2><p>RAM（随机存取存储器）</p><p>SAM（顺序存取存储器），如磁带</p><p>DAM（直接存取存储器），如磁盘</p><p>CAM（相联存储器）：按照内容访问，如快表</p><h2 id="主存储器结构"><a href="#主存储器结构" class="headerlink" title="主存储器结构"></a>主存储器结构</h2><p><img src="/2023/01/10/%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/image-20211215195402961.png" alt="image-20211215195402961"></p><h3 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a>层次结构</h3><p><img src="/2023/01/10/%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/image-20211215195436418.png" alt="image-20211215195436418"></p><h3 id="SDRAM芯片技术"><a href="#SDRAM芯片技术" class="headerlink" title="SDRAM芯片技术"></a>SDRAM芯片技术</h3><p>该芯片读写受到外部系统时钟（即前端总线时钟CLK）控制，因此与CPU之间采用同步方式交换数据。他将CPU或者其他主设备发出的地址和控制信息锁存起来，经过确定的几个时钟周期后给出响应。</p><p>支持突发传输，只要在第一次存取时给出首地址，以后按照地址顺序读写即可</p><h3 id="DRAM芯片位扩展"><a href="#DRAM芯片位扩展" class="headerlink" title="DRAM芯片位扩展"></a>DRAM芯片位扩展</h3><p>位扩展：用若干片位数较少的存储器芯片构成给定字长的存储器，如下图：</p><p><img src="/2023/01/10/%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/image-20211215200636325-16395699972491.png" alt="image-20211215200636325"></p><p>可见，数据读取时是多个字节读取的，如果数据不对齐就需要多次访存，浪费时间</p><h2 id="高速缓冲存储器"><a href="#高速缓冲存储器" class="headerlink" title="高速缓冲存储器"></a>高速缓冲存储器</h2><p>程序访问的局部性：在较短时间间隔内，程序产生的地址往往集中在存储空间的一个很小范围，这种现象成为程序访问的局部性</p><p>时间局部性：多次访问同一个内存地址</p><p>空间局部性：访问相邻地址</p><p>为了更好利用局部性，通常把当前访问单元以及邻近单元作为一个主存储块一起调入cache</p><h3 id="CPU在cache中的访问过程"><a href="#CPU在cache中的访问过程" class="headerlink" title="CPU在cache中的访问过程"></a>CPU在cache中的访问过程</h3><p><img src="/2023/01/10/%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/image-20211215201246544.png" alt="image-20211215201246544"></p><p>cache命中：CPU访问单元所在的主存块在cache中</p><p>由于程序访问的局部性特点，cache的命中率可以达到很高</p><h3 id="cache行和主存块的映射"><a href="#cache行和主存块的映射" class="headerlink" title="cache行和主存块的映射"></a>cache行和主存块的映射</h3><p>直接：每个主存块映射到cache固定行，容易导致频繁换入换出</p><p>全相联：每个主存块映射到cache任意行，难以操作</p><p>组相联映射：将cache分成大小相等的组，每个主存块被映射到cache固定组中的任意一行，即采用组间模映射、组内全映射的方式</p><h3 id="cache中的主存替换算法"><a href="#cache中的主存替换算法" class="headerlink" title="cache中的主存替换算法"></a>cache中的主存替换算法</h3><p>由于多个主存块会映射到同一个cache行中，因此需要决定将哪个块淘汰掉</p><p>先进先出算法：淘汰最先进入的，没有局部性</p><p>最近最少用算法：淘汰使用最少的</p><p>最不经常用算法</p><p>随机替换算法：随机选取一个，性能略差于其他算法，但代价低</p><h3 id="cache一致性问题"><a href="#cache一致性问题" class="headerlink" title="cache一致性问题"></a>cache一致性问题</h3><p>cache中的内容需要和主存的内容保持同步</p><p>写回法：当CPU执行写操作时，如果写命中，则信息只会被写入cache而不会被写入内存；如果没有命中，则在cache中分配一行，将主存块调入该cache行中并更新cache中相应单元的内容</p><p>之后cache行中的主存块被替换时，才将该主存块内容一次性写回内存，如果块脏，则写回，否则丢弃</p><h3 id="IA-32的cache结构"><a href="#IA-32的cache结构" class="headerlink" title="IA-32的cache结构"></a>IA-32的cache结构</h3><p><img src="/2023/01/10/%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/image-20211215203009805.png" alt="image-20211215203009805"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统-虚拟内存管理</title>
    <link href="/2023/01/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/2023/01/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统-虚拟内存管理"><a href="#操作系统-虚拟内存管理" class="headerlink" title="操作系统-虚拟内存管理"></a>操作系统-虚拟内存管理</h1><h2 id="CPU访存"><a href="#CPU访存" class="headerlink" title="CPU访存"></a>CPU访存</h2><p>虚拟地址空间：不同的可执行文件所映射的虚拟地址空间大小一样，地址空间中的区域划分结构也相同</p><p>页可以分为3种状态：</p><ol><li>未分配页：没有任何内容相关联的页</li><li>缓存页：已调入主存而被缓存在DRAM中的页面</li><li>未缓存页：未调入主存而存在硬盘上的页面</li></ol><p>操作系统使用页表将虚拟页转换成物理页，页表具有一下属性：</p><p>装入位：该页是否存在DRAM中</p><p>存放位置：指向物理页号，若为0，则没有被调入内存</p><p>脏位：该页是否被修改</p><p>使用位：配合替换策略来设置</p><p>访问权限位：说明页面访问权限</p><p>禁止缓存位：说明页面是否可以装入cache</p><p><img src="/2023/01/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20211215212421980.png" alt="image-20211215212421980"></p><p>快表：后背转换缓冲器，高速缓存，存储了最活跃的几个页表项。快表比页表小得多，为提高命中率，快表通常具有较高的关联度，大多采用全相联或者组相联的方式</p><p>CPU访存的过程如下：</p><p><img src="/2023/01/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20211215212808356.png" alt="image-20211215212808356"></p><h2 id="页面替换算法"><a href="#页面替换算法" class="headerlink" title="页面替换算法"></a>页面替换算法</h2><h3 id="先进先出算法（FIFO）"><a href="#先进先出算法（FIFO）" class="headerlink" title="先进先出算法（FIFO）"></a>先进先出算法（FIFO）</h3><p>基本思路：选择在内存中驻留时间最长的页面并淘汰之。具体来说：OS维护着一个链表，记录了所有内存当中的逻辑页面。从链表的排序顺序来看，链首页面的驻留时间最长，链尾页面的驻留时间最短。当发生一个页面中断时，把链首页面淘汰出局，把新的页面添加到链表的末尾。</p><h3 id="最近最久未使用算法（LRU）"><a href="#最近最久未使用算法（LRU）" class="headerlink" title="最近最久未使用算法（LRU）"></a>最近最久未使用算法（LRU）</h3><p>思路：当一个缺页中断发生时，选择最久未使用的那个页面，并淘汰之。</p><p>它是对最优置换算法的近似，以过去推未来。根据程序的局部性原理，即在最近一小段时间（最近几条指令），如果某些页面被频繁访问，那么在将来的一小段时间内，它们还可能再一次被频繁访问。反之，如果在过去某些页面长时间未被访问，那么将来它们还可能会长时间地得不到访问。</p><p>算法实现模拟：（使用哈希链表实现）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// key: page, int</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRU</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> max_size = <span class="hljs-number">3</span>;<br>    unordered_map&lt;<span class="hljs-type">int</span>, list&lt; <span class="hljs-type">int</span> &gt;::iterator &gt; h;<br>    list&lt; <span class="hljs-type">int</span> &gt; ls;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(<span class="hljs-type">int</span> pg)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// pg in h:</span><br>        <span class="hljs-keyword">if</span>(h.<span class="hljs-built_in">count</span>(pg) &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-comment">// put to head</span><br>            <span class="hljs-keyword">auto</span> tmp = *h[pg];<br>            ls.<span class="hljs-built_in">erase</span>(h[pg]);<br>            ls.<span class="hljs-built_in">push_front</span>(tmp);<br>            h[pg] = ls.<span class="hljs-built_in">begin</span>();<br>        &#125;<br>        <span class="hljs-keyword">else</span>  <span class="hljs-comment">// pg not in h</span><br>        &#123;<br>            <span class="hljs-comment">// cur size &lt; max size</span><br>            <span class="hljs-comment">// put to front, add to h</span><br>            <span class="hljs-keyword">if</span>(h.<span class="hljs-built_in">size</span>() &lt; max_size)<br>            &#123;<br>                ls.<span class="hljs-built_in">push_front</span>(pg);<br>                h[pg] = ls.<span class="hljs-built_in">begin</span>();<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-comment">// swap the last, del in h</span><br>                h.<span class="hljs-built_in">erase</span>(ls.<span class="hljs-built_in">back</span>());<br>                ls.<span class="hljs-built_in">pop_back</span>();<br>                <span class="hljs-comment">// put to front, add to h</span><br>                ls.<span class="hljs-built_in">push_front</span>(pg);<br>                h[pg] = ls.<span class="hljs-built_in">begin</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">output</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;~~~~~~~~~~~~~~~~~~~~\n&quot;</span>;<br>        cout &lt;&lt; <span class="hljs-string">&quot;hash table:\n&quot;</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; pr : h)<br>        &#123;<br>            cout &lt;&lt; pr.first &lt;&lt; endl;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;list: \n&quot;</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; v : ls)<br>        &#123;<br>            cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;\n~~~~~~~~~~~~~~~~~~~~\n&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    LRU lru;<br>    <span class="hljs-type">int</span> tb[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; v : tb)<br>    &#123;<br>        lru.<span class="hljs-built_in">visit</span>(v);<br>        lru.<span class="hljs-built_in">output</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="时钟页面置换算法"><a href="#时钟页面置换算法" class="headerlink" title="时钟页面置换算法"></a>时钟页面置换算法</h3><p>Clock 页面置换算法——LRU的近似，对FIFO的改进</p><p>基本思路：需要用到页表项的访问位（access bit），当一个页面被装入内存时，把该位初始化为0，然后如果这个页被访问（读&#x2F;写）时，硬件把它置为1.</p><p>把各个页面组织成环形链表（类似钟表面），把指针指向最老的页面（最先进来）；</p><p>当发生一个缺页中断，考察指针所指向的最老的页面，若它的访问为为0，则立即淘汰。若访问为1，则把该位置为0，然后指针往下移动一格。如此下去，直到找到被淘汰的页面，然后把指针移动到它的下一格。</p><h3 id="最不常用算法（least-frequently-used，LFU）"><a href="#最不常用算法（least-frequently-used，LFU）" class="headerlink" title="最不常用算法（least frequently used，LFU）"></a>最不常用算法（least frequently used，LFU）</h3><p>基本思路：当一个缺页中断发生时，选择访问次数最少的那个页面，并淘汰之</p><p>实现方法：对每个页面设置一个访问计数器，每当一个页面被访问时，该页面的访问计数器加1，淘汰计数值最小的那个页面</p><p>LRU&#x2F;LFU区别：LRU考察的是多久未访问，时间越短越值得留在内存，LFU是访问次数&#x2F;频度，次数越多越好。</p><p>反例：一个页面在进程开始时使用的很多，但以后就不使用了。此时LFU就不适用了。把时间也考虑进去，在一段时间内考察LFU。比如，定期把次数寄存器右移一位。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>不相交集结构</title>
    <link href="/2023/01/10/%E4%B8%8D%E7%9B%B8%E4%BA%A4%E9%9B%86%E7%BB%93%E6%9E%84/"/>
    <url>/2023/01/10/%E4%B8%8D%E7%9B%B8%E4%BA%A4%E9%9B%86%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="不相交集结构"><a href="#不相交集结构" class="headerlink" title="不相交集结构"></a>不相交集结构</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>顾名思义，不相交集数据结构的集合之间是没有交集的，这种结构常常需要实现两种运算：</p><ul><li>Find(x): 查找元素x所在的集合的名字</li><li>Union(x, y): 包含元素x和y的两个集合用他们的并集替换</li></ul><h2 id="实现数据结构"><a href="#实现数据结构" class="headerlink" title="实现数据结构"></a>实现数据结构</h2><p>以上两种算法都要求能够找到元素所在的集合的名字，因此可以构造树结构，将该树的根作为集合的名字，树上的结点都有一个指向父节点的指针，这样每个结点都能够找到该集合的名字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//class TreeNode 的成员和函数</span><br>TreeNode nextTreeNode;  <span class="hljs-comment">//指向父节点, 为空则是根节点</span><br><span class="hljs-type">int</span> val;                <span class="hljs-comment">//存放值</span><br><span class="hljs-type">int</span> height;             <span class="hljs-comment">//树的高度（这里只有该结点为根节点时才有效）</span><br><br>get,set方法;<br><br>TreeNode <span class="hljs-title function_">find</span><span class="hljs-params">(TreeNode x)</span>;       <span class="hljs-comment">//找到x的根节点</span><br>TreeNode <span class="hljs-title function_">union</span><span class="hljs-params">(TreeNode x)</span>;      <span class="hljs-comment">//合并两颗树（必须保证参数是根节点，即find(this).union(Find(x))</span><br></code></pre></td></tr></table></figure><h2 id="按秩合并措施"><a href="#按秩合并措施" class="headerlink" title="按秩合并措施"></a>按秩合并措施</h2><p>很明显，如果随意地合并两个集合，那么树的高度最坏会达到$O(n)$级别，所以采取以下措施：</p><p>高树和矮树合并时，把高树的根节点作为新的根节点，并成为矮树的根节点的父节点。</p><p>如果两棵树高度相同，任意哪个作为根节点都行，但是树的高度也要增加。</p><p>实现代码：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">union</span><span class="hljs-params">(TreeNode x)</span> </span>&#123;<br>    <span class="hljs-comment">// TODO Auto-generated method stub</span><br>    <span class="hljs-keyword">if</span>(height &lt;= x.height)&#123;<br>        <span class="hljs-built_in">setNextTreeNode</span>(x);<br>        <span class="hljs-keyword">if</span>(height == x.height)&#123;<br>            x.height++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        x.<span class="hljs-built_in">setNextTreeNode</span>(<span class="hljs-keyword">this</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="查找集合-amp-路径压缩"><a href="#查找集合-amp-路径压缩" class="headerlink" title="查找集合&amp;路径压缩"></a>查找集合&amp;路径压缩</h2><p>要寻找到一个集合的名字很容易，采取的数据结构就是围绕这一需求而设计的，但是为了避免树的高度过大，在查找到一条路径后可以采取路径压缩的策略来降低树的高度。</p><p>基本思路：在找到树的根节点后，重新遍历这条路径上的所有结点，让他们都指向树的根节点，最终完成路径压缩。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">find</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-comment">// TODO Auto-generated method stub</span><br>       <span class="hljs-type">TreeNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;<br>       <span class="hljs-keyword">while</span>(!p.isRoot())&#123;<br>           p = p.getNextTreeNode();<br>       &#125;<br>       <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> p;<br>       p = <span class="hljs-built_in">this</span>;<br>       <span class="hljs-keyword">while</span>(!p.isRoot())&#123;<br>           <span class="hljs-type">TreeNode</span> <span class="hljs-variable">nextNode</span> <span class="hljs-operator">=</span> p.getNextTreeNode();<br>           p.setNextTreeNode(root);<br>           p = nextNode;<br>       &#125;<br>       <span class="hljs-keyword">return</span> root;<br>   &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>不相交集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>标签划分</title>
    <link href="/2023/01/10/%E6%A0%87%E7%AD%BE%E5%88%92%E5%88%86/"/>
    <url>/2023/01/10/%E6%A0%87%E7%AD%BE%E5%88%92%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="标签划分"><a href="#标签划分" class="headerlink" title="标签划分"></a>标签划分</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定一个字符串，将该字符串划分成尽可能多的部分，使得这些每个字母最多只能出现在这些部分中的一个</p><p><img src="/2023/01/10/%E6%A0%87%E7%AD%BE%E5%88%92%E5%88%86/image-20201122125753144.png" alt="image-20201122125753144"></p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>首先获得每个字符最后出现的下标，然后从头开始遍历每一个字符，如果某个字符的范围超出当前划分的右边界，则扩展右边界，这是当前的最优解。直到遍历指针到达右边界，此时说明划分里的字符都是只出现在这个划分里的，将该划分放入答案中，然后把下一个下标作为下一个划分的起点，直到字符串遍历完。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">partitionLabels</span><span class="hljs-params">(String S)</span> &#123;<br>        <span class="hljs-type">int</span>[] last = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; S.length(); ++i)<br>            last[S.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>] = i;<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, anchor = <span class="hljs-number">0</span>;<br>        List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; S.length(); ++i) &#123;<br>            j = Math.max(j, last[S.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]);<br>            <span class="hljs-keyword">if</span> (i == j) &#123;<br>                ans.add(i - anchor + <span class="hljs-number">1</span>);<br>                anchor = i + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UnityShader-重建世界坐标</title>
    <link href="/2023/01/10/UnityShader-%E9%87%8D%E5%BB%BA%E4%B8%96%E7%95%8C%E5%9D%90%E6%A0%87/"/>
    <url>/2023/01/10/UnityShader-%E9%87%8D%E5%BB%BA%E4%B8%96%E7%95%8C%E5%9D%90%E6%A0%87/</url>
    
    <content type="html"><![CDATA[<h1 id="UnityShader-重建世界坐标"><a href="#UnityShader-重建世界坐标" class="headerlink" title="UnityShader-重建世界坐标"></a>UnityShader-重建世界坐标</h1><p>最近在学习屏幕后处理相关的知识，其中很重要的一个技巧就是通过深度纹理重建像素的世界坐标，通过它可以实现很多酷炫的效果，比如烟雾效果，扫描效果等。我目前已知两种方法，一种是通过逆矩阵的方式重建，另一种是通过屏幕射线插值的方式实现，本文主要介绍第二种</p><h2 id="通过屏幕射线插值重建"><a href="#通过屏幕射线插值重建" class="headerlink" title="通过屏幕射线插值重建"></a>通过屏幕射线插值重建</h2><p>核心原理：计算摄像机的位置加上像素点到摄像机的偏移得到世界坐标</p><p>其中用到的数学原理如下图所示：</p><p><img src="/2023/01/10/UnityShader-%E9%87%8D%E5%BB%BA%E4%B8%96%E7%95%8C%E5%9D%90%E6%A0%87/image-20210926192549702.png" alt="image-20210926192549702"></p><p>我将用以下俯视图辅助解释其中的原理：</p><p><img src="/2023/01/10/UnityShader-%E9%87%8D%E5%BB%BA%E4%B8%96%E7%95%8C%E5%9D%90%E6%A0%87/RebuildWorldPosition.drawio.png" alt="RebuildWorldPosition.drawio"></p><p>如图，O为摄像机的位置，A为远裁剪平面的左上角，B为右上角，其它点的相对位置如图，其中T为一个世界空间中的像素点，为了得到T的坐标，我们需要先求出向量$$OT$$的值</p><p>根据相似三角形定理，可以得出$$OT &#x3D; OE \times depth(T)$$，公式推导如下：<br>$$<br>\frac{\abs{OT}}{\abs{OE}} &#x3D; \frac{\abs{OD}}{\abs{OC}} &#x3D; \frac{depth(T)}{depth(E)} &#x3D; \frac{depth(T)}{1}<br>$$</p><p>$$<br>\abs{OT} &#x3D; \abs{OE} \times depth(T)<br>$$</p><p>又因为：<br>$$<br>OT \times OE &#x3D; 0<br>$$<br>即$$OT$$平行于$$OE$$，因此有：<br>$$<br>OT &#x3D; OE \times depth(T)<br>$$<br>所以，我们只要知道T点的深度值和向量$$OE$$，就能求得像度点 T 的世界坐标</p><p>T的线性深度值可以通过深度纹理采集，然后进行透视除法的逆获得，那么如何求得向量$$OE$$呢？</p><p>我们可以在顶点着色器中求得摄像机坐标到屏幕四边形四个顶点的向量，再通过GPU插值获得，这4个向量的求法很简单，利用到摄像机的几个参数即可，具体方法见代码</p><p>在《Unity Shader 入门精要》一书中也介绍了类似的重建深度坐标的方法，但其中使用的深度值是<strong>视角空间下的深度值</strong>，该深度值的范围是[Near, Far]（视角空间下z坐标的范围），本文所使用的是01范围的深度值，是视角空间下的深度值除以Far后得到的，如果不小心混淆使用则得不到理想的效果！！</p><p>挂载到摄像机下脚本的关键代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnRenderImage</span>(<span class="hljs-params">RenderTexture source, RenderTexture destination</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (RenderMaterial == <span class="hljs-literal">null</span>) <span class="hljs-comment">// 用于重建世界坐标的材质</span><br>    &#123;<br>        Graphics.Blit(source, destination);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> aspect = currentCamera.aspect;<br>        <span class="hljs-keyword">var</span> far = currentCamera.farClipPlane;<br>        <span class="hljs-keyword">var</span> right = transform.right;<br>        <span class="hljs-keyword">var</span> up = transform.up;<br>        <span class="hljs-keyword">var</span> forward = transform.forward;<br>        <span class="hljs-keyword">var</span> halfHeight = Mathf.Tan(currentCamera.fieldOfView * <span class="hljs-number">0.5f</span> * Mathf.Deg2Rad);<br><br>        <span class="hljs-comment">// 计算远裁剪面处的xyz三方向向量</span><br>        <span class="hljs-keyword">var</span> rightVec = right * far * halfFovTan * aspect;<br>        <span class="hljs-keyword">var</span> upVec = up * far * halfFovTan;<br>        <span class="hljs-keyword">var</span> forwardVec = forward * far;<br><br>        <span class="hljs-comment">// 计算摄像机到远裁剪平面的四个顶点的向量</span><br>        <span class="hljs-keyword">var</span> topLeft = (forwardVec - rightVec + upVec);<br>        <span class="hljs-keyword">var</span> topRight = (forwardVec + rightVec + upVec);<br>        <span class="hljs-keyword">var</span> bottomLeft = (forwardVec - rightVec - upVec);<br>        <span class="hljs-keyword">var</span> bottomRight = (forwardVec + rightVec - upVec);<br><br>        <span class="hljs-comment">// 将计算得到的向量放到一个4维矩阵中储存</span><br>        <span class="hljs-keyword">var</span> frustumCorners = Matrix4x4.identity;<br>        frustumCorners.SetRow(<span class="hljs-number">0</span>, topLeft);<br>        frustumCorners.SetRow(<span class="hljs-number">1</span>, topRight);<br>        frustumCorners.SetRow(<span class="hljs-number">2</span>, bottomLeft);<br>        frustumCorners.SetRow(<span class="hljs-number">3</span>, bottomRight);<br><br>        postEffectMat.SetMatrix(<span class="hljs-string">&quot;_FrustumCornersRay&quot;</span>, frustumCorners);<br>        Graphics.Blit(source, destination, RenderMaterial);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>用于重建世界坐标的shader关键代码如下：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-comment">// 顶点着色器，负责计算世界空间坐标，把向量存储到顶点信息中（实际上只有4个顶点，6个索引）</span><br>v2f vert(appdata_img v) &#123;<br>    v2f o;<br>    o.pos = UnityObjectToClipPos(v.vertex);<br><br>    o.srcPos = ComputeScreenPos(o.pos);<br><br>    o.uv = v.texcoord;<br>    o.uv_depth = v.texcoord;<br><br>    <span class="hljs-meta">#if UNITY_UV_STARTS_AT_TOP</span><br>    <span class="hljs-keyword">if</span> (_MainTex_TexelSize.y &lt; <span class="hljs-number">0</span>)<br>        o.uv_depth.y = <span class="hljs-number">1</span> - o.uv_depth.y;<br>    <span class="hljs-meta">#endif</span><br><br>    <span class="hljs-type">int</span> <span class="hljs-keyword">index</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (v.texcoord.x &lt; <span class="hljs-number">0.5</span> &amp;&amp; v.texcoord.y &lt; <span class="hljs-number">0.5</span>) &#123;<br>        <span class="hljs-keyword">index</span> = <span class="hljs-number">0</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (v.texcoord.x &gt; <span class="hljs-number">0.5</span> &amp;&amp; v.texcoord.y &lt; <span class="hljs-number">0.5</span>) &#123;<br>        <span class="hljs-keyword">index</span> = <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (v.texcoord.x &gt; <span class="hljs-number">0.5</span> &amp;&amp; v.texcoord.y &gt; <span class="hljs-number">0.5</span>) &#123;<br>        <span class="hljs-keyword">index</span> = <span class="hljs-number">2</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">index</span> = <span class="hljs-number">3</span>;<br>    &#125;<br><br>    <span class="hljs-meta">#if UNITY_UV_STARTS_AT_TOP</span><br>    <span class="hljs-keyword">if</span> (_MainTex_TexelSize.y &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">index</span> = <span class="hljs-number">3</span> - <span class="hljs-keyword">index</span>;<br>    <span class="hljs-meta">#endif</span><br><br>    o.interpolatedRay = _FrustumCornersRay[<span class="hljs-keyword">index</span>];<br><br>    <span class="hljs-keyword">return</span> o;<br>&#125;<br><br>fixed4 frag(v2f i) : SV_Target &#123;<br>    <span class="hljs-comment">// 获得线性深度值</span><br>    <span class="hljs-type">float</span> depth = tex2Dproj(_CameraDepthTexture, UNITY_PROJ_COORD(i.srcPos)).r;<br>    <span class="hljs-type">float</span> linear01Depth = Linear01Depth(depth);<br><br>    <span class="hljs-comment">// 计算世界坐标</span><br>    float3 worldPos = _WorldSpaceCameraPos + linear01Depth * i.interpolatedRay.xyz;<br><br>    <span class="hljs-keyword">return</span> fixed4(worldPos, <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>Shader</tag>
      
      <tag>postprocess</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UnityShader-高级纹理</title>
    <link href="/2023/01/10/UnityShader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/"/>
    <url>/2023/01/10/UnityShader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="高级纹理"><a href="#高级纹理" class="headerlink" title="高级纹理"></a>高级纹理</h1><h2 id="立方体纹理"><a href="#立方体纹理" class="headerlink" title="立方体纹理"></a>立方体纹理</h2><p><strong>立方体纹理（Cubemap）</strong>是<strong>环境映射</strong>的一种实现形式，可以用于模拟物体周围的环境，或者模拟金属反射周围的环境</p><p><strong>原理：</strong></p><p>立方体纹理包含6个图像，在进行纹理采样时，计算从立方体中心出发的矢量和立方体的交点，然后对该交点进行像素采样</p><p><img src="/2023/01/10/UnityShader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/cubemap_sample.png" alt="cubemap_sample.png-20.1kB"></p><p><strong>优点：</strong></p><p>实现快速，效果良好</p><p><strong>缺点：</strong></p><p>当场景中引入新的物体、光源，或者物体本身需要移动时，立方体纹理也需要重新生成</p><p>不能反射使用了该立方体纹理的物体本身，难以处理金属的多次反射</p><h3 id="天空盒子（Skybox）"><a href="#天空盒子（Skybox）" class="headerlink" title="天空盒子（Skybox）"></a>天空盒子（Skybox）</h3><p>用于模拟背景或者天空，整个场景被包围在一个立方体内</p><p>实现：</p><ol><li>新建材质，在UnityShader下拉菜单中选择Skybox&#x2F;6 Sided</li><li>使用6张纹理对材质进行赋值</li><li>设置纹理WrapMode为Clamp，防止出现接缝处不匹配现象</li><li>调整属性：<ul><li>Tint Color：控制该材质的整体颜色</li><li>Exposure：调整天空盒子的亮度</li><li>Rotation：调整天空盒子沿+y轴方向的旋转角度</li></ul></li><li>在Window-》Rendering-》Lighting中，将该材质赋值给Skybox选项</li></ol><p>也可以给摄像机设置单独的天空盒子来覆盖默认的，只需要添加Skybox组件即可</p><h3 id="创建用于环境映射的立方体纹理"><a href="#创建用于环境映射的立方体纹理" class="headerlink" title="创建用于环境映射的立方体纹理"></a>创建用于环境映射的立方体纹理</h3><ol><li>直接由特殊布局的纹理创建。该纹理类似于立方体展开图的交叉布局、全景布局等。该方法可以对纹理数据进行压缩，也支持边缘修正、光滑反射等</li><li>手动创建Cubemap资源，再把6张图赋值给它</li><li>由脚本生成</li></ol><br><p>使用方法1创建立方体纹理：</p><ol><li><p>指定环境映射的位置</p></li><li><p>使用<code>Camera.RenderToCubemap</code>函数创建立方体纹理，相关代码如下，需要放置在Editor文件夹下</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> UnityEditor;<br><span class="hljs-keyword">using</span> System.Collections;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">RenderCubemapWizard</span> : <span class="hljs-title">ScriptableWizard</span> &#123;<br><br><span class="hljs-keyword">public</span> Transform renderFromPosition;<br><span class="hljs-keyword">public</span> Cubemap cubemap;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnWizardUpdate</span> ()</span> &#123;<br>helpString = <span class="hljs-string">&quot;Select transform to render from and cubemap to render into&quot;</span>;<br>isValid = (renderFromPosition != <span class="hljs-literal">null</span>) &amp;&amp; (cubemap != <span class="hljs-literal">null</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnWizardCreate</span> ()</span> &#123;<br><span class="hljs-comment">// create temporary camera for rendering</span><br>GameObject go = <span class="hljs-keyword">new</span> GameObject( <span class="hljs-string">&quot;CubemapCamera&quot;</span>);<br>go.AddComponent&lt;Camera&gt;();<br><span class="hljs-comment">// place it on the object</span><br>go.transform.position = renderFromPosition.position;<br><span class="hljs-comment">// render into cubemap</span><br>go.GetComponent&lt;Camera&gt;().RenderToCubemap(cubemap);<br><br><span class="hljs-comment">// destroy temporary camera</span><br>DestroyImmediate( go );<br>&#125;<br><br>[<span class="hljs-meta">MenuItem(<span class="hljs-string">&quot;GameObject/Render into Cubemap&quot;</span>)</span>]<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RenderCubemap</span> ()</span> &#123;<br>ScriptableWizard.DisplayWizard&lt;RenderCubemapWizard&gt;(<br><span class="hljs-string">&quot;Render cubemap&quot;</span>, <span class="hljs-string">&quot;Render!&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>选择Create-》Legacy-》Cubemap创建立方体纹理，在面板中勾选Readable选项</p></li><li><p>使用Wizard（刚刚编写的向导脚本）对立方体纹理添加具体图像</p></li><li><p>调整Face Size选项，值越大分辨率越大，但是占用内存也越多</p></li></ol><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>原理：通过入射光线的方向和表面法线的方向计算反射方向，再利用反射方向对立方体进行纹理采样</p><p>实现代码如下：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs glsl">Shader &quot;Reflection&quot; &#123;<br>Properties &#123;<br>_Color (&quot;Color Tint&quot;, Color) = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>        <span class="hljs-comment">// 控制漫反射颜色</span><br>_ReflectColor (&quot;Reflection Color&quot;, Color) = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>        <span class="hljs-comment">// 控制材质的反射程度</span><br>_ReflectAmount (&quot;Reflect Amount&quot;, Range(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) = <span class="hljs-number">1</span><br>_Cubemap (&quot;Reflection Cubemap&quot;, Cube) = &quot;_Skybox&quot; &#123;&#125;<br>&#125;<br>SubShader &#123;<br>Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot;&#125;<br><br>Pass &#123; <br>Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;<br><br>CGPROGRAM<br><br><span class="hljs-meta">#pragma multi_compile_fwdbase</span><br><br><span class="hljs-meta">#pragma vertex vert</span><br><span class="hljs-meta">#pragma fragment frag</span><br><br><span class="hljs-meta">#include &quot;Lighting.cginc&quot;</span><br><span class="hljs-meta">#include &quot;AutoLight.cginc&quot;</span><br><br>fixed4 _Color;<br>fixed4 _ReflectColor;<br>fixed _ReflectAmount;<br>samplerCUBE _Cubemap;<br><br>struct a2v &#123;<br>float4 vertex : POSITION;<br>float3 normal : NORMAL;<br>&#125;;<br><br>struct v2f &#123;<br>float4 pos : SV_POSITION;<br>float3 worldPos : TEXCOORD0;<br>fixed3 worldNormal : TEXCOORD1;<br>fixed3 worldViewDir : TEXCOORD2;<br>fixed3 worldRefl : TEXCOORD3;<br>SHADOW_COORDS(<span class="hljs-number">4</span>)<br>&#125;;<br><br>v2f vert(a2v v) &#123;<br>v2f o;<br><br>o.pos = UnityObjectToClipPos(v.vertex);<br><br>o.worldNormal = UnityObjectToWorldNormal(v.normal);<br><br>o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<br><br>o.worldViewDir = UnityWorldSpaceViewDir(o.worldPos);<br><br><span class="hljs-comment">// Compute the reflect dir in world space</span><br>o.worldRefl = <span class="hljs-built_in">reflect</span>(-o.worldViewDir, o.worldNormal);<br><br>TRANSFER_SHADOW(o);<br><br><span class="hljs-keyword">return</span> o;<br>&#125;<br><br>fixed4 frag(v2f i) : SV_Target &#123;<br>fixed3 worldNormal = <span class="hljs-built_in">normalize</span>(i.worldNormal);<br>fixed3 worldLightDir = <span class="hljs-built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));<br>fixed3 worldViewDir = <span class="hljs-built_in">normalize</span>(i.worldViewDir);<br><br>fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;<br><br>fixed3 diffuse = _LightColor0.rgb * _Color.rgb * <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">dot</span>(worldNormal, worldLightDir));<br><br><span class="hljs-comment">// Use the reflect dir in world space to access the cubemap</span><br>fixed3 reflection = texCUBE(_Cubemap, i.worldRefl).rgb * _ReflectColor.rgb;<br><br>UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);<br><br><span class="hljs-comment">// Mix the diffuse color with the reflected color</span><br>fixed3 color = ambient + lerp(diffuse, reflection, _ReflectAmount) * atten;<br><br><span class="hljs-keyword">return</span> fixed4(color, <span class="hljs-number">1.0</span>);<br>&#125;<br><br>ENDCG<br>&#125;<br>&#125;<br>FallBack &quot;Reflective/VertexLit&quot;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="折射"><a href="#折射" class="headerlink" title="折射"></a>折射</h3><p>原理：当光线从一种介质斜射入另一种介质时，传播方向一般会发生改变</p><p>使用**斯涅尔定律(Snell’s Law)**来计算反射角：<br>$$<br>n_1sin\theta_{1} &#x3D; n_2sin\theta_{2}<br>$$<br>其中n1,n2为折射率(index of refraction)。图形学中通常只模拟一次折射</p><p>实现代码如下：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs glsl">Shader &quot;Refraction&quot; &#123;<br>Properties &#123;<br>_Color (&quot;Color Tint&quot;, Color) = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>_RefractColor (&quot;Refraction Color&quot;, Color) = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>_RefractAmount (&quot;Refraction Amount&quot;, Range(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) = <span class="hljs-number">1</span><br>        <span class="hljs-comment">// 不同介质的透射比</span><br>_RefractRatio (&quot;Refraction Ratio&quot;, Range(<span class="hljs-number">0.1</span>, <span class="hljs-number">1</span>)) = <span class="hljs-number">0.5</span><br>_Cubemap (&quot;Refraction Cubemap&quot;, Cube) = &quot;_Skybox&quot; &#123;&#125;<br>&#125;<br>SubShader &#123;<br>Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot;&#125;<br><br>Pass &#123; <br>Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;<br><br>CGPROGRAM<br><br><span class="hljs-meta">#pragma multi_compile_fwdbase</span><br><br><span class="hljs-meta">#pragma vertex vert</span><br><span class="hljs-meta">#pragma fragment frag</span><br><br><span class="hljs-meta">#include &quot;Lighting.cginc&quot;</span><br><span class="hljs-meta">#include &quot;AutoLight.cginc&quot;</span><br><br>fixed4 _Color;<br>fixed4 _RefractColor;<br><span class="hljs-type">float</span> _RefractAmount;<br>fixed _RefractRatio;<br>samplerCUBE _Cubemap;<br><br>struct a2v &#123;<br>float4 vertex : POSITION;<br>float3 normal : NORMAL;<br>&#125;;<br><br>struct v2f &#123;<br>float4 pos : SV_POSITION;<br>float3 worldPos : TEXCOORD0;<br>fixed3 worldNormal : TEXCOORD1;<br>fixed3 worldViewDir : TEXCOORD2;<br>fixed3 worldRefr : TEXCOORD3;<br>SHADOW_COORDS(<span class="hljs-number">4</span>)<br>&#125;;<br><br>v2f vert(a2v v) &#123;<br>v2f o;<br>o.pos = UnityObjectToClipPos(v.vertex);<br><br>o.worldNormal = UnityObjectToWorldNormal(v.normal);<br><br>o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<br><br>o.worldViewDir = UnityWorldSpaceViewDir(o.worldPos);<br><br><span class="hljs-comment">// Compute the refract dir in world space</span><br>                <span class="hljs-comment">// 参数一为入射光线的方向，必须是归一化之后的矢量</span><br>                <span class="hljs-comment">// 参数二是表面法线，需要归一化</span><br>                <span class="hljs-comment">// 参数三是入射光线所在介质的折射率和折射光线所在介质的折射率之间的比值</span><br>o.worldRefr = <span class="hljs-built_in">refract</span>(-<span class="hljs-built_in">normalize</span>(o.worldViewDir), <span class="hljs-built_in">normalize</span>(o.worldNormal), _RefractRatio);<br><br>TRANSFER_SHADOW(o);<br><br><span class="hljs-keyword">return</span> o;<br>&#125;<br><br>fixed4 frag(v2f i) : SV_Target &#123;<br>fixed3 worldNormal = <span class="hljs-built_in">normalize</span>(i.worldNormal);<br>fixed3 worldLightDir = <span class="hljs-built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));<br>fixed3 worldViewDir = <span class="hljs-built_in">normalize</span>(i.worldViewDir);<br><br>fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;<br><br>fixed3 diffuse = _LightColor0.rgb * _Color.rgb * <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">dot</span>(worldNormal, worldLightDir));<br><br><span class="hljs-comment">// Use the refract dir in world space to access the cubemap</span><br>fixed3 refraction = texCUBE(_Cubemap, i.worldRefr).rgb * _RefractColor.rgb;<br><br>UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);<br><br><span class="hljs-comment">// Mix the diffuse color with the refract color</span><br>fixed3 color = ambient + lerp(diffuse, refraction, _RefractAmount) * atten;<br><br><span class="hljs-keyword">return</span> fixed4(color, <span class="hljs-number">1.0</span>);<br>&#125;<br><br>ENDCG<br>&#125;<br>&#125; <br>FallBack &quot;Reflective/VertexLit&quot;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="菲涅耳反射-Fresnel-reflection"><a href="#菲涅耳反射-Fresnel-reflection" class="headerlink" title="菲涅耳反射(Fresnel reflection)"></a>菲涅耳反射(Fresnel reflection)</h3><p>原理：</p><p>当光线照射到物体表面时，一部分发生反射，一部分进入物体内部，发生折射或者散射。被反射的光和入射光之间存在一定的比率关系，该比率可以通过菲涅耳等式计算。</p><p>Schlick菲涅耳近似等式：<br>$$<br>F_{schlick}(v, n) &#x3D; F_0 + (1 - F_0)(1 - v \cdot n)^{5}<br>$$<br>其中，$F_0$ 是一个反射系数，用于控制菲涅耳反射的强度，$v$ 是视角方向，$n$ 是表面法线。</p><p>Empricial菲涅耳近似等式：<br>$$<br>F_{Empricial}(v, n) &#x3D; max(0, min(1, bias + scale \times (1 - v \cdot n)^{power}))<br>$$<br>其中，bias, scale 和 power是控制项</p><p>实现代码如下：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs glsl">Shader &quot;Fresnel&quot; &#123;<br>Properties &#123;<br>_Color (&quot;Color Tint&quot;, Color) = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>_FresnelScale (&quot;Fresnel Scale&quot;, Range(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) = <span class="hljs-number">0.5</span><br>_Cubemap (&quot;Reflection Cubemap&quot;, Cube) = &quot;_Skybox&quot; &#123;&#125;<br>&#125;<br>SubShader &#123;<br>Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot;&#125;<br><br>Pass &#123; <br>Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;<br><br>CGPROGRAM<br><br><span class="hljs-meta">#pragma multi_compile_fwdbase</span><br><br><span class="hljs-meta">#pragma vertex vert</span><br><span class="hljs-meta">#pragma fragment frag</span><br><br><span class="hljs-meta">#include &quot;Lighting.cginc&quot;</span><br><span class="hljs-meta">#include &quot;AutoLight.cginc&quot;</span><br><br>fixed4 _Color;<br>fixed _FresnelScale;<br>samplerCUBE _Cubemap;<br><br>struct a2v &#123;<br>float4 vertex : POSITION;<br>float3 normal : NORMAL;<br>&#125;;<br><br>struct v2f &#123;<br>float4 pos : SV_POSITION;<br>float3 worldPos : TEXCOORD0;<br>  fixed3 worldNormal : TEXCOORD1;<br>  fixed3 worldViewDir : TEXCOORD2;<br>  fixed3 worldRefl : TEXCOORD3;<br>  SHADOW_COORDS(<span class="hljs-number">4</span>)<br>&#125;;<br><br>v2f vert(a2v v) &#123;<br>v2f o;<br>o.pos = UnityObjectToClipPos(v.vertex);<br><br>o.worldNormal = UnityObjectToWorldNormal(v.normal);<br><br>o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<br><br>o.worldViewDir = UnityWorldSpaceViewDir(o.worldPos);<br><br>o.worldRefl = <span class="hljs-built_in">reflect</span>(-o.worldViewDir, o.worldNormal);<br><br>TRANSFER_SHADOW(o);<br><br><span class="hljs-keyword">return</span> o;<br>&#125;<br><br>fixed4 frag(v2f i) : SV_Target &#123;<br>fixed3 worldNormal = <span class="hljs-built_in">normalize</span>(i.worldNormal);<br>fixed3 worldLightDir = <span class="hljs-built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));<br>fixed3 worldViewDir = <span class="hljs-built_in">normalize</span>(i.worldViewDir);<br><br>fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;<br><br>UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);<br><br>fixed3 reflection = texCUBE(_Cubemap, i.worldRefl).rgb;<br><br>fixed fresnel = _FresnelScale + (<span class="hljs-number">1</span> - _FresnelScale) * <span class="hljs-built_in">pow</span>(<span class="hljs-number">1</span> - <span class="hljs-built_in">dot</span>(worldViewDir, worldNormal), <span class="hljs-number">5</span>);<br><br>fixed3 diffuse = _LightColor0.rgb * _Color.rgb * <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">dot</span>(worldNormal, worldLightDir));<br><br>fixed3 color = ambient + lerp(diffuse, reflection, saturate(fresnel)) * atten;<br><br><span class="hljs-keyword">return</span> fixed4(color, <span class="hljs-number">1.0</span>);<br>&#125;<br><br>ENDCG<br>&#125;<br>&#125; <br>FallBack &quot;Reflective/VertexLit&quot;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="渲染纹理"><a href="#渲染纹理" class="headerlink" title="渲染纹理"></a>渲染纹理</h2><p><strong>渲染目标纹理（RTT）</strong>：现代GPU允许把整个三维场景渲染到一个中间缓冲中</p><p><strong>多重渲染目标（MRT）</strong>：GPU允许把场景同时渲染到多个渲染目标纹理中，不再需要为每个渲染目标纹理单独渲染完整的场景</p><p>渲染纹理（Render Texture）：Unity为渲染目标定义了一种专门的纹理类型，通常有两种方式：</p><ul><li>在Project目录下创建一个渲染纹理，然后把某个摄像机的渲染目标设置成该渲染纹理，这样摄像机的渲染结果就会实时更新到渲染纹理中，而不会显示在屏幕上。还可以选择渲染纹理分辨率、滤波模式等属性</li><li>在屏幕后处理使用时使用Grab Pass命令或者OnRenderImage函数获取当前屏幕图像，Unity将图像放到一张和屏幕分辨率等同的渲染纹理中</li></ul><h3 id="镜子效果"><a href="#镜子效果" class="headerlink" title="镜子效果"></a>镜子效果</h3><p>实现原理：使用一个渲染纹理作为输入属性，并把该渲染纹理在水平方向上翻转后直接显示到物体上</p><p>在Project视图中创建渲染纹理（Create-》Render Texture）</p><p>为了得到从镜子出发观察到的图像，需要创建一个摄像机，并调整它的位置、裁剪平面、视角等，使得它显示的图像是我们希望的图像。再将渲染纹理（Mirror Texture）附加到该摄像机上</p><p><img src="/2023/01/10/UnityShader-%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86/render_texture.png" alt="render_texture.png-113.3kB"></p><p>渲染纹理的分辨率可能影响到画面效果，此时可以调整为更高的分辨率或者进行抗锯齿采样，但同时也会损失性能</p><p>相关代码如下：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs glsl">Shader &quot;Mirror&quot; &#123;<br>Properties &#123;<br>        <span class="hljs-comment">// 对应由镜子摄像机渲染得到的纹理</span><br>_MainTex (&quot;Main Tex&quot;, <span class="hljs-number">2</span>D) = &quot;white&quot; &#123;&#125;<br>&#125;<br>SubShader &#123;<br>Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot;&#125;<br><br>Pass &#123;<br>CGPROGRAM<br><br><span class="hljs-meta">#pragma vertex vert</span><br><span class="hljs-meta">#pragma fragment frag</span><br><br><span class="hljs-type">sampler2D</span> _MainTex;<br><br>struct a2v &#123;<br>float4 vertex : POSITION;<br>float3 texcoord : TEXCOORD0;<br>&#125;;<br><br>struct v2f &#123;<br>float4 pos : SV_POSITION;<br>float2 uv : TEXCOORD0;<br>&#125;;<br><br>v2f vert(a2v v) &#123;<br>v2f o;<br>o.pos = UnityObjectToClipPos(v.vertex);<br><br>o.uv = v.texcoord;<br><span class="hljs-comment">// Mirror needs to filp x</span><br>o.uv.x = <span class="hljs-number">1</span> - o.uv.x;<br><br><span class="hljs-keyword">return</span> o;<br>&#125;<br><br>fixed4 frag(v2f i) : SV_Target &#123;<br><span class="hljs-keyword">return</span> tex2D(_MainTex, i.uv);<br>&#125;<br><br>ENDCG<br>&#125;<br>&#125; <br> FallBack Off<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="玻璃效果"><a href="#玻璃效果" class="headerlink" title="玻璃效果"></a>玻璃效果</h3><p>原理：</p><ul><li>使用法线纹理来修改模型的法线信息</li><li>通过Cubemap模拟玻璃的<strong>反射</strong></li><li>使用GrabPass抓取玻璃后的屏幕图像后，使用切线空间下的法线对屏幕纹理坐标偏移以模拟近似的<strong>折射</strong>效果</li></ul><p>相关代码如下：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs glsl">Shader &quot;Glass Refraction&quot; &#123;<br>Properties &#123;<br>        <span class="hljs-comment">// 玻璃的材质纹理，默认为白色</span><br>_MainTex (&quot;Main Tex&quot;, <span class="hljs-number">2</span>D) = &quot;white&quot; &#123;&#125;<br>        <span class="hljs-comment">// 玻璃的法线纹理</span><br>_BumpMap (&quot;Normal Map&quot;, <span class="hljs-number">2</span>D) = &quot;bump&quot; &#123;&#125;<br>        <span class="hljs-comment">// 用于模拟反射的环境纹理</span><br>_Cubemap (&quot;Environment Cubemap&quot;, Cube) = &quot;_Skybox&quot; &#123;&#125;<br>        <span class="hljs-comment">// 控制模拟折射时图像的扭曲程度，该值越大，计算得到的偏移量越大，玻璃背后的物体形变程度越大</span><br>_Distortion (&quot;Distortion&quot;, Range(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>)) = <span class="hljs-number">10</span><br>        <span class="hljs-comment">// 控制折射程度，为0时只有反射效果，为1时只有折射效果</span><br>_RefractAmount (&quot;Refract Amount&quot;, Range(<span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>)) = <span class="hljs-number">1.0</span><br>&#125;<br>SubShader &#123;<br><span class="hljs-comment">// We must be transparent, so other objects are drawn before this one.</span><br>        <span class="hljs-comment">// RenderType=Opaque: 在使用着色器替换时，该物体在需要时能被正确渲染，通常发生在需要得到摄像机的深度和法线纹理时</span><br>Tags &#123; &quot;Queue&quot;=&quot;Transparent&quot; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;<br><br><span class="hljs-comment">// This pass grabs the screen behind the object into a texture.</span><br><span class="hljs-comment">// We can access the result in the next pass as _RefractionTex</span><br>        <span class="hljs-comment">// 抓取得到的屏幕图像将被存储在该纹理中</span><br>        <span class="hljs-comment">// 注意：</span><br>        <span class="hljs-comment">//   如果声明了纹理，则Unity只会执行一次屏幕图像的抓取，即在第一次使用含有该指令的材质中，这样能够节省性能</span><br>        <span class="hljs-comment">//   如果没有声明纹理（GrabPass &#123;&#125;），则Unity会在每一次运行该指令时进行屏幕抓取，即允许不同的物体具有不同的屏幕图像</span><br>        <span class="hljs-comment">// 这取决于物体当时的渲染队列、颜色缓冲区等要素</span><br>GrabPass &#123; &quot;_RefractionTex&quot; &#125;<br><br>Pass &#123;<br>CGPROGRAM<br><br><span class="hljs-meta">#pragma vertex vert</span><br><span class="hljs-meta">#pragma fragment frag</span><br><br><span class="hljs-meta">#include &quot;UnityCG.cginc&quot;</span><br><br><span class="hljs-type">sampler2D</span> _MainTex;<br>float4 _MainTex_ST;<br><span class="hljs-type">sampler2D</span> _BumpMap;<br>float4 _BumpMap_ST;<br>samplerCUBE _Cubemap;<br><span class="hljs-type">float</span> _Distortion;<br>fixed _RefractAmount;<br>            <span class="hljs-comment">// 抓取得到的屏幕图像</span><br><span class="hljs-type">sampler2D</span> _RefractionTex;<br>            <span class="hljs-comment">// 上述纹理的纹素大小(1/width, 1/height)</span><br>float4 _RefractionTex_TexelSize;<br><br>struct a2v &#123;<br>float4 vertex : POSITION;<br>float3 normal : NORMAL;<br>float4 tangent : TANGENT; <br>float2 texcoord: TEXCOORD0;<br>&#125;;<br><br>struct v2f &#123;<br>float4 pos : SV_POSITION;<br>float4 scrPos : TEXCOORD0;<br>float4 uv : TEXCOORD1;<br>float4 TtoW0 : TEXCOORD2;  <br>    float4 TtoW1 : TEXCOORD3;  <br>    float4 TtoW2 : TEXCOORD4; <br>&#125;;<br><br>v2f vert (a2v v) &#123;<br>v2f o;<br>o.pos = UnityObjectToClipPos(v.vertex);<br><br>o.scrPos = ComputeGrabScreenPos(o.pos);<br><br>                <span class="hljs-comment">// 提取纹理坐标</span><br>o.uv.xy = TRANSFORM_TEX(v.texcoord, _MainTex);<br>o.uv.zw = TRANSFORM_TEX(v.texcoord, _BumpMap);<br><br>                <span class="hljs-comment">// 计算从切线空间变换到世界空间的矩阵</span><br>float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;  <br>fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);  <br>fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);  <br>fixed3 worldBinormal = <span class="hljs-built_in">cross</span>(worldNormal, worldTangent) * v.tangent.w; <br><br>o.TtoW0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);  <br>o.TtoW1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);  <br>o.TtoW2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);  <br><br><span class="hljs-keyword">return</span> o;<br>&#125;<br><br>fixed4 frag (v2f i) : SV_Target &#123;<br>float3 worldPos = float3(i.TtoW0.w, i.TtoW1.w, i.TtoW2.w);<br>fixed3 worldViewDir = <span class="hljs-built_in">normalize</span>(UnityWorldSpaceViewDir(worldPos));<br><br><span class="hljs-comment">// Get the normal in tangent space</span><br>fixed3 bump = UnpackNormal(tex2D(_BumpMap, i.uv.zw));<br><br><span class="hljs-comment">// Compute the offset in tangent space</span><br>float2 <span class="hljs-keyword">offset</span> = bump.xy * _Distortion * _RefractionTex_TexelSize.xy;<br>                <span class="hljs-comment">// 乘以i.srcPos.z可以让变形程度随着摄像机的远近发生变化</span><br>i.scrPos.xy = <span class="hljs-keyword">offset</span> * i.scrPos.z + i.scrPos.xy;<br>                <span class="hljs-comment">// 对srcPos进行透视除法得到真正的NDC</span><br>                <span class="hljs-comment">// 原因：</span><br>                <span class="hljs-comment">// 在顶点着色器中通过ComputeGrabScreenPos计算得到的坐标没有经过齐次除法，因为需要对xy进行正确插值</span><br>                <span class="hljs-comment">// 在经过插值后，我们手动进行透视除法，可以得到正确结果，该结果为NDC下坐标，此时可以被当作纹理坐标使用了</span><br>fixed3 refrCol = tex2D(_RefractionTex, i.scrPos.xy/i.scrPos.w).rgb;<br><br><span class="hljs-comment">// Convert the normal to world space</span><br>bump = <span class="hljs-built_in">normalize</span>(half3(<span class="hljs-built_in">dot</span>(i.TtoW0.xyz, bump), <span class="hljs-built_in">dot</span>(i.TtoW1.xyz, bump), <span class="hljs-built_in">dot</span>(i.TtoW2.xyz, bump)));<br>fixed3 reflDir = <span class="hljs-built_in">reflect</span>(-worldViewDir, bump);<br>fixed4 texColor = tex2D(_MainTex, i.uv.xy);<br>fixed3 reflCol = texCUBE(_Cubemap, reflDir).rgb * texColor.rgb;<br><br>fixed3 finalColor = reflCol * (<span class="hljs-number">1</span> - _RefractAmount) + refrCol * _RefractAmount;<br><br><span class="hljs-keyword">return</span> fixed4(finalColor, <span class="hljs-number">1</span>);<br>&#125;<br><br>ENDCG<br>&#125;<br>&#125;<br><br>FallBack &quot;Diffuse&quot;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="渲染纹理和GrabPass的比较"><a href="#渲染纹理和GrabPass的比较" class="headerlink" title="渲染纹理和GrabPass的比较"></a>渲染纹理和GrabPass的比较</h3><p>GrabPass:</p><ul><li>在Shader中编写相关指令，使用简单</li><li>效率上次于渲染纹理，特别是在移动设备上</li></ul><p>渲染纹理：</p><ul><li>首先需要创建一个渲染纹理和摄像机，然后摄像机计算得到渲染纹理后将纹理交给shader</li><li>可以自定义渲染纹理大小</li><li>可以通过调整摄像机的渲染层来减少二次渲染的场景大小</li><li>可以控制摄像机是否需要开启</li><li>移动设备优先使用该方法</li></ul><p>Unity的命令缓冲也能够得到类似于抓屏的效果，<a href="https://docs.unity3d.com/Manual/GraphicsCommandBuffers.html">Unity - Manual: Extending the Built-in Render Pipeline with CommandBuffers (unity3d.com)</a></p><h2 id="程序纹理"><a href="#程序纹理" class="headerlink" title="程序纹理"></a>程序纹理</h2><p>使用特定的算法来创建图案，可以更加自由地控制纹理外观和形状</p><h3 id="使用代码生成波点纹理"><a href="#使用代码生成波点纹理" class="headerlink" title="使用代码生成波点纹理"></a>使用代码生成波点纹理</h3><p>生成脚本：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><br><span class="hljs-comment">// 保证该脚本能够在编辑器模式下运行</span><br>[<span class="hljs-meta">ExecuteInEditMode</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ProceduralTextureGeneration</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br><br><span class="hljs-keyword">public</span> Material material = <span class="hljs-literal">null</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">region</span> Material properties</span><br>[<span class="hljs-meta">SerializeField, SetProperty(<span class="hljs-string">&quot;textureWidth&quot;</span>)</span>]<br><span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> m_textureWidth = <span class="hljs-number">512</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> textureWidth &#123;<br><span class="hljs-keyword">get</span> &#123;<br><span class="hljs-keyword">return</span> m_textureWidth;<br>&#125;<br><span class="hljs-keyword">set</span> &#123;<br>m_textureWidth = <span class="hljs-keyword">value</span>;<br>_UpdateMaterial();<br>&#125;<br>&#125;<br><br>[<span class="hljs-meta">SerializeField, SetProperty(<span class="hljs-string">&quot;backgroundColor&quot;</span>)</span>]<br><span class="hljs-keyword">private</span> Color m_backgroundColor = Color.white;<br><span class="hljs-keyword">public</span> Color backgroundColor &#123;<br><span class="hljs-keyword">get</span> &#123;<br><span class="hljs-keyword">return</span> m_backgroundColor;<br>&#125;<br><span class="hljs-keyword">set</span> &#123;<br>m_backgroundColor = <span class="hljs-keyword">value</span>;<br>_UpdateMaterial();<br>&#125;<br>&#125;<br><br>[<span class="hljs-meta">SerializeField, SetProperty(<span class="hljs-string">&quot;circleColor&quot;</span>)</span>]<br><span class="hljs-keyword">private</span> Color m_circleColor = Color.yellow;<br><span class="hljs-keyword">public</span> Color circleColor &#123;<br><span class="hljs-keyword">get</span> &#123;<br><span class="hljs-keyword">return</span> m_circleColor;<br>&#125;<br><span class="hljs-keyword">set</span> &#123;<br>m_circleColor = <span class="hljs-keyword">value</span>;<br>_UpdateMaterial();<br>&#125;<br>&#125;<br><br>[<span class="hljs-meta">SerializeField, SetProperty(<span class="hljs-string">&quot;blurFactor&quot;</span>)</span>]<br><span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> m_blurFactor = <span class="hljs-number">2.0f</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> blurFactor &#123;<br><span class="hljs-keyword">get</span> &#123;<br><span class="hljs-keyword">return</span> m_blurFactor;<br>&#125;<br><span class="hljs-keyword">set</span> &#123;<br>m_blurFactor = <span class="hljs-keyword">value</span>;<br>_UpdateMaterial();<br>&#125;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br><span class="hljs-keyword">private</span> Texture2D m_generatedTexture = <span class="hljs-literal">null</span>;<br><br><span class="hljs-comment">// Use this for initialization</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> ()</span> &#123;<br><span class="hljs-keyword">if</span> (material == <span class="hljs-literal">null</span>) &#123;<br>Renderer renderer = gameObject.GetComponent&lt;Renderer&gt;();<br><span class="hljs-keyword">if</span> (renderer == <span class="hljs-literal">null</span>) &#123;<br>Debug.LogWarning(<span class="hljs-string">&quot;Cannot find a renderer.&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br>material = renderer.sharedMaterial;<br>&#125;<br>_UpdateMaterial();<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> _UpdateMaterial() &#123;<br><span class="hljs-keyword">if</span> (material != <span class="hljs-literal">null</span>) &#123;<br>m_generatedTexture = _GenerateProceduralTexture();<br>material.SetTexture(<span class="hljs-string">&quot;_MainTex&quot;</span>, m_generatedTexture);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> Color _MixColor(Color color0, Color color1, <span class="hljs-built_in">float</span> mixFactor) &#123;<br>Color mixColor = Color.white;<br>mixColor.r = Mathf.Lerp(color0.r, color1.r, mixFactor);<br>mixColor.g = Mathf.Lerp(color0.g, color1.g, mixFactor);<br>mixColor.b = Mathf.Lerp(color0.b, color1.b, mixFactor);<br>mixColor.a = Mathf.Lerp(color0.a, color1.a, mixFactor);<br><span class="hljs-keyword">return</span> mixColor;<br>&#125;<br><br><span class="hljs-keyword">private</span> Texture2D _GenerateProceduralTexture() &#123;<br>Texture2D proceduralTexture = <span class="hljs-keyword">new</span> Texture2D(textureWidth, textureWidth);<br><br><span class="hljs-comment">// The interval between circles</span><br><span class="hljs-built_in">float</span> circleInterval = textureWidth / <span class="hljs-number">4.0f</span>;<br><span class="hljs-comment">// The radius of circles</span><br><span class="hljs-built_in">float</span> radius = textureWidth / <span class="hljs-number">10.0f</span>;<br><span class="hljs-comment">// The blur factor</span><br><span class="hljs-built_in">float</span> edgeBlur = <span class="hljs-number">1.0f</span> / blurFactor;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> w = <span class="hljs-number">0</span>; w &lt; textureWidth; w++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> h = <span class="hljs-number">0</span>; h &lt; textureWidth; h++) &#123;<br><span class="hljs-comment">// Initalize the pixel with background color</span><br>Color pixel = backgroundColor;<br><br><span class="hljs-comment">// Draw nine circles one by one</span><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++) &#123;<br><span class="hljs-comment">// Compute the center of current circle</span><br>Vector2 circleCenter = <span class="hljs-keyword">new</span> Vector2(circleInterval * (i + <span class="hljs-number">1</span>), circleInterval * (j + <span class="hljs-number">1</span>));<br><br><span class="hljs-comment">// Compute the distance between the pixel and the center</span><br><span class="hljs-built_in">float</span> dist = Vector2.Distance(<span class="hljs-keyword">new</span> Vector2(w, h), circleCenter) - radius;<br><br><span class="hljs-comment">// Blur the edge of the circle</span><br>Color color = _MixColor(circleColor, <span class="hljs-keyword">new</span> Color(pixel.r, pixel.g, pixel.b, <span class="hljs-number">0.0f</span>), Mathf.SmoothStep(<span class="hljs-number">0f</span>, <span class="hljs-number">1.0f</span>, dist * edgeBlur));<br><br><span class="hljs-comment">// Mix the current color with the previous color</span><br>pixel = _MixColor(pixel, color, color.a);<br>&#125;<br>&#125;<br><br>proceduralTexture.SetPixel(w, h, pixel);<br>&#125;<br>&#125;<br><br>proceduralTexture.Apply();<br><br><span class="hljs-keyword">return</span> proceduralTexture;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="Unity的程序材质"><a href="#Unity的程序材质" class="headerlink" title="Unity的程序材质"></a>Unity的程序材质</h3><p>使用<strong>Substance Designer</strong>来生成纹理，使用该程序纹理得到<strong>程序材质</strong>（Procedural Materials）</p><p>可以导入外部的程序纹理后，在Unity中调节出不同效果</p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>Shader</tag>
      
      <tag>Texture</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UnityShader-边缘检测</title>
    <link href="/2023/01/10/UnityShader-%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/"/>
    <url>/2023/01/10/UnityShader-%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="UnityShader-边缘检测"><a href="#UnityShader-边缘检测" class="headerlink" title="UnityShader-边缘检测"></a>UnityShader-边缘检测</h1><h2 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h2><p>卷积操作指使用一个<strong>卷积核</strong>(kernel)对一张图像中的每个像素进行一系列操作。卷积核通常是一个四方形的网格结构，该区域内的每个方格都有一个权重值，当对图像中的某个像素进行卷积时，会把卷积核的中心放置到该像素上，翻转核之后再依次计算核中每个元素和其覆盖的图像像素的乘积并求和，得到结果就是该点的新像素值</p><p><img src="/2023/01/10/UnityShader-%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/convolution.png" alt="convolution.png-15.1kB"></p><h2 id="基于像素差值的边缘判定"><a href="#基于像素差值的边缘判定" class="headerlink" title="基于像素差值的边缘判定"></a>基于像素差值的边缘判定</h2><p>如果相邻像素之间存在差别明显的颜色、亮度、纹理等属性，就认为他们之间应该有一条边界，这种像素之间的差值用<strong>梯度</strong>来表示</p><p><img src="/2023/01/10/UnityShader-%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/edge_detection_kernel.png" alt="edge_detection_kernel.png-19.8kB"></p><p>在进行边缘检测时，需要对每个像素分别进行一次卷积计算，得到两个方向的梯度值$$G_x$$和$$G_y$$，整体的梯度计算公式为：<br>$$<br>G &#x3D; \sqrt{G_x^2 + G_y^2}<br>$$<br>出于性能考虑，有时会使用绝对值操作来代替开根号操作：<br>$$<br>G &#x3D; \abs{G_x} + \abs{G_y}<br>$$<br>当得到梯度G后，可以设置一个特定的阈值，超过该阈值的像素判定为边缘；或者建立像素颜色和梯度值之间的函数映射关系，梯度值越大，像素叠加的边缘颜色越深</p><h2 id="使用Sobel算子实现"><a href="#使用Sobel算子实现" class="headerlink" title="使用Sobel算子实现"></a>使用Sobel算子实现</h2><p>shader的代码实现如下，有一个疑问点在于，如果像素位于图像边缘，如何计算超出图像范围的像素值，经过测试，超出的部分可能取得clamp环绕模式，原因如下：</p><ul><li>将i.uv[it] +&#x2F;- dx, dx &gt;&#x3D;1时，edge &#x3D; 1，即完全不影响原图，代表邻域中的像素颜色都是相同的</li><li>如果是repeat模式，则边缘检测的效果应该不会发生变化</li></ul><p>当然，另一种情况是采样的像素颜色全是非0值，但我人为上述解释的可能性更高</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs glsl">Shader &quot;Edge Detection&quot; &#123;<br>Properties &#123;<br>_MainTex (&quot;Base (RGB)&quot;, <span class="hljs-number">2</span>D) = &quot;white&quot; &#123;&#125;<br>_EdgeOnly (&quot;Edge Only&quot;, Float) = <span class="hljs-number">1.0</span><br>_EdgeColor (&quot;Edge Color&quot;, Color) = (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)<br>_BackgroundColor (&quot;Background Color&quot;, Color) = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>&#125;<br>SubShader &#123;<br>Pass &#123;  <br><span class="hljs-comment">// 屏幕后处理的标准设置</span><br>ZTest Always Cull Off ZWrite Off<br><br>CGPROGRAM<br><br><span class="hljs-meta">#include &quot;UnityCG.cginc&quot;</span><br><br><span class="hljs-meta">#pragma vertex vert  </span><br><span class="hljs-meta">#pragma fragment fragSobel</span><br><br><span class="hljs-type">sampler2D</span> _MainTex;  <br><span class="hljs-comment">// xxx_TexcelSize是Unity提供的访问xxx纹理对应的每个纹素的大小</span><br><span class="hljs-comment">// 大小为SxS的纹理的该值大约为1/S</span><br><span class="hljs-keyword">uniform</span> half4 _MainTex_TexelSize;<br><span class="hljs-comment">// 当_EdgeOnly为0时，边缘会叠加在原渲染图像上;当edgesOnly为1时，只会显示边缘，不显示原渲染图像</span><br>fixed _EdgeOnly;<br>fixed4 _EdgeColor;<br>fixed4 _BackgroundColor;<br><br>struct v2f &#123;<br>float4 pos : SV_POSITION;<br><span class="hljs-comment">// 存储自身及其邻域的纹理坐标</span><br>half2 uv[<span class="hljs-number">9</span>] : TEXCOORD0;<br>&#125;;<br>  <br>v2f vert(appdata_img v) &#123;<br>v2f o;<br>o.pos = UnityObjectToClipPos(v.vertex);<br><br>half2 uv = v.texcoord;<br><br>o.uv[<span class="hljs-number">0</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>);<br>o.uv[<span class="hljs-number">1</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>);<br>o.uv[<span class="hljs-number">2</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br>o.uv[<span class="hljs-number">3</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>o.uv[<span class="hljs-number">4</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>o.uv[<span class="hljs-number">5</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>o.uv[<span class="hljs-number">6</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>);<br>o.uv[<span class="hljs-number">7</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>o.uv[<span class="hljs-number">8</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br> <br><span class="hljs-keyword">return</span> o;<br>&#125;<br><br><span class="hljs-comment">// 计算亮度值</span><br>fixed luminance(fixed4 color) &#123;<br><span class="hljs-keyword">return</span>  <span class="hljs-number">0.2125</span> * color.r + <span class="hljs-number">0.7154</span> * color.g + <span class="hljs-number">0.0721</span> * color.b; <br>&#125;<br><br>half Sobel(v2f i) &#123;<br><span class="hljs-keyword">const</span> half Gx[<span class="hljs-number">9</span>] = &#123;<span class="hljs-number">-1</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,<br><span class="hljs-number">-2</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">2</span>,<br><span class="hljs-number">-1</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>&#125;;<br><span class="hljs-keyword">const</span> half Gy[<span class="hljs-number">9</span>] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">-1</span>,<br><span class="hljs-number">0</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">0</span>,<br><span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">1</span>&#125;;<br><br>half texColor;<br>half edgeX = <span class="hljs-number">0</span>;<br>half edgeY = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> it = <span class="hljs-number">0</span>; it &lt; <span class="hljs-number">9</span>; it++) &#123;<br><span class="hljs-comment">// 超出的部分可能取得clamp环绕模式，原因如下：</span><br><span class="hljs-comment">// 将i.uv[it] +/- dx, dx &gt;=1时，edge = 1，即完全不影响原图，代表邻域中的像素颜色都是相同的</span><br><span class="hljs-comment">// 如果是repeat模式，则边缘检测的效果应该不会发生变化</span><br>texColor = luminance(tex2D(_MainTex, i.uv[it]));<br>edgeX += texColor * Gx[it];<br>edgeY += texColor * Gy[it];<br>&#125;<br><br><span class="hljs-comment">// 1减去水平方向和垂直方向梯度值的绝对值，得到edge，edge越小，表明该位置越可能是一个边缘点</span><br>half edge = <span class="hljs-number">1</span> - <span class="hljs-built_in">abs</span>(edgeX) - <span class="hljs-built_in">abs</span>(edgeY);<br><br><span class="hljs-keyword">return</span> edge;<br>&#125;<br><br>fixed4 fragSobel(v2f i) : SV_Target &#123;<br><span class="hljs-comment">// 获得梯度值</span><br>half edge = Sobel(i);<br><br><span class="hljs-comment">// 计算背景为原图像时的颜色值</span><br>fixed4 withEdgeColor = lerp(_EdgeColor, tex2D(_MainTex, i.uv[<span class="hljs-number">4</span>]), edge);<br><span class="hljs-comment">// 计算背景为自行设置背景时的颜色值</span><br>fixed4 onlyEdgeColor = lerp(_EdgeColor, _BackgroundColor, edge);<br><span class="hljs-comment">// 根据EdgeOnly进行插值，以决定背景的实际颜色</span><br><span class="hljs-keyword">return</span> lerp(withEdgeColor, onlyEdgeColor, _EdgeOnly);<br> &#125;<br><br>ENDCG<br>&#125; <br>&#125;<br><span class="hljs-comment">// 不使用其它着色器</span><br>FallBack Off<br>&#125;<br><br></code></pre></td></tr></table></figure><p>挂载在脚本上的代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> System.Collections;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">EdgeDetection</span> : <span class="hljs-title">PostEffectsBase</span> &#123;<br><br><span class="hljs-keyword">public</span> Shader edgeDetectShader;<br><span class="hljs-keyword">private</span> Material edgeDetectMaterial = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">public</span> Material material &#123;  <br><span class="hljs-keyword">get</span> &#123;<br>edgeDetectMaterial = CheckShaderAndCreateMaterial(edgeDetectShader, edgeDetectMaterial);<br><span class="hljs-keyword">return</span> edgeDetectMaterial;<br>&#125;  <br>&#125;<br><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 当_EdgeOnly为0时，边缘会叠加在原渲染图像上;当edgesOnly为1时，只会显示边缘，不显示原渲染图像</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>[<span class="hljs-meta">Range(0.0f, 1.0f)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> edgesOnly = <span class="hljs-number">0.0f</span>;<br><br><span class="hljs-keyword">public</span> Color edgeColor = Color.black;<br><br><span class="hljs-keyword">public</span> Color backgroundColor = Color.white;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnRenderImage</span> (<span class="hljs-params">RenderTexture src, RenderTexture dest</span>)</span> &#123;<br><span class="hljs-keyword">if</span> (material != <span class="hljs-literal">null</span>) &#123;<br>material.SetFloat(<span class="hljs-string">&quot;_EdgeOnly&quot;</span>, edgesOnly);<br>material.SetColor(<span class="hljs-string">&quot;_EdgeColor&quot;</span>, edgeColor);<br>material.SetColor(<span class="hljs-string">&quot;_BackgroundColor&quot;</span>, backgroundColor);<br><br>Graphics.Blit(src, dest, material);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>Graphics.Blit(src, dest);<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="基于深度和法线的边缘检测"><a href="#基于深度和法线的边缘检测" class="headerlink" title="基于深度和法线的边缘检测"></a>基于深度和法线的边缘检测</h2><p>以上方法存在许多缺陷，原因在于，单纯使用颜色信息得到的边缘并不一定真的是世界空间中物体的边缘，如果某个表面上有许多色彩差异较大的色块，依然会被错误地判定为边缘</p><p>更好的解决办法是，使用深度和法线纹理进行边缘检测，这样，图像不会受到纹理和光照的影响</p><h2 id="使用Roberts算子实现"><a href="#使用Roberts算子实现" class="headerlink" title="使用Roberts算子实现"></a>使用Roberts算子实现</h2><p>Roberts算子的使用：计算左上角和右下角的差值，乘以右上角和左下角的差值，作为评估边缘的依据。本实现中，我们会取对角方向的深度或者法线值，比较它们之间的差值，如果超过某个阈值，就认为它们之间存在一条边</p><p>shader的代码如下：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs glsl">Shader &quot;Edge Detection Normals And Depth&quot; &#123;<br>Properties &#123;<br>_MainTex (&quot;Base (RGB)&quot;, <span class="hljs-number">2</span>D) = &quot;white&quot; &#123;&#125;<br>_EdgeOnly (&quot;Edge Only&quot;, Float) = <span class="hljs-number">1.0</span><br>_EdgeColor (&quot;Edge Color&quot;, Color) = (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)<br>_BackgroundColor (&quot;Background Color&quot;, Color) = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>_SampleDistance (&quot;Sample Distance&quot;, Float) = <span class="hljs-number">1.0</span><br>_Sensitivity (&quot;Sensitivity&quot;, Vector) = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>&#125;<br>SubShader &#123;<br>CGINCLUDE<br><br><span class="hljs-meta">#include &quot;UnityCG.cginc&quot;</span><br><br><span class="hljs-type">sampler2D</span> _MainTex;<br>half4 _MainTex_TexelSize;<br>fixed _EdgeOnly;<br>fixed4 _EdgeColor;<br>fixed4 _BackgroundColor;<br><span class="hljs-comment">// 控制对深度+法线纹理采样时，使用的采样距离，sampleDistance越大，描边越宽</span><br><span class="hljs-type">float</span> _SampleDistance;<br><span class="hljs-comment">// x分量存放法线阈值，y分量存放深度阈值</span><br>half4 _Sensitivity;<br><br><span class="hljs-type">sampler2D</span> _CameraDepthNormalsTexture;<br><br>struct v2f &#123;<br>float4 pos : SV_POSITION;<br>half2 uv[<span class="hljs-number">5</span>]: TEXCOORD0;<br>&#125;;<br>  <br>v2f vert(appdata_img v) &#123;<br>v2f o;<br>o.pos = UnityObjectToClipPos(v.vertex);<br><br>half2 uv = v.texcoord;<br>o.uv[<span class="hljs-number">0</span>] = uv;<br><br><span class="hljs-meta">#if UNITY_UV_STARTS_AT_TOP</span><br><span class="hljs-keyword">if</span> (_MainTex_TexelSize.y &lt; <span class="hljs-number">0</span>)<br>uv.y = <span class="hljs-number">1</span> - uv.y;<br><span class="hljs-meta">#endif</span><br><br>o.uv[<span class="hljs-number">1</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>) * _SampleDistance;<br>o.uv[<span class="hljs-number">2</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>) * _SampleDistance;<br>o.uv[<span class="hljs-number">3</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>) * _SampleDistance;<br>o.uv[<span class="hljs-number">4</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>) * _SampleDistance;<br> <br><span class="hljs-keyword">return</span> o;<br>&#125;<br><br>half CheckSame(half4 center, half4 <span class="hljs-keyword">sample</span>) &#123;<br><span class="hljs-comment">// 直接使用了xy分量，因为只需要比较两个值之间的差异度</span><br>half2 centerNormal = center.xy;<br><span class="hljs-type">float</span> centerDepth = DecodeFloatRG(center.zw);<br>half2 sampleNormal = <span class="hljs-keyword">sample</span>.xy;<br><span class="hljs-type">float</span> sampleDepth = DecodeFloatRG(<span class="hljs-keyword">sample</span>.zw);<br><br><span class="hljs-comment">// difference in normals</span><br><span class="hljs-comment">// do not bother decoding normals - there&#x27;s no need here</span><br>half2 diffNormal = <span class="hljs-built_in">abs</span>(centerNormal - sampleNormal) * _Sensitivity.x;<br><span class="hljs-type">int</span> isSameNormal = (diffNormal.x + diffNormal.y) &lt; <span class="hljs-number">0.1</span>;<br><span class="hljs-comment">// difference in depth</span><br><span class="hljs-type">float</span> diffDepth = <span class="hljs-built_in">abs</span>(centerDepth - sampleDepth) * _Sensitivity.y;<br><span class="hljs-comment">// scale the required threshold by the distance</span><br><span class="hljs-type">int</span> isSameDepth = diffDepth &lt; <span class="hljs-number">0.1</span> * centerDepth;<br><br><span class="hljs-comment">// return:</span><br><span class="hljs-comment">// 1 - if normals and depth are similar enough</span><br><span class="hljs-comment">// 0 - otherwise</span><br><span class="hljs-keyword">return</span> isSameNormal * isSameDepth ? <span class="hljs-number">1.0</span> : <span class="hljs-number">0.0</span>;<br>&#125;<br><br>fixed4 fragRobertsCrossDepthAndNormal(v2f i) : SV_Target &#123;<br>half4 sample1 = tex2D(_CameraDepthNormalsTexture, i.uv[<span class="hljs-number">1</span>]);<br>half4 sample2 = tex2D(_CameraDepthNormalsTexture, i.uv[<span class="hljs-number">2</span>]);<br>half4 sample3 = tex2D(_CameraDepthNormalsTexture, i.uv[<span class="hljs-number">3</span>]);<br>half4 sample4 = tex2D(_CameraDepthNormalsTexture, i.uv[<span class="hljs-number">4</span>]);<br><br>half edge = <span class="hljs-number">1.0</span>;<br><br>edge *= CheckSame(sample1, sample2);<br>edge *= CheckSame(sample3, sample4);<br><br>fixed4 withEdgeColor = lerp(_EdgeColor, tex2D(_MainTex, i.uv[<span class="hljs-number">0</span>]), edge);<br>fixed4 onlyEdgeColor = lerp(_EdgeColor, _BackgroundColor, edge);<br><br><span class="hljs-keyword">return</span> lerp(withEdgeColor, onlyEdgeColor, _EdgeOnly);<br>&#125;<br><br>ENDCG<br><br>Pass &#123; <br>ZTest Always Cull Off ZWrite Off<br><br>CGPROGRAM      <br><br><span class="hljs-meta">#pragma vertex vert  </span><br><span class="hljs-meta">#pragma fragment fragRobertsCrossDepthAndNormal</span><br><br>ENDCG  <br>&#125;<br>&#125; <br>FallBack Off<br>&#125;<br></code></pre></td></tr></table></figure><p>挂载到相机上的脚本如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> System.Collections;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">EdgeDetectNormalsAndDepth</span> : <span class="hljs-title">PostEffectsBase</span> &#123;<br><br><span class="hljs-keyword">public</span> Shader edgeDetectShader;<br><span class="hljs-keyword">private</span> Material edgeDetectMaterial = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">public</span> Material material &#123;  <br><span class="hljs-keyword">get</span> &#123;<br>edgeDetectMaterial = CheckShaderAndCreateMaterial(edgeDetectShader, edgeDetectMaterial);<br><span class="hljs-keyword">return</span> edgeDetectMaterial;<br>&#125;  <br>&#125;<br><br>[<span class="hljs-meta">Range(0.0f, 1.0f)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> edgesOnly = <span class="hljs-number">0.0f</span>;<br><br><span class="hljs-keyword">public</span> Color edgeColor = Color.black;<br><br><span class="hljs-keyword">public</span> Color backgroundColor = Color.white;<br><span class="hljs-comment">// 控制对深度+法线纹理采样时，使用的采样距离，sampleDistance越大，描边越宽</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> sampleDistance = <span class="hljs-number">1.0f</span>;<br><br><span class="hljs-comment">// 影响当邻域的深度值相差多少时，认为存在一条边界，等于0表示不受深度影响</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> sensitivityDepth = <span class="hljs-number">1.0f</span>;<br><span class="hljs-comment">// 影响当邻域的法线值相差多少时，认为存在一条边界，等于0表示不受法线影响</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> sensitivityNormals = <span class="hljs-number">1.0f</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnEnable</span>()</span> &#123;<br>GetComponent&lt;Camera&gt;().depthTextureMode |= DepthTextureMode.DepthNormals;<br>&#125;<br><br><span class="hljs-comment">// 声明该属性代表该函数不会对透明物体产生影响，即透明物体不会被描边</span><br>[<span class="hljs-meta">ImageEffectOpaque</span>]<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnRenderImage</span> (<span class="hljs-params">RenderTexture src, RenderTexture dest</span>)</span> &#123;<br><span class="hljs-keyword">if</span> (material != <span class="hljs-literal">null</span>) &#123;<br>material.SetFloat(<span class="hljs-string">&quot;_EdgeOnly&quot;</span>, edgesOnly);<br>material.SetColor(<span class="hljs-string">&quot;_EdgeColor&quot;</span>, edgeColor);<br>material.SetColor(<span class="hljs-string">&quot;_BackgroundColor&quot;</span>, backgroundColor);<br>material.SetFloat(<span class="hljs-string">&quot;_SampleDistance&quot;</span>, sampleDistance);<br>material.SetVector(<span class="hljs-string">&quot;_Sensitivity&quot;</span>, <span class="hljs-keyword">new</span> Vector4(sensitivityNormals, sensitivityDepth, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>));<br><br>Graphics.Blit(src, dest, material);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>Graphics.Blit(src, dest);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="对特定物体的描边"><a href="#对特定物体的描边" class="headerlink" title="对特定物体的描边"></a>对特定物体的描边</h2><p>如果只想对某个物体描边，可以使用Graphics.DrawMesh或者Graphics.DrawMeshNow函数把需要描边的物体再渲染一遍（在所有不透明物体渲染完毕之后），然后使用边缘检测算法计算每个像素的梯度值，判断是否小于某个阈值，如果是，则在Shader中使用clip()函数将该像素剔除掉，从而获得原来的物体颜色</p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>Shader</tag>
      
      <tag>postprocess</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity-协程</title>
    <link href="/2023/01/10/Unity-%E5%8D%8F%E7%A8%8B/"/>
    <url>/2023/01/10/Unity-%E5%8D%8F%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Unity-协程"><a href="#Unity-协程" class="headerlink" title="Unity-协程"></a>Unity-协程</h1><h2 id="基本使用方法"><a href="#基本使用方法" class="headerlink" title="基本使用方法"></a>基本使用方法</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function">IEnumerator <span class="hljs-title">CoroutineFunc</span>()</span><br>&#123;<br>    code...;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> ...;<br>    code...;<br>&#125;<br><br>StartCoroutine(CoroutineFunc);<br>StopCoroutine(CoroutineFunc);<br></code></pre></td></tr></table></figure><p>函数会在<code>yield return</code>处停止，并把控制权转交给<code>Unity</code>，但会在下一帧中继续执行，如果想要提前结束的话则调用<code>yield break</code></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Unity的协程是基于C#的迭代器实现的，但主要是C#2之后的迭代器</p><p>在C#1中，想要使用<code>foreach</code>关键字遍历某个对象，需要先让该对象实现<code>IEnumerable</code>的接口，同时还要实现一个迭代器类</p><p>在C#2中，引入了迭代块语句<code>yield return</code>来简化上述过程，程序员只需要实现1个返回参数类型为<code>IEnumerator</code>的函数即可获得C#1中用两个类实现的相同的效果，例如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">static</span> IEnumerator <span class="hljs-title">GetEnumerator</span>()</span><br>&#123;<br>    <span class="hljs-built_in">int</span> arr[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>    &#123;<br>        <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> arr[i];<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// in main</span><br><span class="hljs-keyword">foreach</span>(<span class="hljs-function"><span class="hljs-built_in">int</span> a <span class="hljs-keyword">in</span> <span class="hljs-title">GetEnumerator</span>())</span><br>&#123;<br>    <span class="hljs-comment">// do something..</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过反编译可执行文件可以发现，我们编写的函数在编译器处理过后已经完全不再是一个函数了，特别是其中的<code>yield return</code>语句，和一般函数中的<code>return</code>语句完全不同，另外，函数中所有的局部变量都变成了生成迭代器类中的全局变量，可以通过反编译代码验证这一点。</p><p>假设C#源代码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">net</span><br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            <span class="hljs-keyword">foreach</span>(<span class="hljs-function"><span class="hljs-built_in">int</span> i <span class="hljs-keyword">in</span> <span class="hljs-title">GetEnumerator</span>())</span><br>            &#123;<br>                <br>            &#125;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">static</span> IEnumerable&lt;Int32&gt; <span class="hljs-title">GetEnumerator</span>()</span><br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>            &#123;<br>                <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> i;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>经过反编译后得到如下结果：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.Diagnostics;<br><span class="hljs-keyword">using</span> System.Runtime.CompilerServices;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">net</span><br>&#123;<br><span class="hljs-comment">// Token: 0x02000002 RID: 2</span><br><span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span><br>&#123;<br><span class="hljs-comment">// Token: 0x06000001 RID: 1 RVA: 0x00002050 File Offset: 0x00000250</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>&#123;<br><span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">int</span> i <span class="hljs-keyword">in</span> HelloWorld.GetEnumerator())<br>&#123;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Token: 0x06000002 RID: 2 RVA: 0x0000209C File Offset: 0x0000029C</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> IEnumerable&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-title">GetEnumerator</span>()</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HelloWorld.&lt;GetEnumerator&gt;d__1(<span class="hljs-number">-2</span>);<br>&#125;<br><br><span class="hljs-comment">// Token: 0x02000003 RID: 3</span><br>[<span class="hljs-meta">CompilerGenerated</span>]<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> &lt;<span class="hljs-title">GetEnumerator</span>&gt;<span class="hljs-title">d__1</span> : <span class="hljs-title">IEnumerable</span>&lt;<span class="hljs-title">int</span>&gt;, <span class="hljs-title">IEnumerable</span>, <span class="hljs-title">IEnumerator</span>&lt;<span class="hljs-title">int</span>&gt;, <span class="hljs-title">IEnumerator</span>, <span class="hljs-title">IDisposable</span><br>&#123;<br><span class="hljs-comment">// Token: 0x06000004 RID: 4 RVA: 0x000020AE File Offset: 0x000002AE</span><br>[<span class="hljs-meta">DebuggerHidden</span>]<br><span class="hljs-keyword">public</span> &lt;GetEnumerator&gt;d__1(<span class="hljs-built_in">int</span> &lt;&gt;<span class="hljs-number">1</span>__state)<br>&#123;<br><span class="hljs-keyword">this</span>.&lt;&gt;<span class="hljs-number">1</span>__state = &lt;&gt;<span class="hljs-number">1</span>__state;<br><span class="hljs-keyword">this</span>.&lt;&gt;l__initialThreadId = Environment.CurrentManagedThreadId;<br>&#125;<br><br><span class="hljs-comment">// Token: 0x06000005 RID: 5 RVA: 0x000020C9 File Offset: 0x000002C9</span><br>[<span class="hljs-meta">DebuggerHidden</span>]<br><span class="hljs-keyword">void</span> IDisposable.Dispose()<br>&#123;<br>&#125;<br><br><span class="hljs-comment">// Token: 0x06000006 RID: 6 RVA: 0x000020CC File Offset: 0x000002CC</span><br><span class="hljs-built_in">bool</span> IEnumerator.MoveNext()<br>&#123;<br><span class="hljs-built_in">int</span> num = <span class="hljs-keyword">this</span>.&lt;&gt;<span class="hljs-number">1</span>__state;<br><span class="hljs-keyword">if</span> (num != <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (num != <span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">this</span>.&lt;&gt;<span class="hljs-number">1</span>__state = <span class="hljs-number">-1</span>;<br><span class="hljs-built_in">int</span> num2 = <span class="hljs-keyword">this</span>.&lt;i&gt;<span class="hljs-number">5</span>__1;<br><span class="hljs-keyword">this</span>.&lt;i&gt;<span class="hljs-number">5</span>__1 = num2 + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">this</span>.&lt;&gt;<span class="hljs-number">1</span>__state = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">this</span>.&lt;i&gt;<span class="hljs-number">5</span>__1 = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.&lt;i&gt;<span class="hljs-number">5</span>__1 &gt;= <span class="hljs-number">10</span>)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">this</span>.&lt;&gt;<span class="hljs-number">2</span>__current = <span class="hljs-keyword">this</span>.&lt;i&gt;<span class="hljs-number">5</span>__1;<br><span class="hljs-keyword">this</span>.&lt;&gt;<span class="hljs-number">1</span>__state = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// Token: 0x17000001 RID: 1</span><br><span class="hljs-comment">// (get) Token: 0x06000007 RID: 7 RVA: 0x0000213F File Offset: 0x0000033F</span><br><span class="hljs-built_in">int</span> IEnumerator&lt;<span class="hljs-built_in">int</span>&gt;.Current<br>&#123;<br>[<span class="hljs-meta">DebuggerHidden</span>]<br><span class="hljs-keyword">get</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.&lt;&gt;<span class="hljs-number">2</span>__current;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Token: 0x06000008 RID: 8 RVA: 0x00002147 File Offset: 0x00000347</span><br>[<span class="hljs-meta">DebuggerHidden</span>]<br><span class="hljs-keyword">void</span> IEnumerator.Reset()<br>&#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotSupportedException();<br>&#125;<br><br><span class="hljs-comment">// Token: 0x17000002 RID: 2</span><br><span class="hljs-comment">// (get) Token: 0x06000009 RID: 9 RVA: 0x0000214E File Offset: 0x0000034E</span><br><span class="hljs-built_in">object</span> IEnumerator.Current<br>&#123;<br>[<span class="hljs-meta">DebuggerHidden</span>]<br><span class="hljs-keyword">get</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.&lt;&gt;<span class="hljs-number">2</span>__current;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Token: 0x0600000A RID: 10 RVA: 0x0000215C File Offset: 0x0000035C</span><br>[<span class="hljs-meta">DebuggerHidden</span>]<br>IEnumerator&lt;<span class="hljs-built_in">int</span>&gt; IEnumerable&lt;<span class="hljs-built_in">int</span>&gt;.GetEnumerator()<br>&#123;<br>HelloWorld.&lt;GetEnumerator&gt;d__1 result;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.&lt;&gt;<span class="hljs-number">1</span>__state == <span class="hljs-number">-2</span> &amp;&amp; <span class="hljs-keyword">this</span>.&lt;&gt;l__initialThreadId == Environment.CurrentManagedThreadId)<br>&#123;<br><span class="hljs-keyword">this</span>.&lt;&gt;<span class="hljs-number">1</span>__state = <span class="hljs-number">0</span>;<br>result = <span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>result = <span class="hljs-keyword">new</span> HelloWorld.&lt;GetEnumerator&gt;d__1(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-comment">// Token: 0x0600000B RID: 11 RVA: 0x00002193 File Offset: 0x00000393</span><br>[<span class="hljs-meta">DebuggerHidden</span>]<br>IEnumerator IEnumerable.GetEnumerator()<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.System.Collections.Generic.IEnumerable&lt;System.Int32&gt;.GetEnumerator();<br>&#125;<br><br><span class="hljs-comment">// Token: 0x04000001 RID: 1</span><br><span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> &lt;&gt;<span class="hljs-number">1</span>__state;<br><br><span class="hljs-comment">// Token: 0x04000002 RID: 2</span><br><span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> &lt;&gt;<span class="hljs-number">2</span>__current;<br><br><span class="hljs-comment">// Token: 0x04000003 RID: 3</span><br><span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> &lt;&gt;l__initialThreadId;<br><br><span class="hljs-comment">// Token: 0x04000004 RID: 4</span><br><span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> &lt;i&gt;<span class="hljs-number">5</span>__1;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以发现，该函数被完全处理成了一个新的内部类，名称为<code>&lt;GetEnumerator&gt;d__1</code>， 其中，局部变量<code>i</code>变成了<code>&lt;i&gt;5__1</code>， 又增加了3个新的变量，其中<code>&lt;&gt;1__state</code>记录对象的当前状态，<code>&lt;&gt;2__current</code>记录下一个要返回的值，<code>&lt;&gt;1__initialThreadId</code>记录当前线程<code>Id</code>。</p><p>同时，这个生成类变成了一个类似于状态机的东西，它将原来的局部变量作为状态机的上下文环境，将原本的代码逻辑按照复杂的规则转换成状态机中状态之间的切换，实现在<code>MoveNext</code>函数中，这样，在主函数完成对<code>MoveNext</code>的一次调用后，并不会丢失函数中声明的局部变量，同时也不会导致线程阻塞，有些类似于操作系统中的进程调度，这正是设计协程的良好框架！</p><p>但是，由于该方法需要将局部变量存储在堆中，如果频繁开启协程，则会申请大量空间，造成时间和空间上的巨大浪费，因此要谨慎使用协程，尽量不要在<code>Update</code>函数中每帧开启协程，并且大部分情况下这种代码逻辑是有问题的。</p><h2 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h2><p>虽然不知道微软使用了什么样的规则将包含<code>yield</code>的函数翻译成迭代器类，但是我们可以直接写一个迭代器类来实现相同的效果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;conio.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">using</span> Ref = shared_ptr&lt;T&gt;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> id = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> id++;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Enumerator</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Enumerator</span>():<span class="hljs-built_in">state</span>(<span class="hljs-number">-1</span>), <span class="hljs-built_in">val</span>(<span class="hljs-number">10</span>), <span class="hljs-built_in">ID</span>(<span class="hljs-built_in">getId</span>()), <span class="hljs-built_in">timer</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">current</span>(<span class="hljs-number">0</span>)<br>    &#123;<br><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">MoveNext</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-type">int</span> state;<br><br>    <span class="hljs-type">int</span> ID;<br>    <span class="hljs-type">int</span> val;<br><br>    <span class="hljs-type">int</span> timer;<br><br>    <span class="hljs-type">int</span> current;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Coroutine</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Update</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Add</span><span class="hljs-params">(Ref&lt;Enumerator&gt; Etr)</span></span>;<br><br>    vector&lt; Ref&lt;Enumerator&gt; &gt; Etrs;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> ch;<br>    Coroutine Crt;<br>    <br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        Crt.<span class="hljs-built_in">Update</span>();<br>        <span class="hljs-keyword">if</span>(_kbhit())<br>        &#123;<br>            <span class="hljs-keyword">if</span>((ch = _getch()) == <span class="hljs-string">&#x27;w&#x27;</span>)<br>            &#123;<br>                Crt.<span class="hljs-built_in">Add</span>(<span class="hljs-built_in">make_shared</span>&lt;Enumerator&gt;());<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Enumerator::MoveNext</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">switch</span>(state)<br>    &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">-1</span>:<br>            cout &lt;&lt; ID &lt;&lt; <span class="hljs-string">&quot; start!\n&quot;</span>;<br>            state = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">while</span>(val &gt;= <span class="hljs-number">0</span>)<br>            &#123;<br>                cout &lt;&lt; ID &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; val &lt;&lt; endl;<br>                val -= <span class="hljs-number">1</span>;<br><br>                state = <span class="hljs-number">2</span>;<br>                timer = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            state = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            cout &lt;&lt; ID &lt;&lt; <span class="hljs-string">&quot; end!\n&quot;</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">for</span>(; timer &lt; <span class="hljs-number">10000</span>;)<br>            &#123;<br>                timer++;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            state = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Coroutine::Add</span><span class="hljs-params">(Ref&lt;Enumerator&gt; Etr)</span></span><br><span class="hljs-function"></span>&#123;<br>    Etrs.<span class="hljs-built_in">push_back</span>(Etr);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Coroutine::Update</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; Etrs.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        Enumerator* Etr = Etrs[i].<span class="hljs-built_in">get</span>();<br>        <span class="hljs-keyword">if</span>(!Etr-&gt;<span class="hljs-built_in">MoveNext</span>())<br>        &#123;<br>            Etrs.<span class="hljs-built_in">erase</span>(Etrs.<span class="hljs-built_in">begin</span>() + i);<br>            i--;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在以上程序中，<code>Enumerator</code>为迭代器类，其<code>MoveNext</code>输出一个整数，并随着迭代次数不断减少。 <code>Coroutine</code>为管理协程的类，当按下<code>w</code>键时，程序向其中添加一个迭代器对象，<code>Coroutine</code>对象会在主线程中每帧更新所有迭代器对象，直到该对象迭代完成，将其弹出</p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>协程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity-Animation</title>
    <link href="/2023/01/10/Unity-Animation/"/>
    <url>/2023/01/10/Unity-Animation/</url>
    
    <content type="html"><![CDATA[<h1 id="Unity-Animation"><a href="#Unity-Animation" class="headerlink" title="Unity-Animation"></a>Unity-Animation</h1><h2 id="Editor"><a href="#Editor" class="headerlink" title="Editor"></a>Editor</h2><ol><li><p>动画片段集(Animation Clips)</p><p>动画数据被存放在动画片段集中，如人物的跑动、跳跃，路灯的亮度变化等数据。动画片段集分为两个部分：</p><ul><li><p>Values：某个属性的值</p></li><li><p>Bindings：该动画片段集绑定的对象物体的属性，如位置，旋转，光照强度等</p><p><img src="/2023/01/10/Unity-Animation/image-20210628231944021.png" alt="image-20210628231944021"></p></li></ul></li><li><p>编辑窗口</p><p>注：动画只有附着在一个具体的游戏对象上（该动画有上下文）才可以被编辑关键帧</p><ul><li><p>改变时间线显示单位：可调整为秒单位或帧单位，如下图展开菜单栏的前两项</p><p><img src="/2023/01/10/Unity-Animation/151645b8-1c94-49ba-8f91-a545fa02b0d9_image19.png" alt="img"></p></li><li><p>显示帧数：需要先勾选Show Sample Rate（如上图），表示1秒内显示多少帧，如下图Samples的位置</p><p><img src="/2023/01/10/Unity-Animation/image-20210628235432991.png" alt="image-20210628235432991"></p></li><li><p>预览模式(Preview Mode)：</p><p><img src="/2023/01/10/Unity-Animation/image-20210629000628052.png" alt="image-20210629000628052"></p><p>该模式下，时间线和属性会蓝色高亮，该模式用于编辑关键帧</p></li><li><p>记录模式(Record Mode)：</p><p><img src="/2023/01/10/Unity-Animation/image-20210629000708338.png" alt="image-20210629000708338"></p><p>进入模式后，时间线会变红，在该模式下添加的任何绑定、关键帧、曲线的修改都会被记录到动画中，可用于自行添加关键帧</p></li><li><p>切换Animation Clips:</p><p><img src="/2023/01/10/Unity-Animation/99348067-460f-4513-96b2-3f17387ae2e0_image14.png" alt="img"></p><p>可以在当前的Animator中新建Clip，也可以切换到已存在的一个Clips上编辑</p></li><li><p>筛选动画曲线：</p><p>点击下图中的按钮后，左栏只会显示游戏对象中存在的绑定</p><p><img src="/2023/01/10/Unity-Animation/dfa36069-8cbe-428e-87f5-f37d24f9404b_image5.png" alt="img"></p></li><li><p>添加关键帧和事件：</p><p><img src="/2023/01/10/Unity-Animation/9d403922-3988-490e-ae4f-85cdf429cf7d_image20.png" alt="img"></p><p>在选定的帧点击创建事件按钮后，就可以设置动画事件，如果该动画具有上下文，则直接选择脚本中的函数</p></li><li><p>Dopesheet Mode:</p><p>只会显示绑定量在某个时间结点是否有关键帧</p></li><li><p>Curves Mode:</p><p>能够显示每一帧的属性值</p><p>曲线编辑模式如下图：</p><p><img src="/2023/01/10/Unity-Animation/be53f113-d521-4685-99f0-f84ff4f4c497_image12.png" alt="img"></p><ul><li>Clamped Auto：平滑接近关键帧</li><li>Free Smooth: 自由编辑曲线<ul><li>Flat: 曲线的切线时水平的</li></ul></li><li>Broken: 左右的切线不平行<ul><li>Free：自由编辑</li><li>Linear：相邻关键帧用直线连接</li><li>Constant：保持前一个关键帧的值不变，直到下一个关键帧发生突变，图像类似于脉冲信号</li></ul></li><li>Weighted：可以控制曲线的长度</li></ul></li><li><p>Ripple Editting：</p><p><img src="/2023/01/10/Unity-Animation/acc192d4-6389-4def-b3e4-02514e6737c9_image10.png" alt="img"></p><p>勾选后，关键帧的移动能够带动后面的关键帧移动</p><p>勾选前：</p><p><img src="/2023/01/10/Unity-Animation/image-20210629004016725.png" alt="image-20210629004016725"></p><p>勾选后：</p><p><img src="/2023/01/10/Unity-Animation/image-20210629004040728.png" alt="image-20210629004040728"></p><p>移动黄色区域后：</p><p><img src="/2023/01/10/Unity-Animation/image-20210629004103401.png" alt="image-20210629004103401"></p><p>曲线模式同样能够整块编辑</p><p><img src="/2023/01/10/Unity-Animation/image-20210629004212816.png" alt="image-20210629004212816"></p></li></ul></li><li><p>动画转换(Animation Transaction)</p><p><img src="/2023/01/10/Unity-Animation/image-20210628232857756.png" alt="image-20210628232857756"></p><ul><li>Has Exit Time: 当前动画只有播放到指定的时间后才能退出，可用于动画的流畅衔接</li><li>Exit Time: 退出时间和动画完成时间的比例</li><li>Fixed Duration: 选中时以秒来计算转换持续时间，否则按帧计算</li><li>Transition Duration: 转换持续时间</li><li>Transition Offset: 下一个动画从哪个位置开始播放，即图中1:00开始经过30s的位置</li><li>Interruption Source: 能够被某个动画打断转换，例如该值设置为Current State，代表动画转换时，如果当前动画被播放，则可以打断转换，并且被打断后从头开始播放动画</li><li>Ordered Interruption: 打断是否有先后顺序</li></ul></li></ol><h2 id="Animator"><a href="#Animator" class="headerlink" title="Animator"></a>Animator</h2><p>动画系统的整体结构如下：</p><p><img src="/2023/01/10/Unity-Animation/Unity-Animation-Animator.png"></p><p>动画参数：</p><ul><li>Floats</li><li>Integers</li><li>Booleans</li><li>Triggers</li></ul><h3 id="Animation-Blending"><a href="#Animation-Blending" class="headerlink" title="Animation Blending"></a>Animation Blending</h3><p>动画混合，指的是对于某个属性值而言，其最终值是多个动画的加权平均数</p><p><strong>混合树（Blending Tree）</strong></p><p>类型：</p><ul><li>1D：可以通过一个参数来混合多个动画</li><li>2D Simple Directional：2个参数控制动画，但每个轴上只有2个动画</li><li>2D Freeform Directional：每个方向可以有多个动画</li><li>2D Freeform Cartesian：参数可以代表不同的概念，不仅仅是PosX和PosY</li><li>Direct：每个动画通过一个参数直接调节，多个动画可以叠加</li></ul><p>对于每个Motion，有下列参数需要注意：</p><p><img src="/2023/01/10/Unity-Animation/image-20210629092513734.png" alt="image-20210629092513734"></p><p>临界值(threhold)：该动画达到最大混合权重的位置，根据实际参数值到临界值的距离降低该动画的权重</p><p>时间范围设置(Time Scale setting)：设置该动画的相对播放速度</p><p>混合树内也可以嵌套另一个混合树</p><h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p>每个动画机都需要管理若干个状态，状态所具有的属性如下：</p><ul><li><p>Motion：设置状态的动画或者混合树</p></li><li><p>Speed：设置动画的播放速度</p><p>可以通过代码来控制播放速度的大小，勾选Parameter，在Multiplier右栏填写参数名称</p><p><img src="/2023/01/10/Unity-Animation/04acdada-2bcc-4ee6-a36a-b89f22045646_image5.png" alt="img"></p></li><li><p>Normalized Time：动画播放的相对时间，0表示开始播放，1表示播放结束</p></li><li><p>Motion Time：可以通过参数设置Normalized Time</p></li><li><p>Cycle Offset：设置动画循环开始的时间</p></li></ul><p>Any State：能够从任何状态发出转换，并且该状态的转换是优先的</p><h3 id="State-Machine"><a href="#State-Machine" class="headerlink" title="State Machine"></a>State Machine</h3><p>可以像创建状态一样创建状态机</p><p>状态机的转换：</p><p>可以从状态机内部直接转换到状态机外部的某个状态，也可以先转换到状态机自身，再进行二次转换；状态机的转进同理</p><h3 id="Layers"><a href="#Layers" class="headerlink" title="Layers"></a>Layers</h3><p>动画层索引（Animator Layer indices）：动画层索引自顶向下递增，初值为0</p><p>动画层权重（Animator Layer weights）：决定每个动画层的混合权重</p><p>蒙版（Masking）：可以设置哪些游戏对象受到动画影响，例如可以只在人物的上半身设置攻击动画的模板</p><p>混合类型：</p><ul><li>Override blending：类似于混合树混合，动画层之间的权重不可叠加</li><li>Additive blending：动画层的权重可以叠加</li></ul><p>同步（Sync）：当前动画层发生转换时，同步的动画层也发生转换，可以设置Timing选项调整权重(?)</p><h2 id="Scripts"><a href="#Scripts" class="headerlink" title="Scripts"></a>Scripts</h2><p>设置动画机的参数：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#">animator.SetBool();<br>animator.SetFloat();<br>animator.SetInteger();<br>animator.SetTrigger();<br></code></pre></td></tr></table></figure><p>该函数有2个重载，第一个参数可以是字符串，也可以是该字符串的哈希值（调用<code>Animator.StringToHash(str)</code>转换，后者的性能更好</p><p>获取动画机的参数：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c#">animator.GetBool();<br>animator.GetFloat();<br>animator.GetInteger();<br></code></pre></td></tr></table></figure><p>控制动画层权重：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#">animator.SetLayerWeight();<br>animator.GetLayerWeight();<br></code></pre></td></tr></table></figure><p>控制动画播放：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#">animator.Play(name, index of layer, offset);<br>animator.PlayInFixedTime();   <span class="hljs-comment">// offset is based on seconds but not Normalized Time</span><br>animator.CrossFade();         <span class="hljs-comment">// 添加渐变效果</span><br>animator.CrossFadeInFixedTime();<br></code></pre></td></tr></table></figure><p>状态和动画片段的信息：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c#">animator.IsTransition();                  <span class="hljs-comment">// 判断状态是否在发生转换</span><br>animator.GetCurrentAnimatorStateInfo();   <span class="hljs-comment">// 获得当前状态信息</span><br>animator.GetNextAnimatorStateInfo();      <span class="hljs-comment">// 获得下一个状态信息</span><br>animator.GetCurrentAnimatorClipInfo();    <span class="hljs-comment">// 获得当前动画片段信息，返回一个动画片段信息的数组，用于获取混合树及权重</span><br>animator.GetNextAnimatorClipInfo();       <span class="hljs-comment">// 获得下一个动画片段信息</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>Animation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity-Physics</title>
    <link href="/2023/01/10/Unity-Physics/"/>
    <url>/2023/01/10/Unity-Physics/</url>
    
    <content type="html"><![CDATA[<h1 id="Unity-Physics"><a href="#Unity-Physics" class="headerlink" title="Unity-Physics"></a>Unity-Physics</h1><h2 id="2D"><a href="#2D" class="headerlink" title="2D"></a>2D</h2><h3 id="Physics-2D-Settings"><a href="#Physics-2D-Settings" class="headerlink" title="Physics 2D Settings"></a>Physics 2D Settings</h3><p>用于设置一些全局属性，如重力大小，层与层之间的碰撞关系</p><p><img src="/2023/01/10/Unity-Physics/image-20210629164215458.png" alt="image-20210629164215458"></p><h3 id="Rigidbody-2D"><a href="#Rigidbody-2D" class="headerlink" title="Rigidbody 2D"></a>Rigidbody 2D</h3><p>设置面板如下：</p><p><img src="/2023/01/10/Unity-Physics/image-20210629164850404.png" alt="image-20210629164850404"></p><ul><li>Body Type：<ul><li>Dynamic：受到力的影响</li><li>Kinematic：不会受到力的影响（包括重力），物体运动受代码控制</li><li>Static：永不移动，只会与动态刚体碰撞，除非设置useFullKinematicContacts，它将和Kinematic刚体碰撞</li></ul></li><li>Material：物体的材质，可以设置弹性和摩擦属性</li><li>Simulated：如果取消勾选，则该物体不受力的影响，且不和其他物体产生接触</li><li>Use Auto Mass：是否根据碰撞器检测质量</li><li>Mass：物体的质量，这会影响物体的惯性、碰撞等</li><li>Linear Drag：运动阻力</li><li>Angular Drag：旋转阻力</li><li>Gravity Scale：重力对物体的影响</li><li>Collision Detection：碰撞检测<ul><li>Discrete：离散检测，不适用于高速物体</li><li>Continuous：连续检测，适用于高速物体，但是会消耗性能</li></ul></li><li>Sleep Mode：睡眠模式<ul><li>Never Sleep：很消耗性能，尽量不要用</li><li>Start Awake：初始化时唤醒</li><li>Start Asleep：最初为睡眠状态（不受重力影响），被碰撞后才唤醒</li></ul></li><li>Interpolate：是否在更新之间插值（一般用于移动不稳定的情况）<ul><li>None：不插值</li><li>Interpolate：根据前一帧插值</li><li>Extrapolate：根据后一帧预估插值</li></ul></li><li>Constraints：锁定方向或者旋转</li></ul><h3 id="Collider-2D"><a href="#Collider-2D" class="headerlink" title="Collider 2D"></a>Collider 2D</h3><h4 id="Circle-Collider-2D"><a href="#Circle-Collider-2D" class="headerlink" title="Circle Collider 2D"></a>Circle Collider 2D</h4><p><img src="/2023/01/10/Unity-Physics/image-20210629223725787.png" alt="image-20210629223725787"></p><ul><li>Material：设置碰撞体的材质（Physics Material 2D），可以设置摩擦力和弹性系数</li><li>Is Trigger：是否为触发体，如果勾选，代表可以被穿过</li><li>Used By Effector：是否能够被Effector 2D使用</li><li>Offset：调整碰撞体的偏移位置</li><li>Radius：调整碰撞体的半径</li></ul><h4 id="Box-Collider-2D"><a href="#Box-Collider-2D" class="headerlink" title="Box Collider 2D"></a>Box Collider 2D</h4><p><img src="/2023/01/10/Unity-Physics/image-20210629224333684.png" alt="image-20210629224333684"></p><p>大部分属性和Circle Collider 2D相同，但也有一些特殊的属性</p><h4 id="polygon-collider-2D"><a href="#polygon-collider-2D" class="headerlink" title="polygon collider 2D"></a>polygon collider 2D</h4><p><img src="/2023/01/10/Unity-Physics/image-20210629224434929.png" alt="image-20210629224434929"></p><p>多边形碰撞体，必须是闭合的图形</p><p>编辑：直接在多边形的边上点击以添加新的结点，按住ctrl后移动到边上会显示为红色，点击后合并红色的边</p><h4 id="edge-collider-2D"><a href="#edge-collider-2D" class="headerlink" title="edge collider 2D"></a>edge collider 2D</h4><p><img src="/2023/01/10/Unity-Physics/image-20210629224548908.png" alt="image-20210629224548908"></p><p>可以不是闭合的，用作地形碰撞</p><p>编辑方法同上</p><h3 id="Hinge-Joint-2D"><a href="#Hinge-Joint-2D" class="headerlink" title="Hinge Joint 2D"></a>Hinge Joint 2D</h3><p>铰链接合组件，可用于制作活动门、铁链等需要旋转的物体，该组件必须配合Rigidbody 2D使用</p><p><img src="/2023/01/10/Unity-Physics/image-20210630011020233.png" alt="image-20210630011020233"></p><ul><li>Enable Collision：勾选后，该游戏对象和连接的刚体之间会发生碰撞，否则能够穿过刚体</li><li>Connected Rigid Body：连接的刚体组件</li><li>Auto Configure Connected Anchor：自动设置锚点和连接锚点</li><li>Anchor：锚点，物体旋转的轴</li><li>Connected Anchor：连接锚点，如果物体锚点偏离了连接锚点，则物体会被瞬移回去，因此相当于一个固定点</li><li>Use Motor：使用驱动力，勾选后，可以设置驱动速度<ul><li>Motor Speed：需要达到的最大驱动速度，正方向为顺时针</li><li>Maximum Motor Force：施加用于达到驱动速度的力，如果该值过小，则无法达到驱动速度</li></ul></li><li>Use Limits：设置旋转的角度<ul><li>Lower Angle：最小允许旋转角度</li><li>Upper Angle：最大允许旋转角度</li></ul></li><li>Break Force：能够破坏铰链的力的大小</li><li>Break Torque：能够破坏铰链的力矩的大小</li></ul><p>通过合理的设置上述属性，能够设计一些有趣的机关：</p><ul><li>弹簧木板：木板被碰撞打开后能够回到原来的位置，可以通过使用驱动力和限制角度实现</li><li>锁链：为每个锁环设置Hinge Joint 2D组件，并连接上一个组件，最后利用Distance Joint 2D限制悬挂物体到支点的距离</li></ul><p>详细步骤见：<a href="https://www.youtube.com/watch?v=l6awvCT29yU">Hinge Joint 2D - Official Unity Tutorial - YouTube</a></p><h3 id="Area-Effector-2D"><a href="#Area-Effector-2D" class="headerlink" title="Area Effector 2D"></a>Area Effector 2D</h3><p><img src="/2023/01/10/Unity-Physics/image-20210630102922401.png" alt="image-20210630102922401"></p><ul><li>Use Collider Mask：使用碰撞器蒙版</li><li>Force<ul><li>Use Global Angle：力的方向相对于全局</li><li>Force Angle：力的方向，默认是相对自身（且不受物体绕y轴的影响），除非勾选Global Angle</li><li>Force Magnitude：力的大小</li><li>Force Variation：给力添加一个随机量，即最终的合力由Magnitude加上0到Variation之间的值</li><li>Force Target：<ul><li>Rigidbody：受影响物体为刚体</li><li>Collider：受影响物体为碰撞体，且会旋转</li></ul></li><li>Damping：<ul><li>Drag：运动阻力大小，可以用来限制物体在其他方向的移动</li><li>Angular Drag：旋转阻力大小</li></ul></li></ul></li></ul><h3 id="Distance-Joint-2D"><a href="#Distance-Joint-2D" class="headerlink" title="Distance Joint 2D"></a>Distance Joint 2D</h3><p><img src="/2023/01/10/Unity-Physics/image-20210701004104980.png" alt="image-20210701004104980"></p><p>用于限制刚体和其连接刚体之间的距离</p><ul><li>Enable Collision：勾选后，连接刚体和该物体之间可以碰撞</li><li>Connected Rigid Body：连接的刚体</li><li>Auto Configure Connected Anchor：勾选后，自动设置连接锚点的位置</li><li>Anchor：物体需要回归的位置</li><li>Connected Anchor：连接刚体的锚点</li><li>Auto Configure Distance：自动设置两个锚点之间的距离</li><li>Distance：两个锚点之间的距离</li><li>Max Distance Only：勾选后，物体可以移动到两个锚点之间的位置，否则只能做圆周运动</li><li>Break Force：能够破坏该组件的力</li></ul><h3 id="Point-Effector-2D"><a href="#Point-Effector-2D" class="headerlink" title="Point Effector 2D"></a>Point Effector 2D</h3><p><img src="/2023/01/10/Unity-Physics/image-20210701145313483.png" alt="image-20210701145313483"></p><p>可以用于产生类似于爆炸或者磁铁的效果</p><ul><li>Use Collider Mask：使用蒙版</li><li>Force：<ul><li>Force Magnitude：力的大小，正方向指向力的源头</li><li>Force Variation：附加一个随机大小的力，最大值为设置的值</li><li>Distance Scale：产生效果的物理距离相对于实际距离的大小，只有Force Mode设置为非Constant只时才会生效，以线性模式举例，如果Scale为5，则计算力的大小时距离取实际距离的5倍</li><li>Force Source：力的来源<ul><li>Collider：来源为Collider的中心点</li><li>Rigidbody：来源为质点</li></ul></li><li>Force Target：力的目标<ul><li>Collider：只有碰撞体受影响</li><li>Rigidbody：只有刚体受影响</li></ul></li><li>Force Mode：力的模式（力关于距离的函数）<ul><li>Constant：恒定力，不受距离影响</li><li>Inverse Linear：距离和力的大小呈线性相反关系</li><li>Inverse Squared：距离和力的大小呈平方相反关系</li></ul></li><li>Drag：线性移动的阻力，可以防止物体移动越过中心点</li><li>Angular Drag：旋转阻力</li></ul></li></ul><h2 id="3D"><a href="#3D" class="headerlink" title="3D"></a>3D</h2>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>Physics</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity-Serialize</title>
    <link href="/2023/01/10/Unity-Serialize/"/>
    <url>/2023/01/10/Unity-Serialize/</url>
    
    <content type="html"><![CDATA[<h1 id="Unity-Serialize"><a href="#Unity-Serialize" class="headerlink" title="Unity-Serialize"></a>Unity-Serialize</h1><h2 id="XMLSerializer"><a href="#XMLSerializer" class="headerlink" title="XMLSerializer"></a>XMLSerializer</h2><p>C#序列化对象为XML条件：</p><ul><li>对于类，要使其实例可以序列化，必须保证其自己、成员以及父类都有[Serializable]标记</li><li>对象数组序列化时，无参构造函数不可少</li></ul><p>XML序列化</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span> <span class="hljs-title">XMLSerialize</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">T entity</span>)</span><br>&#123;<br>    StringBuilder buffer = <span class="hljs-keyword">new</span> StringBuilder();<br>    XmlSerializer serializer = <span class="hljs-keyword">new</span> XmlSerializer(<span class="hljs-keyword">typeof</span>(T));<br>    TextWriter writer = <span class="hljs-keyword">new</span> StringWriter(buffer);<br>    serializer.Serialize(writer, entity);<br>    <span class="hljs-keyword">return</span> buffer.ToString();<br>&#125;<br></code></pre></td></tr></table></figure><p>XML反序列化</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> T <span class="hljs-title">DeXMLSerialize</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-built_in">string</span> xmlString</span>)</span><br>&#123;<br>    StringBuilder buffer = <span class="hljs-keyword">new</span> StringBuilder();<br>    buffer.Append(xmlString);<br>    XmlSerializer serializer = <span class="hljs-keyword">new</span> XmlSerializer(<span class="hljs-keyword">typeof</span>(T));<br><br>    TextReader reader = <span class="hljs-keyword">new</span> StringReader(buffer.ToString());<br><br>    <span class="hljs-built_in">object</span> obj = serializer.Deserialize(reader);<br>    T cloneObject = (T)obj;<br><br>    <span class="hljs-keyword">return</span> cloneObject;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>Serialize</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RSA</title>
    <link href="/2023/01/10/RSA/"/>
    <url>/2023/01/10/RSA/</url>
    
    <content type="html"><![CDATA[<h1 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>一种基于大合数因子分解困难性的公开密钥密码，用于加密和数字签名</p><p>特点：</p><p>非对称：有一个公钥对和私钥对，公钥对可以公开，减少了密钥传递的风险</p><p>分组加密</p><h2 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h2><p>RSA加解密算法的步骤如下：</p><ol><li><p>随机选择两个大素数p和q且保密</p></li><li><p>计算n&#x3D;pq, 将n公开</p></li><li><p>计算$$\varphi(n)&#x3D;(p - 1)(q - 1)$$</p></li><li><p>随机地选取一个正整数e, $$1 &lt; e &lt; \varphi(n)$$，且$$(e, \varphi(n))&#x3D;1$$, 将e公开</p></li><li><p>根据$$ed&#x3D;1mod\varphi(n)$$, 求出d，并对d保密</p></li><li><p>加密运算：<br>$$<br>C &#x3D; M^emod\space n<br>$$</p></li><li><p>解密运算：<br>$$<br>M &#x3D; C^d mod \space n<br>$$</p></li></ol><p>其中，正整数e一般选择3或者65537</p><p>第5步求解乘法逆元时，可以使用扩展欧几里得算法降低复杂度</p><blockquote><p>欧几里得算法</p><p>$$gcd(a, b) &#x3D; gcd(b, a % b)$$</p><p>扩展欧几里得算法</p><p>求$$a * x + b * y &#x3D; gcd(a, b)$$的一组解x0, y0</p><p> 原理见具体实现</p><p>求解a * b &#x3D; 1 (mod m)中a的逆元b, b为正整数，且尽量为最小值</p><p>原理见具体实现</p></blockquote><p>加解密运算时，可使用快速幂避免大数求模</p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// main.c</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;rsa.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int64_t</span> M = <span class="hljs-number">688</span>;<br>    <span class="hljs-type">int64_t</span> C = <span class="hljs-number">1570</span>;<br>    <span class="hljs-type">int64_t</span> resM;<br>    <span class="hljs-type">int64_t</span> resC;<br><br>    p = <span class="hljs-number">47</span>;<br>    q = <span class="hljs-number">71</span>;<br>    e = <span class="hljs-number">79</span>;<br><br>    cal_key_pair();<br><br>    rsa_encrypt(M,    e, n, &amp;resC);<br>    rsa_decrypt(resC, d, n, &amp;resM);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;public  key: (%lld, %lld)\n&quot;</span>, n, e);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;private key: (%lld, %lld)\n&quot;</span>, n, d);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;encode C:%lld\ndecode M:%lld\n&quot;</span>, resC, resM);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> RSA_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RSA_H</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int64_t</span>;<br><br><span class="hljs-comment">// PRIVATE</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int64_t</span> p;<br><span class="hljs-keyword">extern</span> <span class="hljs-type">int64_t</span> q;<br><span class="hljs-keyword">extern</span> <span class="hljs-type">int64_t</span> d;<br><br><span class="hljs-comment">// PUBLIC</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int64_t</span> n;<br><span class="hljs-keyword">extern</span> <span class="hljs-type">int64_t</span> e;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">cal_key_pair</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// rsa加密</span><br><span class="hljs-comment">// M的长度不能大于n的长度，否则需要分组</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">rsa_encrypt</span><span class="hljs-params">(<span class="hljs-type">int64_t</span> M, <span class="hljs-type">int64_t</span> e, <span class="hljs-type">int64_t</span> n, <span class="hljs-type">int64_t</span>* C)</span>;<br><br><span class="hljs-comment">// rsa解密</span><br><span class="hljs-comment">// C的长度不能大于n的长度，否则需要分组</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">rsa_decrypt</span><span class="hljs-params">(<span class="hljs-type">int64_t</span> C, <span class="hljs-type">int64_t</span> d, <span class="hljs-type">int64_t</span> n, <span class="hljs-type">int64_t</span>* M)</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;math.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;rsa.h&quot;</span></span><br><br><span class="hljs-comment">// PRIVATE</span><br><span class="hljs-type">int64_t</span> p;<br><span class="hljs-type">int64_t</span> q;<br><span class="hljs-type">int64_t</span> d;<br><br><span class="hljs-comment">// PUBLIC</span><br><span class="hljs-type">int64_t</span> n;<br><span class="hljs-type">int64_t</span> e = <span class="hljs-number">65537</span>;<br><br><span class="hljs-comment">// 欧几里得算法 求最大公约数</span><br><span class="hljs-comment">// gcd(a, b) = gcd(b, a % b)</span><br><span class="hljs-type">int64_t</span> <span class="hljs-title function_">gcd</span><span class="hljs-params">(<span class="hljs-type">int64_t</span> a, <span class="hljs-type">int64_t</span> b)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> a;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> gcd(b, a % b);<br>&#125;<br><br><span class="hljs-comment">// 扩展欧几里得算法 求a * x + b * y = gcd(a, b)的一组解x0, y0</span><br><span class="hljs-comment">// 通解为 x = x0 + (b / gcd) * t, y = y0 - (a / gcd) * t</span><br><span class="hljs-comment">// 求解方法：</span><br><span class="hljs-comment">// 设 a * x + b * y = gcd(a, b)</span><br><span class="hljs-comment">// 则当a = gcd, b = 0时， x = 1, y = 0，此为gcd(a, b)的递归出口</span><br><span class="hljs-comment">// 令b * x1 + (a % b) * y1 = gcd(b, a % b)</span><br><span class="hljs-comment">// 因为 a % b = a - (floor)(a / b) * b</span><br><span class="hljs-comment">// 所以 a * x1 + (a % b) * y1</span><br><span class="hljs-comment">//   = a * x1 + (a - (floor)(a / b) * b) * y1</span><br><span class="hljs-comment">//   = a * y1 + b * (x1 - (floor)(a / b) * y1)</span><br><span class="hljs-comment">// 而   gcd(a, b) == gcd(b, a % b)</span><br><span class="hljs-comment">// 因此 x = y1</span><br><span class="hljs-comment">//     y = x1 - (int)(a / b) * y1</span><br><span class="hljs-comment">// 递归出口为b == 0, x = 1, y = 0</span><br><span class="hljs-type">int64_t</span> <span class="hljs-title function_">e_gcd</span><span class="hljs-params">(<span class="hljs-type">int64_t</span> a, <span class="hljs-type">int64_t</span> b, <span class="hljs-type">int64_t</span>* x, <span class="hljs-type">int64_t</span>* y)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>)<br>    &#123;<br>        *x = <span class="hljs-number">1</span>;<br>        *y = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    <span class="hljs-type">int64_t</span> x1, y1;<br>    <span class="hljs-type">int64_t</span> gcd = e_gcd(b, a % b, &amp;x1, &amp;y1);<br>    *x = y1;<br>    *y = x1 - (a / b) * y1;<br>    <span class="hljs-keyword">return</span> gcd;<br>&#125;<br><br><span class="hljs-comment">// 求解a * b = 1 (mod m)中a的逆元b, b为正整数，且尽量为最小值</span><br><span class="hljs-comment">// a*b=1(mod m) == a*b + m*y0 = 1</span><br><span class="hljs-comment">// 则 e_gcd(a, m, &amp;b, &amp;y0) =&gt; b = x0</span><br><span class="hljs-comment">// 此时 x = x0 + (m / gcd) * t = x0 + m*t</span><br><span class="hljs-comment">// 要使b最小，则需保证x0 &gt; 0, 那么b = x0 % m</span><br><span class="hljs-comment">// 若 x0 &lt; 0, 则令 xs = x0 % abs(m), -m &lt; xs &lt; 0</span><br><span class="hljs-comment">// 则 b = xs + m, 0 &lt; b &lt; m, 此为所求结果</span><br><span class="hljs-type">int64_t</span> <span class="hljs-title function_">inv1</span><span class="hljs-params">(<span class="hljs-type">int64_t</span> a, <span class="hljs-type">int64_t</span> m)</span><br>&#123;<br>    <span class="hljs-type">int64_t</span> x0, y0, xs, b;<br>    <span class="hljs-type">int64_t</span> gcd = e_gcd(a, m, &amp;x0, &amp;y0);<br>    <span class="hljs-keyword">if</span>(gcd != <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span>(x0 &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        xs = x0 % m;<br>        b = xs + m;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        b = x0 % m;<br>    &#125;<br>    <span class="hljs-keyword">return</span> b;<br>&#125;<br><br><span class="hljs-comment">// 快速幂运算 b^exp(mod m)</span><br><span class="hljs-comment">// a * b % m == (a % m) * (b % m) % m</span><br><span class="hljs-comment">// b^exp mod m = </span><br><span class="hljs-comment">// b^(exp - 1) * b mod m,      e % 2 == 1</span><br><span class="hljs-comment">// b^(exp/2) * b(exp/2) mod m, e % 2 == 0</span><br><span class="hljs-comment">// 优化：改成非递归迭代算法</span><br><span class="hljs-type">int64_t</span> <span class="hljs-title function_">pow_mod</span><span class="hljs-params">(<span class="hljs-type">int64_t</span> b, <span class="hljs-type">int64_t</span> <span class="hljs-built_in">exp</span>, <span class="hljs-type">int64_t</span> m)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">exp</span> == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">exp</span> % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> (pow_mod(b, <span class="hljs-built_in">exp</span> - <span class="hljs-number">1</span>, m) * b) % m;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-type">int64_t</span> tmp = pow_mod(b, <span class="hljs-built_in">exp</span> / <span class="hljs-number">2</span>, m);<br>        <span class="hljs-keyword">return</span> (tmp * tmp) % m;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">cal_key_pair</span><span class="hljs-params">()</span><br>&#123;<br>    n = p * q;<br>    <span class="hljs-type">int64_t</span> Fn = (p - <span class="hljs-number">1</span>) * (q - <span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// e * d = 1 (mod Fn)</span><br>    d = inv1(e, Fn);<br>    <span class="hljs-keyword">if</span>(d == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;e, Fn have gcd != 1!\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">rsa_encrypt</span><span class="hljs-params">(<span class="hljs-type">int64_t</span> M, <span class="hljs-type">int64_t</span> e, <span class="hljs-type">int64_t</span> n, <span class="hljs-type">int64_t</span>* C)</span><br>&#123;<br>    *C = pow_mod(M, e, n);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">rsa_decrypt</span><span class="hljs-params">(<span class="hljs-type">int64_t</span> C, <span class="hljs-type">int64_t</span> d, <span class="hljs-type">int64_t</span> n, <span class="hljs-type">int64_t</span>* M)</span><br>&#123;<br>    *M = pow_mod(C, d, n);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>密码学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RSA</tag>
      
      <tag>非对称密码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OrangeOS-定义速查表</title>
    <link href="/2023/01/10/OrangeOS-%E5%AE%9A%E4%B9%89%E9%80%9F%E6%9F%A5%E8%A1%A8/"/>
    <url>/2023/01/10/OrangeOS-%E5%AE%9A%E4%B9%89%E9%80%9F%E6%9F%A5%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="OrangeOS-定义速查表"><a href="#OrangeOS-定义速查表" class="headerlink" title="OrangeOS-定义速查表"></a>OrangeOS-定义速查表</h1><p>主要放置一些结构体定义，寄存器定义和中断定义等</p><h2 id="保护模式"><a href="#保护模式" class="headerlink" title="保护模式"></a>保护模式</h2><h3 id="段式寻址过程"><a href="#段式寻址过程" class="headerlink" title="段式寻址过程"></a>段式寻址过程</h3><p><img src="/2023/01/10/OrangeOS-%E5%AE%9A%E4%B9%89%E9%80%9F%E6%9F%A5%E8%A1%A8/image-20211108112908961.png" alt="image-20211108112908961"></p><h3 id="段描述符"><a href="#段描述符" class="headerlink" title="段描述符"></a>段描述符</h3><p><img src="/2023/01/10/OrangeOS-%E5%AE%9A%E4%B9%89%E9%80%9F%E6%9F%A5%E8%A1%A8/image-20211108112825528.png" alt="image-20211108112825528"></p><h4 id="描述符属性"><a href="#描述符属性" class="headerlink" title="描述符属性"></a>描述符属性</h4><p>P位：存在（Present）位。P&#x3D;1表示段在内存中存在；P&#x3D;0表示段在内存中不存在。<br>DPL ：描述符特权级（Descriptor Privilege Level）。特权级可以是0、1、2或者3。数字越小特权级越大。<br>S位 ：指明描述符是数据段／代码段描述符（S&#x3D;1）还是系统段／门描述符（S&#x3D;0）。</p><p>G位： 段界限粒度（Granularity）位。G&#x3D;0时段界限粒度为字节；G&#x3D;1时段界限粒度为4KB。<br>D&#x2F;B位： 这一位比较复杂，分三种情况。 在可执行代码段描述符中，这一位叫做D位。D&#x3D;1时，在默认情况下指令使用32位地址及32位或8位操作数；D&#x3D;0时，在默认情况下使用16位地址及16位或8位操作数。 在向下扩展数据段的描述符中，这一位叫做B位。B&#x3D;1时，段的上部界限为4GB；B&#x3D;0时，段的上部界限为64KB。 在描述堆栈段（由ss寄存器指向的段）的描述符中，这一位叫做B位。B&#x3D;1时，隐式的堆栈访问指令（如push、pop和call）使用32位堆栈指针寄存器esp；D&#x3D;0时，隐式的堆栈访问指 令（如push、pop和call）使用16位堆栈指针寄存器sp。<br>AVL位： 保留位，可以被系统软件使用。</p><h4 id="描述符类型"><a href="#描述符类型" class="headerlink" title="描述符类型"></a>描述符类型</h4><p><img src="/2023/01/10/OrangeOS-%E5%AE%9A%E4%B9%89%E9%80%9F%E6%9F%A5%E8%A1%A8/image-20211108113146797.png" alt="image-20211108113146797"></p><h3 id="选择子结构"><a href="#选择子结构" class="headerlink" title="选择子结构"></a>选择子结构</h3><p><img src="/2023/01/10/OrangeOS-%E5%AE%9A%E4%B9%89%E9%80%9F%E6%9F%A5%E8%A1%A8/image-20211108112848519.png" alt="image-20211108112848519"></p><p>TI&#x3D;0: GDT， TI&#x3D;1：LDT</p><h3 id="GDTR"><a href="#GDTR" class="headerlink" title="GDTR"></a>GDTR</h3><p><img src="/2023/01/10/OrangeOS-%E5%AE%9A%E4%B9%89%E9%80%9F%E6%9F%A5%E8%A1%A8/image-20211108112939922.png" alt="image-20211108112939922"></p><h3 id="CR0-实-x2F-保切换"><a href="#CR0-实-x2F-保切换" class="headerlink" title="CR0(实&#x2F;保切换)"></a>CR0(实&#x2F;保切换)</h3><p>PE&#x3D;0：实模式，PE&#x3D;1：保护模式</p><p><img src="/2023/01/10/OrangeOS-%E5%AE%9A%E4%B9%89%E9%80%9F%E6%9F%A5%E8%A1%A8/image-20211108113120874.png" alt="image-20211108113120874"></p><h3 id="保护模式下I-x2F-O"><a href="#保护模式下I-x2F-O" class="headerlink" title="保护模式下I&#x2F;O"></a>保护模式下I&#x2F;O</h3><h4 id="eflags"><a href="#eflags" class="headerlink" title="eflags"></a>eflags</h4><p><img src="/2023/01/10/OrangeOS-%E5%AE%9A%E4%B9%89%E9%80%9F%E6%9F%A5%E8%A1%A8/image-20211108120441963.png" alt="image-20211108120441963"></p><h3 id="部分中英文对照"><a href="#部分中英文对照" class="headerlink" title="部分中英文对照"></a>部分中英文对照</h3><p><img src="/2023/01/10/OrangeOS-%E5%AE%9A%E4%B9%89%E9%80%9F%E6%9F%A5%E8%A1%A8/image-20211108113232596.png" alt="image-20211108113232596"></p><h3 id="特权级"><a href="#特权级" class="headerlink" title="特权级"></a>特权级</h3><h4 id="特权级分级"><a href="#特权级分级" class="headerlink" title="特权级分级"></a>特权级分级</h4><p><img src="/2023/01/10/OrangeOS-%E5%AE%9A%E4%B9%89%E9%80%9F%E6%9F%A5%E8%A1%A8/image-20211108114105708.png" alt="image-20211108114105708"></p><h4 id="特权级检验"><a href="#特权级检验" class="headerlink" title="特权级检验"></a>特权级检验</h4><ol><li>CPL（Current Privilege Level）： CPL是当前执行的程序或任务的特权级。它被存储在cs和ss的第0位和第1位上。在通常情况下，CPL等于代码所在的段的特权级。当程序转移到不同特权级的代码段时，处理器将改变CPL。 在遇到一致代码段时，情况稍稍有点特殊，一致代码段可以被相同或者更低特权级的代码访问。当处理器访问一个与CPL特权级不同的一致代码段时，CPL不会被改变。 </li><li>DPL（DescriptorPrivilege Level）： DPL表示段或者门的特权级。它被存储在段描述符或者门描述符的DPL字段中，正如我们先前所看到的那样。当当前代码段试图访问一个段或者门时，DPL将会和CPL以及段或门选择子的RPL相比 较，根据段或者门类型的不同，DPL将会被区别对待，下面介绍一下各种类型的段或者门的情况。</li></ol><ul><li>数据段： DPL规定了可以访问此段的最低特权级。比如，一个数据段的DPL是1，那么只有运行在CPL为0或者1的程序才有权访问它。 </li><li>非一致代码段（不使用调用门的情况下）： DPL规定访问此段的特权级。比如，一个非一致代码段的特权级为0，那么只有CPL为0的程序才可以访问它。 </li><li>调用门： DPL规定了当前执行的程序或任务可以访问此调用门的最低特权级（这与数据段的规则是一致的）。 </li><li>一致代码段和通过调用门访问的非一致代码段： DPL规定了访问此段的最高特权级。比如，一个一致代码段的DPL是2，那么CPL为0和1的程序将无法访问此段。 </li><li>TSS： DPL规定了可以访问此TSS的最低特权级（这与数据段的规则是一致的）。</li></ul><ol start="3"><li>RPL（RequestedPrivilege Level）： RPL是通过段选择子的第0位和第1位表现出来的。处理器通过检查RPL和CPL来确认一个访问请求是否合法。即便提出访问请求的段有足够的特权级，如果RPL不够也是不行的。也就是说，如果RPL 的数字比CPL大（数字越大特权级越低），那么RPL将会起决定性作用，反之亦然。</li></ol><h4 id="一致-x2F-非一致代码段特权转移规则"><a href="#一致-x2F-非一致代码段特权转移规则" class="headerlink" title="一致&#x2F;非一致代码段特权转移规则"></a>一致&#x2F;非一致代码段特权转移规则</h4><p><img src="/2023/01/10/OrangeOS-%E5%AE%9A%E4%B9%89%E9%80%9F%E6%9F%A5%E8%A1%A8/image-20211108113653215.png" alt="image-20211108113653215"></p><h4 id="门描述符"><a href="#门描述符" class="headerlink" title="门描述符"></a>门描述符</h4><p><img src="/2023/01/10/OrangeOS-%E5%AE%9A%E4%B9%89%E9%80%9F%E6%9F%A5%E8%A1%A8/image-20211108114523273.png" alt="image-20211108114523273"></p><p>Param Count：参数个数，用于堆栈切换时的参数拷贝</p><h4 id="调用门特权级规则"><a href="#调用门特权级规则" class="headerlink" title="调用门特权级规则"></a>调用门特权级规则</h4><p><img src="/2023/01/10/OrangeOS-%E5%AE%9A%E4%B9%89%E9%80%9F%E6%9F%A5%E8%A1%A8/image-20211108114653609.png" alt="image-20211108114653609"></p><h4 id="短调用堆栈"><a href="#短调用堆栈" class="headerlink" title="短调用堆栈"></a>短调用堆栈</h4><p><img src="/2023/01/10/OrangeOS-%E5%AE%9A%E4%B9%89%E9%80%9F%E6%9F%A5%E8%A1%A8/image-20211108114727502.png" alt="image-20211108114727502"></p><p><img src="/2023/01/10/OrangeOS-%E5%AE%9A%E4%B9%89%E9%80%9F%E6%9F%A5%E8%A1%A8/image-20211108115032645.png" alt="image-20211108115032645"></p><h4 id="长调用堆栈"><a href="#长调用堆栈" class="headerlink" title="长调用堆栈"></a>长调用堆栈</h4><p><img src="/2023/01/10/OrangeOS-%E5%AE%9A%E4%B9%89%E9%80%9F%E6%9F%A5%E8%A1%A8/image-20211108115053954.png" alt="image-20211108115053954"></p><p><img src="/2023/01/10/OrangeOS-%E5%AE%9A%E4%B9%89%E9%80%9F%E6%9F%A5%E8%A1%A8/image-20211108115105399.png" alt="image-20211108115105399"></p><h4 id="特权级变换堆栈转移"><a href="#特权级变换堆栈转移" class="headerlink" title="特权级变换堆栈转移"></a>特权级变换堆栈转移</h4><p><img src="/2023/01/10/OrangeOS-%E5%AE%9A%E4%B9%89%E9%80%9F%E6%9F%A5%E8%A1%A8/image-20211108115144226.png" alt="image-20211108115144226"></p><p><img src="/2023/01/10/OrangeOS-%E5%AE%9A%E4%B9%89%E9%80%9F%E6%9F%A5%E8%A1%A8/image-20211108115308094.png" alt="image-20211108115308094"></p><h4 id="TSS结构"><a href="#TSS结构" class="headerlink" title="TSS结构"></a>TSS结构</h4><p><img src="/2023/01/10/OrangeOS-%E5%AE%9A%E4%B9%89%E9%80%9F%E6%9F%A5%E8%A1%A8/image-20211108115202826.png" alt="image-20211108115202826"></p><h2 id="分页机制"><a href="#分页机制" class="headerlink" title="分页机制"></a>分页机制</h2><h3 id="地址转换原理"><a href="#地址转换原理" class="headerlink" title="地址转换原理"></a>地址转换原理</h3><p><img src="/2023/01/10/OrangeOS-%E5%AE%9A%E4%B9%89%E9%80%9F%E6%9F%A5%E8%A1%A8/image-20211108115515007.png" alt="image-20211108115515007"></p><h3 id="页式寻址过程"><a href="#页式寻址过程" class="headerlink" title="页式寻址过程"></a>页式寻址过程</h3><p><img src="/2023/01/10/OrangeOS-%E5%AE%9A%E4%B9%89%E9%80%9F%E6%9F%A5%E8%A1%A8/image-20211108115549510.png" alt="image-20211108115549510"></p><h3 id="PDE"><a href="#PDE" class="headerlink" title="PDE"></a>PDE</h3><p><img src="/2023/01/10/OrangeOS-%E5%AE%9A%E4%B9%89%E9%80%9F%E6%9F%A5%E8%A1%A8/image-20211108115611312.png" alt="image-20211108115611312"></p><h3 id="PTE"><a href="#PTE" class="headerlink" title="PTE"></a>PTE</h3><p><img src="/2023/01/10/OrangeOS-%E5%AE%9A%E4%B9%89%E9%80%9F%E6%9F%A5%E8%A1%A8/image-20211108115626833.png" alt="image-20211108115626833"></p><h3 id="cr3"><a href="#cr3" class="headerlink" title="cr3"></a>cr3</h3><p><img src="/2023/01/10/OrangeOS-%E5%AE%9A%E4%B9%89%E9%80%9F%E6%9F%A5%E8%A1%A8/image-20211108115659378.png" alt="image-20211108115659378"></p><h3 id="分页示例"><a href="#分页示例" class="headerlink" title="分页示例"></a>分页示例</h3><p><img src="/2023/01/10/OrangeOS-%E5%AE%9A%E4%B9%89%E9%80%9F%E6%9F%A5%E8%A1%A8/image-20211108115733079.png" alt="image-20211108115733079"></p><h3 id="ARDS-地址范围描述符结构"><a href="#ARDS-地址范围描述符结构" class="headerlink" title="ARDS(地址范围描述符结构)"></a>ARDS(地址范围描述符结构)</h3><p><img src="/2023/01/10/OrangeOS-%E5%AE%9A%E4%B9%89%E9%80%9F%E6%9F%A5%E8%A1%A8/image-20211108115816252.png" alt="image-20211108115816252"></p><h2 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h2><h3 id="中断调用过程"><a href="#中断调用过程" class="headerlink" title="中断调用过程"></a>中断调用过程</h3><p><img src="/2023/01/10/OrangeOS-%E5%AE%9A%E4%B9%89%E9%80%9F%E6%9F%A5%E8%A1%A8/image-20211108115916345.png" alt="image-20211108115916345"></p><h3 id="中断门和陷阱门"><a href="#中断门和陷阱门" class="headerlink" title="中断门和陷阱门"></a>中断门和陷阱门</h3><p><img src="/2023/01/10/OrangeOS-%E5%AE%9A%E4%B9%89%E9%80%9F%E6%9F%A5%E8%A1%A8/image-20211108115932693.png" alt="image-20211108115932693"></p><h3 id="部分中断向量号定义"><a href="#部分中断向量号定义" class="headerlink" title="部分中断向量号定义"></a>部分中断向量号定义</h3><p><img src="/2023/01/10/OrangeOS-%E5%AE%9A%E4%B9%89%E9%80%9F%E6%9F%A5%E8%A1%A8/image-20211108120010951.png" alt="image-20211108120010951"></p><h3 id="8259A"><a href="#8259A" class="headerlink" title="8259A"></a>8259A</h3><p><img src="/2023/01/10/OrangeOS-%E5%AE%9A%E4%B9%89%E9%80%9F%E6%9F%A5%E8%A1%A8/image-20211108120030467.png" alt="image-20211108120030467"></p><h4 id="ICW格式"><a href="#ICW格式" class="headerlink" title="ICW格式"></a>ICW格式</h4><p><img src="/2023/01/10/OrangeOS-%E5%AE%9A%E4%B9%89%E9%80%9F%E6%9F%A5%E8%A1%A8/image-20211108120053968.png" alt="image-20211108120053968"></p><p><img src="/2023/01/10/OrangeOS-%E5%AE%9A%E4%B9%89%E9%80%9F%E6%9F%A5%E8%A1%A8/image-20211108120106099.png" alt="image-20211108120106099"></p><h4 id="OCW1"><a href="#OCW1" class="headerlink" title="OCW1"></a>OCW1</h4><p><img src="/2023/01/10/OrangeOS-%E5%AE%9A%E4%B9%89%E9%80%9F%E6%9F%A5%E8%A1%A8/image-20211108120153432.png" alt="image-20211108120153432"></p><h4 id="OCW2"><a href="#OCW2" class="headerlink" title="OCW2"></a>OCW2</h4><p><img src="/2023/01/10/OrangeOS-%E5%AE%9A%E4%B9%89%E9%80%9F%E6%9F%A5%E8%A1%A8/image-20211108120221443.png" alt="image-20211108120221443"></p><h3 id="中断堆栈变换"><a href="#中断堆栈变换" class="headerlink" title="中断堆栈变换"></a>中断堆栈变换</h3><p><img src="/2023/01/10/OrangeOS-%E5%AE%9A%E4%B9%89%E9%80%9F%E6%9F%A5%E8%A1%A8/image-20211108120302282.png" alt="image-20211108120302282"></p><h2 id="FAT12"><a href="#FAT12" class="headerlink" title="FAT12"></a>FAT12</h2><h3 id="软盘结构"><a href="#软盘结构" class="headerlink" title="软盘结构"></a>软盘结构</h3><p><img src="/2023/01/10/OrangeOS-%E5%AE%9A%E4%B9%89%E9%80%9F%E6%9F%A5%E8%A1%A8/image-20211108120601662.png" alt="image-20211108120601662"></p><h3 id="根目录条目-Directory-Entry"><a href="#根目录条目-Directory-Entry" class="headerlink" title="根目录条目(Directory Entry)"></a>根目录条目(Directory Entry)</h3><p><img src="/2023/01/10/OrangeOS-%E5%AE%9A%E4%B9%89%E9%80%9F%E6%9F%A5%E8%A1%A8/image-20211108120623209.png" alt="image-20211108120623209"></p><h3 id="BIOS-ParameterBlock-BPB"><a href="#BIOS-ParameterBlock-BPB" class="headerlink" title="BIOS ParameterBlock(BPB)"></a>BIOS ParameterBlock(BPB)</h3><p><img src="/2023/01/10/OrangeOS-%E5%AE%9A%E4%B9%89%E9%80%9F%E6%9F%A5%E8%A1%A8/image-20211108120539807.png" alt="image-20211108120539807"></p><h3 id="根目录占用扇区数计算公式"><a href="#根目录占用扇区数计算公式" class="headerlink" title="根目录占用扇区数计算公式"></a>根目录占用扇区数计算公式</h3><p><img src="/2023/01/10/OrangeOS-%E5%AE%9A%E4%B9%89%E9%80%9F%E6%9F%A5%E8%A1%A8/image-20211108120734967.png" alt="image-20211108120734967"></p><p>或者：</p><p><img src="/2023/01/10/OrangeOS-%E5%AE%9A%E4%B9%89%E9%80%9F%E6%9F%A5%E8%A1%A8/image-20211108120808244.png" alt="image-20211108120808244"></p><h3 id="FAT项"><a href="#FAT项" class="headerlink" title="FAT项"></a>FAT项</h3><p><img src="/2023/01/10/OrangeOS-%E5%AE%9A%E4%B9%89%E9%80%9F%E6%9F%A5%E8%A1%A8/image-20211108120825629.png" alt="image-20211108120825629"></p><h3 id="int-13h-读软盘"><a href="#int-13h-读软盘" class="headerlink" title="int 13h(读软盘)"></a>int 13h(读软盘)</h3><p><img src="/2023/01/10/OrangeOS-%E5%AE%9A%E4%B9%89%E9%80%9F%E6%9F%A5%E8%A1%A8/image-20211108120852718.png" alt="image-20211108120852718"></p><h3 id="磁头号、柱面号、起始扇区号计算公式"><a href="#磁头号、柱面号、起始扇区号计算公式" class="headerlink" title="磁头号、柱面号、起始扇区号计算公式"></a>磁头号、柱面号、起始扇区号计算公式</h3><p><img src="/2023/01/10/OrangeOS-%E5%AE%9A%E4%B9%89%E9%80%9F%E6%9F%A5%E8%A1%A8/image-20211108120918295.png" alt="image-20211108120918295"></p><h2 id="操作系统内核"><a href="#操作系统内核" class="headerlink" title="操作系统内核"></a>操作系统内核</h2><h3 id="ELF格式"><a href="#ELF格式" class="headerlink" title="ELF格式"></a>ELF格式</h3><p><img src="/2023/01/10/OrangeOS-%E5%AE%9A%E4%B9%89%E9%80%9F%E6%9F%A5%E8%A1%A8/image-20211108121017919.png" alt="image-20211108121017919"></p><h3 id="ELF-header"><a href="#ELF-header" class="headerlink" title="ELF header"></a>ELF header</h3><p><img src="/2023/01/10/OrangeOS-%E5%AE%9A%E4%B9%89%E9%80%9F%E6%9F%A5%E8%A1%A8/image-20211108121120280.png" alt="image-20211108121120280"></p><p><img src="/2023/01/10/OrangeOS-%E5%AE%9A%E4%B9%89%E9%80%9F%E6%9F%A5%E8%A1%A8/image-20211108121100916.png" alt="image-20211108121100916"></p><h3 id="Program-header"><a href="#Program-header" class="headerlink" title="Program header"></a>Program header</h3><p><img src="/2023/01/10/OrangeOS-%E5%AE%9A%E4%B9%89%E9%80%9F%E6%9F%A5%E8%A1%A8/image-20211108121149023.png" alt="image-20211108121149023"></p><h3 id="载入内核后的内存分布"><a href="#载入内核后的内存分布" class="headerlink" title="载入内核后的内存分布"></a>载入内核后的内存分布</h3><p><img src="/2023/01/10/OrangeOS-%E5%AE%9A%E4%B9%89%E9%80%9F%E6%9F%A5%E8%A1%A8/image-20211108121307904.png" alt="image-20211108121307904"></p><h3 id="载入内核后的寄存器分布"><a href="#载入内核后的寄存器分布" class="headerlink" title="载入内核后的寄存器分布"></a>载入内核后的寄存器分布</h3><p><img src="/2023/01/10/OrangeOS-%E5%AE%9A%E4%B9%89%E9%80%9F%E6%9F%A5%E8%A1%A8/image-20211108121350216.png" alt="image-20211108121350216"></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Orange OS-从0xaa55到kernel</title>
    <link href="/2023/01/10/OrangeOS-%E4%BB%8E0xaa55%E5%88%B0kernel/"/>
    <url>/2023/01/10/OrangeOS-%E4%BB%8E0xaa55%E5%88%B0kernel/</url>
    
    <content type="html"><![CDATA[<h1 id="Orange-OS-从0xaa55到kernel"><a href="#Orange-OS-从0xaa55到kernel" class="headerlink" title="Orange OS-从0xaa55到kernel"></a>Orange OS-从0xaa55到kernel</h1><p>这篇文章梳理一下从启动程序到加载内核的过程，主要是为了将原书中的操作流程抽象出来，不被一些过于具体的寄存器使用和结构体定义所干扰。浅色部分为补充内容，可以跳过，具体细节参考分博客（有时间再写，鸽了o(╥﹏╥)o），有错误请指出</p><h2 id="启动boot程序"><a href="#启动boot程序" class="headerlink" title="启动boot程序"></a>启动boot程序</h2><p>计算机在加电后，需要一个入口从硬件层面进入软件层面，该程序就是BIOS，之后，BIOS进行各种硬件自检和初始化，最后从引导扇区载入引导程序，在Orange OS中由<code>boot.bin</code>程序模拟</p><blockquote><p><strong>什么是BIOS？</strong></p><p><strong>BIOS</strong>是一组固化到计算机内主板上一个ROM芯片上的程序，它保存着计算机最重要的基本输入输出的程序、开机后自检程序和系统自启动程序。在真实机器上一般通过一个按键就能启动</p></blockquote><p>可想而知的是，boot程序需要使用底层语言去编写，这样便于和硬件交流，并且受到引导扇区的限制，该程序不会太大</p><p>但是，在Orange OS中，boot程序并没有直接引导操作系统内核的加载，而是先从硬盘中加载<code>loader.bin</code>程序，该程序再加载内核。</p><blockquote><p><strong>为什么不直接使用boot加载内核？</strong></p><p>这主要是考虑到引导扇区的大小不足以完成保护模式的准备等一系列工作，如果使用<code>loader.bin</code>程序，则程序不再受限于512字节</p></blockquote><p>启动boot程序很简单，将<code>boot.bin</code>装到磁盘第0个扇区，即引导扇区即可</p><h2 id="加载kernel-loader"><a href="#加载kernel-loader" class="headerlink" title="加载kernel loader"></a>加载kernel loader</h2><p>接下来运行boot程序，在磁盘中寻找loader并载入到内存中</p><h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><ol><li><p>从<code>0x7c00</code>处开始执行，因为这是BIOS把引导扇区默认加载到的位置</p></li><li><p>在A盘的<span style="color:#5882FA; font-weight: bold">根目录区</span>寻找<code>loader.bin</code>。根目录区存储了每个文件的元数据，这里需要的是<span style="color:#5882FA; font-weight: bold">文件的名称和位置</span>（具体来说是簇号，扇区号），找到文件位置后，便可以再次读取磁盘数据，将文件加载到指定内存</p><blockquote><p><strong>根目录区是如何加载的？</strong></p><p>通过硬件中断实现，具体来说，调用指令<code>int 13h</code>，需要设置的输入参数为柱面号，磁头号，当前柱面上的扇区号，驱动器号，要读的扇区数，输出参数为内存缓冲区地址。所有输入参数可通过从第0个扇区开始的扇区号计算。</p><p><strong>如果根目录区大于一个簇怎么办，如何判断我需要加载多少个簇？</strong></p><p>根目录区的大小确实不固定，它依赖于变量<code>BPB_RootEntCnt</code>，即目录条目（文件元数据）的数目，该变量存储在引导扇区的数据结构<code>BIOS ParameterBlock</code>中，该结构中有一些很重要的数据，<span style="color:#5882FA; font-weight: bold">这些数据显示了该磁盘的结构和性质</span>，如：</p><ul><li>每扇区字节数</li><li>每簇扇区数</li><li>Boot记录占用扇区数</li><li>FAT表数目</li><li>根目录文件数最大值，即<code>BPB_RootEntCnt</code></li><li>每FAT扇区数</li><li>每磁道扇区数</li><li>磁头数</li><li>中断13的驱动器号</li></ul><p><span style="color:#5882FA; font-weight: bold">利用以上信息，几乎可以从磁盘中获得任何需要的数据！</span>一般来说，该数据结构就定义在<code>boot.bin</code>的特定偏移位置，在Orange OS中，偏移0处是一个跳转到执行代码的短跳转指令，从偏移3到偏移54为该结构体的内容，之后是执行代码，512偏移处为结束标志0xAA55。结构体中的内容都是提前定义好的（Q：厂商定义还是用户定义的？）</p><p><strong>如何从根目录的这些簇中找到文件名称和位置？</strong></p><p>定量计算。在Orange OS中，每个簇512个字节，而一个目录条目为32字节，这样，每个簇正好包含16个目录条目，可以写出以下伪代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;<span class="hljs-keyword">for</span> 根目录区的每个扇区:<br> <span class="hljs-keyword">for</span> <span class="hljs-number">16</span>个目录条目的每个条目:<br>     <span class="hljs-keyword">if</span> 条目中的文件名称 == 寻找的文件名称:<br>         <span class="hljs-keyword">return</span> 该文件在数据区的起始簇号<br></code></pre></td></tr></table></figure><p><strong>获得文件的起始簇号后，如何知道文件占用的其他簇？这些簇有多少个？</strong></p><p>我们并不需要知道文件占用了多少簇，因为文件簇的记录类似于单向链表，知道了起始簇号便知道了链表的头结点，但是，该处的单向链表和数据结构中的稍有不同。在数据结构中，单向链表结点可以由如下定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">&gt;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LinkListNode</span></span><br><span class="hljs-class">&gt;</span>&#123;<br> NodeInfo info;<br> LinkListNode next;<br>&gt;&#125;;<br></code></pre></td></tr></table></figure><p>这种情况下，我们搜索数据的过程是，找到第一个结点，判断是否为需要的数据，之后访问<code>next</code>变量中存储的地址，到下一个结点寻找，直到遇到空结点。</p><p>但是，在文件簇号的寻找过程中，并没有将数据和下一个数据地址定义在一起，即数据簇和文件中该簇对应的下一个簇号没有放在一起，而是将<code>next</code>放在一个叫做<span style="color:#5882FA; font-weight: bold">FAT12</span>的区域中，该区域类似一个数组（位图），数组索引对应当前簇号，数组内容对应下一个簇号。通过这种方式，我们同样可以像链表一样寻找数据，同时，<code>0xFF</code>簇号被定义为该链表的空结点，当FAT项为该内容时，说明文件内容结束。</p><p>这种情况下，在FAT这样一个数组中查找便比较麻烦，因为一个FAT Entry项可能横跨两个扇区</p><p>基本思想是，通过簇号计算出该FAT Entry在FAT中的偏移地址，然后利用该地址计算出所在扇区和相对于扇区的偏移，最后连续读取两个扇区，将该地址的12bit读取出来作为返回结果，即文件的下一个数据簇号</p></blockquote></li><li><p>跳转到<code>loader.bin</code>对应的内存处执行</p></li></ol><h2 id="加载内核"><a href="#加载内核" class="headerlink" title="加载内核"></a>加载内核</h2><p>接下来使用类似的方式加载kernel，但是加载之前，还需要设置环境</p><h3 id="开启分段机制"><a href="#开启分段机制" class="headerlink" title="开启分段机制"></a>开启分段机制</h3><p>虽然原书花费了大段内容介绍分段机制，但是实际使用时并没有分段，所有段基址都是0，作者的理由是方便管理，但我觉得有必要讲一下该机制的现状。 分段机制主要使用在20位地址总线的CPU上，如intel奔腾处理器，但是到了x64架构下，分段机制基本被取消了，同时，现代操作系统linux和windows都采用扁平式分段，即段基址为0，程序运行时，CS,SS这些寄存器的值全都为0，导致CPU的分段机制被遗弃了。但这并不是说操作系统不再对内存访问进行限制，而是把控制权交给了分页机制和一些其他的机制。</p><p>在我看来，扁平式内存也便于将可执行文件加载到指定的虚拟地址，如ELF文件中指定的虚拟地址，分页机制用起来也更加顺手</p><p>回到正题，在<code>loader.bin</code>中，代码段和数据段都被定义在基址0处，只是属性不同，视频段保持默认。通过将GDTR寄存器设置为GDT地址便可以跳入保护模式，开启分段机制，当然还有一些细节上的处理，比如打开地址线，设置cr0等。</p><blockquote><p><strong>分段寻址是如何运作的？</strong></p><p>在保护模式下，有一个全局的描述符表GDT，里面定义了若干段描述符结构体，而段描述符主要记录段基址，长度和访问权限。在开启分段机制后，指令便不能直接访问内存了，必须先访问段描述符。这时定义了一个叫做选择子的结构体，选择子类似于指针，指向段描述符，这样CPU在访问段描述符的同时也能知道你是否有权限访问该段。</p><p>代码需要访问内存时，段寄存器存放选择子，通用寄存器存放偏移地址，之后的寻址过程便交给CPU去做了，CPU会帮你找到段基址，判断你的访问权限，如果能够找到有效地址则返回给你使用</p><p><strong>为什么需要分段？</strong></p><p>分段机制可以为每个段设置访问权限，对内存起到一定的保护作用，同时，分段机制使用了额外的内存存储段基址，这样能够访问到更大的内存空间</p></blockquote><h3 id="开启分页机制"><a href="#开启分页机制" class="headerlink" title="开启分页机制"></a>开启分页机制</h3><p>为了能够让CPU进行分页寻址，需要为每个进程定义页目录表和页表，但为了能够更好地划分内存页，需要先知道内存的大小信息，这可以通过ARDS结构体获得。获得内存大小后，通过定量计算出页目录表的大小和页表数目，再往页表中填充物理页的地址和属性，便完成了线性地址到物理地址的映射，最后，为了让CPU知道页目录表的位置，需要将cr3寄存器设置为页目录表基址。</p><blockquote><p><strong>分页机制是如何运作的？</strong></p><p>在分页机制中，从CPU的角度看，程序只能看到线性地址，从操作系统的角度看，程序只能看到连续的虚拟地址（即可执行文件反汇编后显示的地址），该地址的前10bit为页目录项的索引，CPU计算该索引获得页目录表中页目录项的地址，该地址中存储了页表的基址和访问权限信息；中间10bit为页表中页表项的索引，CPU计算该索引获得该页表项的地址，该地址中存储了物理页的基址和访问权限信息；最后12bit为物理页中的偏移。这样，经过两次索引和一次偏移，如果CPU找到一个有效地址，便返回给你使用</p><p><strong>为什么需要分页？</strong></p><p>分页机制保证了即使一个很大的程序没有被存储在连续的物理页中，也能被映射到连续的虚拟地址上，大大方便了程序的内存访问，同时，不同的进程可以拥有同样的虚拟地址，只要这些地址通过不同的页表被映射到不同的物理页上。</p><p><strong>当前内存大小是如何获得的？</strong></p><p>利用中断<code>int 15h</code>获得地址范围描述符结构ARDS，该结构中存储了不同地址段的基址，长度和属性。其中只有部分内存段能够被操作系统使用。</p></blockquote><h3 id="加载内核文件"><a href="#加载内核文件" class="headerlink" title="加载内核文件"></a>加载内核文件</h3><p>方法类似于加载<code>loader.bin</code>，需要先在根目录区找到<code>kernel.bin</code>文件的名称和在磁盘中的位置，然后将其占用的簇依次加载到指定的内存中，该过程在实模式下进行（保护模式肯定也能做，因为之后的文件加载都是在分页机制下加载了）</p><p><strong>但是，仅仅加载进来是不够的！</strong>因为<code>kernel.bin</code>的文件格式和之前的<code>loader.bin</code>，<code>boot.bin</code>都不同，该文件生成时添加了<code>-f elf</code>参数，因此是ELF格式，该格式规定必须将文件加载到指定的虚拟地址上，这个指定的虚拟地址存放在程序头表中，原则上应该从<code>kernel.bin</code>文件读取，但原书加载内核时，已经提前指定好了虚拟地址，因此使用了一个常数地址加载</p><blockquote><p> <strong>那么实际应该怎么加载？</strong></p><p>在ELF文件中，ELF头记录了程序头表的个数、偏移、大小，而程序头表又记录了每个程序段应该放置的虚拟地址和大小，有了这些信息就能够把文件完整地加载到指定虚拟地址处了</p></blockquote><h2 id="扩充内核"><a href="#扩充内核" class="headerlink" title="扩充内核"></a>扩充内核</h2><p>到现在为止，已经可以在内核中运行代码了，那接下来需要将之前的一些功能转移到内核中来，如分段机制，以及添加额外的功能，如中断调用</p><h3 id="切换GDT和堆栈"><a href="#切换GDT和堆栈" class="headerlink" title="切换GDT和堆栈"></a>切换GDT和堆栈</h3><p>为了方便控制，需要将loader中GDT的内容拷贝到内核新建的GDT中，同时更新选择子，<code>esp</code>寄存器也指向内核中新的栈顶</p><h3 id="添加中断处理"><a href="#添加中断处理" class="headerlink" title="添加中断处理"></a>添加中断处理</h3><p>为了更好地控制进程切换和控制权转换，需要依靠中断机制。这里主要是添加硬件中断，即初始化中断处理器8259A，让内核能够接受时钟中断和键盘中断等。</p><p>首先设置8259A，即为每个端口写入特定的值，之后建立中断向量表IDT，设置每个中断向量对应的中断处理程序，最后设置IDTR寄存器的值为IDT的地址，CPU就能在调用中断指令时正确跳转到中断处理程序了</p><blockquote><p><strong>中断机制是如何运作的？</strong></p><p>首先需要建立一个中断向量表IDT，里面放着若干个中断门或者陷阱门，每个门里面有段描述符和偏移，即每个中断门知道内存中的一个地址，在调用中断指令时，会传递一个参数，该参数就是中断号，即该中断门在IDT中的索引，之后CPU解析该中断门，找到要执行的代码的位置，执行中断处理程序，最后通过<code>iretd</code>指令返回</p><p><strong>为什么有些中断能自动触发，有些必须使用<code>int</code>指令主动触发？</strong></p><p>绝大部分硬件中断，例如时钟中断、键盘中断，都是在硬件生产时设置好的，我们只需要根据规则配置即可，类似于该事件已经被CPU注册了，我们只需要给该事件写一个回调函数就行，在C&#x2F;C++里类似于函数指针，在C#里类似于委托。但有些软件中断是我们用户自己添加进去的，CPU当然不知道什么时候触发这些事件，所以要我们主动调用<code>int</code>指令，类似于C#中的事件。</p><p><strong>中断和一般的调用有什么区别？</strong></p><p>指令不同。中断使用<code>int</code>指令，调用使用<code>call</code>指令。</p><p>他们使用的结构体不同。中断使用中断门存储地址信息，中断门定义在IDT中；而调用使用调用门存储地址信息，同时存储调用时用到的参数个数，调用门定义在GDT或LDT中。</p><p>大部分中断调用都涉及特权级变换，因此需要切换堆栈，这时两者的方式是一样的，都需要先设置TSS中的<code>ss esp</code>寄存器为高特权级堆栈地址。但是，在调用门完成特权级变换时，CPU还会根据参数个数自动将参数内容拷贝到新的堆栈中，而中断不需要额外的参数。</p><p>返回指令不同。中断使用<code>iretd</code>指令返回，该指令弹出<code>ss esp eflags cs eip </code>寄存器的内容并返回低地址，切换堆栈。调用使用<code>ret</code>指令返回，该指令能够传入一个参数，代表要弹出的参数个数，当然也可以不加参数，而是返回调用者的地址后手动<code>pop</code>。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到这里，一个简易的内核就完成了，它现在具有的基本功能是，段式寻址+页式寻址，中断调用，特权级转移。</p><p>梳理之后发现没实现什么内容，这是因为每一个步骤都涉及了太多的规则和细节。我们在实现这些功能时，不仅要和CPU等硬件制定好的规则对接，例如设置各种表寄存器，设置8259A端口，还要考虑历史遗留问题，如实模式跳转到保护模式时地址总线和关闭中断的处理。同时，高级语言中大量的参数名称、变量名称、结构体定义在汇编语言中都只能以全局宏和寄存器替代，这大大增加了阅读难度、使用难度和调试难度。这也体现出发展高级语言编译器的必要性了。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL</title>
    <link href="/2023/01/10/MySQL/"/>
    <url>/2023/01/10/MySQL/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><p>JavaEE: 企业级Java开发 Web</p><p>前端（页面：展示数据） </p><p>后台（连接点：连接数据库JDBC，连接前端（控制视图跳转，和给前端传递数据））</p><p>数据库（存数据，txt, excel, word… …）</p><h2 id="初识MySQL"><a href="#初识MySQL" class="headerlink" title="初识MySQL"></a>初识MySQL</h2><h3 id="数据库的重要性"><a href="#数据库的重要性" class="headerlink" title="数据库的重要性"></a>数据库的重要性</h3><ol><li>大数据时代，得数据者得天下</li><li>存数据</li><li><strong>数据库是所有软件体系最核心的存在</strong></li></ol><h3 id="什么是数据库"><a href="#什么是数据库" class="headerlink" title="什么是数据库"></a>什么是数据库</h3><p>数据库（DB，DataBase）</p><p>概念：数据仓库，<strong>软件</strong>，安装在操作系统（Windows，Linux，Mac）之上！SQL，可以存储大量的数据。500万！</p><p>作用：存储数据，管理数据</p><h3 id="数据库分类"><a href="#数据库分类" class="headerlink" title="数据库分类"></a>数据库分类</h3><p>关系型数据库：（SQL）</p><ul><li>MySQL，Oracle，Sql Server, DB2, SQLlite</li><li>通过表和表之间，行和列之间的关系进行数据的存储，  学员信息表，考勤表，… …</li></ul><p>非关系型数据库：（NoSQL）Not Only SQL</p><ul><li>Redis&#x2F;MongDB</li><li>非关系型数据库，对象存储，通过对象自身的属性来决定。</li></ul><p><strong>DBMS（数据库管理系统）</strong></p><ul><li>数据库的管理软件，科学有效地管理我们的数据。维护和获取数据；</li><li>MySQL</li></ul><p><img src="/2023/01/10/MySQL/image-20200913194526770.png" alt="image-20200913194526770"></p><h3 id="MySQL简介"><a href="#MySQL简介" class="headerlink" title="MySQL简介"></a>MySQL简介</h3><p>MySQL是一个<strong>关系型数据库管理系统</strong></p><p>以前属于瑞典MySQL AB公司，在属于Oracle旗下产品。</p><p>MySQL是最好的RDBMS（Relational DataBase Management System）应用软件之一。</p><p>开源软件。</p><p>体积小、速度快、总体拥有成本低。</p><p>中小型网站，或者大型网站，可以集群。</p><p>官网：<a href="https://www.mysql.com/">https://www.mysql.com/</a></p><h3 id="MySQL安装"><a href="#MySQL安装" class="headerlink" title="MySQL安装"></a>MySQL安装</h3><p>安装地址：<a href="https://dev.mysql.com/downloads/mysql/">https://dev.mysql.com/downloads/mysql/</a></p><p>安装建议：</p><ol><li>尽量不要使用exe安装，会牵涉到注册表</li><li>尽可能使用压缩包安装</li></ol><br><p>步骤：</p><ol><li><p>解压zip</p></li><li><p>添加环境变量：在path中添加bin的目录</p></li><li><p>在mysql文件夹下新建my.ini文件</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[mysqld]</span><br><span class="hljs-attr">basedir</span>=D:\Program Files (x86)\mysql-<span class="hljs-number">8.0</span>.<span class="hljs-number">21</span>\<br><span class="hljs-attr">datadir</span>=D:\Program Files (x86)\mysql-<span class="hljs-number">8.0</span>.<span class="hljs-number">21</span>\data\<br><span class="hljs-attr">port</span>=<span class="hljs-number">3306</span><br><span class="hljs-comment">;skip-grant-tables</span><br></code></pre></td></tr></table></figure></li><li><p>启动<strong>管理员模式</strong>下的CMD，并将路径切换至mysql下的bin目录，然后输入mysqld-install(安装mysql)。</p></li><li><p>再输入mysqld –initialize-insecure –user&#x3D;mysql 初始化数据文件。</p></li><li><p>然后再次启动mysql（使用net start mysql），然后用命令mysql -u root -p进入mysql管理页面</p></li><li><p>进入页面以后更改root密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ALTER USER <span class="hljs-string">&#x27;root&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> IDENTIFIED WITH mysql_native_password BY <span class="hljs-string">&#x27;pwd&#x27;</span>;<br></code></pre></td></tr></table></figure></li><li><p>输入flush privileges; 刷新权限</p></li><li><p>重启mysql(net stop mysql, net start mysql)</p></li><li><p>启动 mysql -u root -p</p></li></ol><h3 id="安装SQLyog"><a href="#安装SQLyog" class="headerlink" title="安装SQLyog"></a>安装SQLyog</h3><ol><li><p>下载客户端后输入注册码</p></li><li><p>打开，连接数据库</p></li><li><p>新建一个数据库school</p></li><li><p>新建一张表student</p></li></ol><p><img src="/2023/01/10/MySQL/image-20200914145307361.png" alt="image-20200914145307361"></p><p>每一个sqlyog操作本质就是对应一些命令</p><p><img src="/2023/01/10/MySQL/image-20200914145743635.png" alt="image-20200914145743635"></p><p>然后保存</p><p>右键student打开表即可添加数据</p><h3 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql <span class="hljs-operator">-</span>uroot <span class="hljs-operator">-</span>p <span class="hljs-comment">--连接数据库</span><br>flush privileges;  <span class="hljs-comment">--刷新权限</span><br><span class="hljs-keyword">show</span> databases;   <span class="hljs-comment">--查询所有的数据库</span><br>use school; <span class="hljs-comment">--切换数据库</span><br><span class="hljs-keyword">show</span> tables;  <span class="hljs-comment">--查看所有表</span><br><span class="hljs-keyword">describe</span> student;  <span class="hljs-comment">--显示数据库中表的信息</span><br><span class="hljs-keyword">create</span> database westos;  <span class="hljs-comment">--创建一个数据库</span><br>exit; <span class="hljs-comment">--退出连接</span><br><span class="hljs-comment">-- --单行注释</span><br><span class="hljs-comment">/* 多行注释 */</span><br></code></pre></td></tr></table></figure><p><strong>数据库语言</strong>  CRUD增删改查</p><p>DML：操作</p><p>DDL：定义</p><p>DQL：查询</p><p>DCL：控制</p><h2 id="操作数据库"><a href="#操作数据库" class="headerlink" title="操作数据库"></a>操作数据库</h2><p>操作数据库-&gt; 操作数据库中的表-&gt; 操作数据库中表的数据</p><p>mySQL的关键字不区分大小写</p><h3 id="操作数据库-1"><a href="#操作数据库-1" class="headerlink" title="操作数据库"></a>操作数据库</h3><ol><li><p>创建数据库 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> DATABASE [IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span>] westos;<br></code></pre></td></tr></table></figure></li><li><p>删除数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> DATABASE IF <span class="hljs-keyword">EXISTS</span> westos<br></code></pre></td></tr></table></figure></li><li><p>使用数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- tab 键的上面，如果表名或者字段名是一个特殊字符，需要带``</span><br>USE `school`;<br></code></pre></td></tr></table></figure></li><li><p>查看数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> DATABASES;<br></code></pre></td></tr></table></figure></li></ol><h3 id="数据库的列类型"><a href="#数据库的列类型" class="headerlink" title="数据库的列类型"></a>数据库的列类型</h3><blockquote><p>数值</p></blockquote><ul><li>tinyint  十分小的数据   1字节</li><li>smallint  较小数据        2字节</li><li><strong>int                                   4字节</strong></li><li>mediumint 中等数据    3字节</li><li>bigint     较大数据          8字节</li><li>float                                4字节</li><li>double                            8字节（精度问题，计算机无法处理无限循环小数）</li><li>decimal   字符串形式浮点数   金融计算的时候，一般是使用decimal</li></ul><blockquote><p>字符串</p></blockquote><ul><li>char   字符串                  0~255</li><li><strong>varchar  可变字符串     0~65535</strong>  对应String类型，常用变量</li><li>tinytext   微型文本        $2^{8} - 1$ </li><li><strong>text           文本串           $2^{16} - 1$</strong>   保存大文本</li></ul><blockquote><p>时间日期</p></blockquote><p>java.util.Date</p><ul><li>date    YYYY-MM-DD，日期格式</li><li>time    HH:mm:ss         时间格式</li><li><strong>datetime  YYYY-MM-DD HH:mm:ss  最常用的时间格式</strong></li><li><strong>timestamp  时间戳  1970.1.1 到现在的毫秒数   也较为常用</strong></li><li>year      年份表示</li></ul><blockquote><p>null</p></blockquote><ul><li>没有值，未知</li><li>注意：不要使用null进行运算，结果为null</li></ul><h3 id="数据库的字段属性"><a href="#数据库的字段属性" class="headerlink" title="数据库的字段属性"></a>数据库的字段属性</h3><p>Unsigned：</p><ul><li>无符号整数</li><li>声明该列不能声明为负数</li></ul><p>Zerofill：</p><ul><li>0填充</li><li>不足的位数使用0来填充</li></ul><p>自增：</p><ul><li>自动在上一条的基础上+1(默认)</li><li>通常用来设计唯一的主键，必须是整数类型</li><li>可以自定义设计主键自增的起始值和步长</li></ul><p>非空：NULL not null</p><ul><li>假设设置为not null，如果不给它赋值就会报错</li><li>NULL，如果不填写值，默认就是NULL</li></ul><p>默认：</p><ul><li>设置默认值</li><li>sex，默认为男，如果不制定值，则为默认值</li></ul><h3 id="创建数据库表"><a href="#创建数据库表" class="headerlink" title="创建数据库表"></a>创建数据库表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `student` (<br>`id` <span class="hljs-type">INT</span>(<span class="hljs-number">4</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="hljs-string">&#x27;学员id&#x27;</span>,<br>`name` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;匿名&#x27;</span> COMMENT <span class="hljs-string">&#x27;姓名&#x27;</span>,<br>`pwd` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;123456&#x27;</span> COMMENT <span class="hljs-string">&#x27;密码&#x27;</span>,<br>`sex` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">2</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;女&#x27;</span> COMMENT <span class="hljs-string">&#x27;性别&#x27;</span>,<br>`birthday` DATETIME <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;出生日期&#x27;</span>,<br>`address` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;家庭住址&#x27;</span>,<br>`email` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;邮箱&#x27;</span>,<br><span class="hljs-comment">-- primary key加到最后面，一般一个表只有一个</span><br><span class="hljs-keyword">PRIMARY</span> KEY(`id`)<br>)ENGINE<span class="hljs-operator">=</span>INNODB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8<br></code></pre></td></tr></table></figure><p>格式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> [IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span>] `<span class="hljs-keyword">table</span> name`(<br>`<span class="hljs-type">char</span> name` col_type [attribute] [index] [comment],<br>    ...<br>`<span class="hljs-type">char</span> name` col_type [attribute] [index] [comment]<br>)[table_type][charset][comment]<br></code></pre></td></tr></table></figure><p>常用命令</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">CREATE</span> DATABASE name  <span class="hljs-comment">-- 查看创建数据库的语句</span><br>... <span class="hljs-keyword">TABLE</span> name<br><span class="hljs-keyword">DESC</span> <span class="hljs-keyword">TABLE</span> name <span class="hljs-comment">--显示表的结构</span><br></code></pre></td></tr></table></figure><h3 id="数据表类型"><a href="#数据表类型" class="headerlink" title="数据表类型"></a>数据表类型</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 关于数据库的引擎</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">INNODB  默认使用</span><br><span class="hljs-comment">MYISAM  早些年使用</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><table><thead><tr><th></th><th>MYISAM</th><th>INNODB</th></tr></thead><tbody><tr><td>事务支持</td><td>不支持</td><td>支持</td></tr><tr><td>数据行锁定</td><td>不支持</td><td>支持</td></tr><tr><td>外键约束</td><td>不支持</td><td>支持</td></tr><tr><td>全文索引</td><td>支持</td><td>不支持</td></tr><tr><td>表空间的大小</td><td>较小</td><td>较大，约为2倍</td></tr></tbody></table><p>常规使用操作：</p><ul><li>MYISAM 节约空间，速度较快</li><li>INNODB 安全性高，支持事务处理，多表多用户操作</li></ul><blockquote><p>在物理空间存在的位置</p></blockquote><p>所有的数据库文件都存在data目录下，一个文件夹对应一个数据库</p><p>本质还是文件存储</p><blockquote><p>设置数据库表的字符集编码</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">CHARSET<span class="hljs-operator">=</span>utf8<br></code></pre></td></tr></table></figure><p>不设置的话，会使用mysql默认的字符集编码~</p><p>MySQL默认编码是Latin1，不支持中文</p><p>在my.ini中配置默认的编码</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">character-set-server</span>=utf8<br></code></pre></td></tr></table></figure><h3 id="修改删除表"><a href="#修改删除表" class="headerlink" title="修改删除表"></a>修改删除表</h3><blockquote><p>修改</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 修改表名</span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> student RENAME <span class="hljs-keyword">AS</span> teacher<br><span class="hljs-comment">-- 增加表的字段</span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `teacher` <span class="hljs-keyword">ADD</span> `age` <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>)<br><span class="hljs-comment">-- 修改表的字段</span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `teacher` MODIFY age <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10</span>)   <span class="hljs-comment">-- 修改约束</span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `teacher` CHANGE age age1 <span class="hljs-type">INT</span>(<span class="hljs-number">1</span>)   <span class="hljs-comment">-- 字段重命名</span><br><span class="hljs-comment">-- 删除表的字段</span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `teacher` <span class="hljs-keyword">DROP</span> age1<br></code></pre></td></tr></table></figure><blockquote><p>删除</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 删除表</span><br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> [iF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span>] `teacher`<br></code></pre></td></tr></table></figure><p><strong>所有创建和删除的操作尽量加上判断，以免报错</strong></p><p>注意点：</p><ul><li>所有字段名尽量用&#96;&#96;包裹起来</li><li>注释 – 、&#x2F;**&#x2F;</li><li>sql 关键字大小写不敏感，建议小写</li><li>所有符号用英文</li></ul><h2 id="MySQL数据管理"><a href="#MySQL数据管理" class="headerlink" title="MySQL数据管理"></a>MySQL数据管理</h2><h3 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h3><p><img src="/2023/01/10/MySQL/image-20200914194621041.png" alt="image-20200914194621041"></p><blockquote><p>方式1：在创建表的时候，增加约束（比较复杂）</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `grade`(<br>`gradeid` <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="hljs-string">&#x27;年级id&#x27;</span>,<br>`gradename` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;年级名称&#x27;</span>,<br><span class="hljs-keyword">PRIMARY</span> KEY(`gradeid`)<br>)ENGINE<span class="hljs-operator">=</span>INNODB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8<br><br><span class="hljs-comment">-- 学生表的gradeid字段需要引用年级表的gradeid</span><br><span class="hljs-comment">-- 定义外键key</span><br><span class="hljs-comment">-- 给这个外键添加约束（执行引用）</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `student` (<br>`id` <span class="hljs-type">INT</span>(<span class="hljs-number">4</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="hljs-string">&#x27;学员id&#x27;</span>,<br>`name` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;匿名&#x27;</span> COMMENT <span class="hljs-string">&#x27;姓名&#x27;</span>,<br>`pwd` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;123456&#x27;</span> COMMENT <span class="hljs-string">&#x27;密码&#x27;</span>,<br>`sex` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">2</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;女&#x27;</span> COMMENT <span class="hljs-string">&#x27;性别&#x27;</span>,<br>`birthday` DATETIME <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;出生日期&#x27;</span>,<br>`gradeid` <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;学生年级&#x27;</span>,<br>`address` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;家庭住址&#x27;</span>,<br>`email` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;邮箱&#x27;</span>,<br><span class="hljs-comment">-- primary key加到最 后面，一般一个表只有一个</span><br><span class="hljs-keyword">PRIMARY</span> KEY(`id`),<br>KEY `FK_gradeid` (`gradeid`),  <span class="hljs-comment">-- 打算作为外键</span><br><span class="hljs-keyword">CONSTRAINT</span> `FK_gradeid` <span class="hljs-keyword">FOREIGN</span> KEY (`gradeid`) <span class="hljs-keyword">REFERENCES</span> `grade` (`gradeid`)<br>)ENGINE<span class="hljs-operator">=</span>INNODB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8<br></code></pre></td></tr></table></figure><p>删除有外键关系的表的时候，必须先删除引用别人的表（从表），再删除被引用的表（主表）</p><blockquote><p>方式2：添加表成功后，再添加外键约束</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 创建表时没有外键关系</span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `student`<br><span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> `FK_gradeid` <span class="hljs-keyword">FOREIGN</span> KEY (`gradeid`) <span class="hljs-keyword">REFERENCES</span> `grade` (`gradeid`);<br><br><span class="hljs-comment">-- alter table 表 add constraint 约束名 foreign key （作为外键的列） references 被引用的表（被引用的字段）</span><br></code></pre></td></tr></table></figure><p>以上操作都是物理外键，数据库级别的外键，不建议使用！避免数据库过多造成困扰，这里了解即可</p><p><strong>最佳实现：</strong></p><ul><li>数据库就是单纯的表，只用来存数据，只有行（数据）和列（字段）</li><li>我们想使用多张表的数据，想使用外键（程序去实现）</li></ul><h3 id="DML语言"><a href="#DML语言" class="headerlink" title="DML语言"></a>DML语言</h3><p><strong>数据库意义：</strong>数据存储，数据管理</p><p>DML语言：数据操作语言</p><ul><li>insert</li><li>update</li><li>delete</li></ul><h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 插入语句（添加）</span><br><span class="hljs-comment">-- insert into 表名 （[字段名1， 字段2 ...])（相当于构造参数） values(&#x27;值1’), (&#x27;值2&#x27;), (&#x27;值3&#x27;)...（相当于对象）</span><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `grade`(`gradename`) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;大四&#x27;</span>)<br><br><span class="hljs-comment">-- 由于主键自增，可以省略主键（如果不写表的字段，就会一一匹配）</span><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `grade` <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;大三&#x27;</span>)  <span class="hljs-comment">-- 错误，因为会默认插入到gradeid中</span><br><br><span class="hljs-comment">-- 一般写插入语句，需要数据和字段一一对应!</span><br><span class="hljs-comment">-- 插入多个字段</span><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `grade`<br>(`gradename`)<br><span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;大一&#x27;</span>),(<span class="hljs-string">&#x27;大二&#x27;</span>),(<span class="hljs-string">&#x27;大三&#x27;</span>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `student`<br>(`name`,`pwd`)<br><span class="hljs-keyword">VALUES</span><br>(<span class="hljs-string">&#x27;张三&#x27;</span>,<span class="hljs-string">&#x27;123456&#x27;</span>),<br>(<span class="hljs-string">&#x27;李四&#x27;</span>,<span class="hljs-string">&#x27;345678&#x27;</span>);<br></code></pre></td></tr></table></figure><p>注意事项：</p><ol><li>字段和字段之间使用英文逗号隔开</li><li>字段可以省略，但是值必须一一对应（不建议，容易出错）</li><li>可以同时插入多条数据，VALUES后面的值需要使用逗号隔开</li></ol><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><blockquote><p>update 修改对象（条件）  set原来的值 -&gt; 新值</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 修改学员的名字</span><br><span class="hljs-comment">-- 带了条件</span><br><span class="hljs-keyword">UPDATE</span> `student`<br><span class="hljs-keyword">SET</span> `name`<span class="hljs-operator">=</span><span class="hljs-string">&#x27;shuwen&#x27;</span><br><span class="hljs-keyword">WHERE</span> `id`<span class="hljs-operator">=</span><span class="hljs-number">1</span>;<br><br><span class="hljs-comment">-- 不制定条件的情况下，会改动所有的表!</span><br><span class="hljs-keyword">UPDATE</span> `student`<br><span class="hljs-keyword">SET</span> `name`<span class="hljs-operator">=</span><span class="hljs-string">&#x27;Apocalypse&#x27;</span>;<br><br><span class="hljs-comment">-- 修改多个属性</span><br><span class="hljs-keyword">UPDATE</span> `student`<br><span class="hljs-keyword">SET</span> `name`<span class="hljs-operator">=</span><span class="hljs-string">&#x27;chen&#x27;</span>, `email`<span class="hljs-operator">=</span><span class="hljs-string">&#x27;1136@qq.com&#x27;</span><br><span class="hljs-keyword">WHERE</span> id<span class="hljs-operator">=</span><span class="hljs-number">1</span>;<br><br><span class="hljs-comment">-- 语法</span><br><span class="hljs-comment">-- update 表名 set column_name = value,[column_name=value,...] where 条件</span><br></code></pre></td></tr></table></figure><p>条件：where子句 运算符 id 等于，大于，小于某个值，在某个区间内修改… …</p><p>操作符会返回boolean值</p><table><thead><tr><th>操作符</th><th>意义</th><th>范围</th><th>结果</th></tr></thead><tbody><tr><td>&#x3D;</td><td>等于</td><td></td><td></td></tr><tr><td>&lt;&gt; 或 !&#x3D;</td><td>不等于</td><td></td><td></td></tr><tr><td>&gt;</td><td></td><td></td><td></td></tr><tr><td>&lt;</td><td></td><td></td><td></td></tr><tr><td>&gt;&#x3D;</td><td></td><td></td><td></td></tr><tr><td>&lt;&#x3D;</td><td></td><td></td><td></td></tr><tr><td>BETWEEN … AND …</td><td>闭区间[x,y]</td><td>BETWEEN id&#x3D;2 AND id&#x3D;5</td><td></td></tr><tr><td>AND</td><td>相当于&amp;&amp;</td><td>5&gt;1 and 1&gt;2</td><td>false</td></tr><tr><td>OR</td><td>相当于||</td><td>5&gt;1 or 1&gt;2</td><td>true</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 通过多个条件定位数据, 无上限</span><br><span class="hljs-keyword">UPDATE</span> `student`<br><span class="hljs-keyword">SET</span> `name`<span class="hljs-operator">=</span><span class="hljs-string">&#x27;hao&#x27;</span><br><span class="hljs-keyword">WHERE</span> `name`<span class="hljs-operator">=</span><span class="hljs-string">&#x27;shuwen&#x27;</span> <span class="hljs-keyword">AND</span> id<span class="hljs-operator">=</span><span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li><p>使用column列尽量带上&#96;&#96;</p></li><li><p>筛选条件，如果没有指定则会修改所有的列</p></li><li><p>value是一个具体的值，也可以是一个变量</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 可以设置值为某个变量</span><br><span class="hljs-keyword">UPDATE</span> `student`<br><span class="hljs-keyword">SET</span> `birthday`<span class="hljs-operator">=</span><span class="hljs-built_in">CURRENT_TIME</span><br><span class="hljs-keyword">WHERE</span> `name`<span class="hljs-operator">=</span><span class="hljs-string">&#x27;hao&#x27;</span>;<br></code></pre></td></tr></table></figure></li><li><p>多个设置的属性之间使用英文逗号隔开</p></li></ul><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><blockquote><p>delete命令</p></blockquote><p>语法：delete from 表名 [where 条件]</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 删除指定数据</span><br><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> `student` <span class="hljs-keyword">WHERE</span> id<span class="hljs-operator">=</span><span class="hljs-number">1</span>;<br><br><span class="hljs-comment">-- 切忌！</span><br><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> `student` <span class="hljs-comment">-- 会删除整张表</span><br></code></pre></td></tr></table></figure><blockquote><p>TRUNCATE 命令</p></blockquote><p>  作用：完全清空一个数据库表，表的结果和索引约束不会变!</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 清空 student 表</span><br><span class="hljs-keyword">TRUNCATE</span> `student`;<br></code></pre></td></tr></table></figure><blockquote><p>delete 和truncate的区别：</p></blockquote><ul><li><p>相同点：都能删除数据，都不会删除表结构</p></li><li><p>不同点：</p><ul><li><p>truncate命令会重新设置自增列，计数器会归零</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 不会影响自增</span><br><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> `test`;<br><br><span class="hljs-comment">-- 会重置自增，归零</span><br><span class="hljs-keyword">TRUNCATE</span> <span class="hljs-keyword">TABLE</span> `test`;<br></code></pre></td></tr></table></figure></li><li><p>truncate不会影响事务</p></li></ul></li></ul><p>delete删除的问题：重启数据库，会发生现象：</p><ul><li>INNODB 自增列会从1开始，(存在内存当中，断点即失)</li><li>MyISAM 继续从上一个自增量开始 (存在文件中，不会丢失)</li></ul><h2 id="DQL查询数据"><a href="#DQL查询数据" class="headerlink" title="DQL查询数据"></a>DQL查询数据</h2><h3 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h3><p>（Data Query Language: 数据查询语言）</p><ul><li>所有的查询操作都使用它 Select</li><li>简单的查询，复杂的查询都能做</li><li>数据库中最核心的语言</li><li>使用频率最高</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> [<span class="hljs-keyword">ALL</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">DISTINCT</span>]<br>&#123;<span class="hljs-operator">*</span> <span class="hljs-operator">|</span>table.<span class="hljs-operator">*</span> <span class="hljs-operator">|</span> [table.field1[<span class="hljs-keyword">as</span> alias1][,table.field2[<span class="hljs-keyword">as</span> alias2]][,...]]&#125;<br><span class="hljs-keyword">FROM</span> table_name [<span class="hljs-keyword">as</span> table_alias]<br>[<span class="hljs-keyword">left</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">right</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> table_name2] <span class="hljs-comment">-- 联合查询</span><br>[<span class="hljs-keyword">where</span> ...]  <span class="hljs-comment">--指定结果需要满足的条件</span><br>[<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> ...] <span class="hljs-comment">-- 指定结果按照哪几个字段来分组</span><br>[<span class="hljs-keyword">having</span> ...] <span class="hljs-comment">-- 过滤分组的记录必须满足的次要条件</span><br>[<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> ...] <span class="hljs-comment">-- 指定查询记录按照一个或者多个条件排序</span><br>[limit &#123;[<span class="hljs-keyword">offset</span>,]row_count <span class="hljs-operator">|</span> row_countOFFSET <span class="hljs-keyword">offset</span>&#125;];<br><span class="hljs-comment">-- 指定查询的记录从哪条至哪条</span><br></code></pre></td></tr></table></figure><p>顺序很重要：</p><p>select 去重 查询的字段（主义：表和字段可以取别名）</p><p>xx join 要连接的表 on 等值判断</p><p>where (具体的值， 子查询语句)</p><p>group by(通过哪个字段来分组)</p><p>having （过滤分组后的信息，条件和where一样，位置不同）</p><p>order by（通过哪个字段排序）[升序&#x2F;降序]</p><p>limit startindex, pagesize</p><p>查询：跨表，跨数据库</p><h3 id="指定查询字段"><a href="#指定查询字段" class="headerlink" title="指定查询字段"></a>指定查询字段</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查询所有字段   SELECT 字段 FROM 表</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> student<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">result</span><br><br><span class="hljs-comment">-- 查询指定字段</span><br><span class="hljs-keyword">SELECT</span> `studentno`,`studentname` <span class="hljs-keyword">FROM</span> student<br><br><span class="hljs-comment">-- 别名，给结果起一个名字 AS，也可以给字段起别名，也可以给表起别名</span><br><span class="hljs-keyword">SELECT</span> `studentno` <span class="hljs-keyword">AS</span> 学号,`studentname` <span class="hljs-keyword">AS</span> 姓名 <span class="hljs-keyword">FROM</span> student<br><br><span class="hljs-comment">-- 函数 concat(a, b)</span><br><span class="hljs-keyword">SELECT</span> CONCAT(<span class="hljs-string">&#x27;姓名:&#x27;</span>,studentname) <span class="hljs-keyword">AS</span> 新名字 <span class="hljs-keyword">FROM</span> student<br></code></pre></td></tr></table></figure><p>语法：select 字段1,… from 表</p><blockquote><p>有的时候，列名字不是那么见名知意，可以其别名 AS 字段名 as 别名; 表名 as 别名</p></blockquote><blockquote><p>去重 distinct</p></blockquote><p>作用：去除SELECT查询出来的结果中重复的数据，重复的数据只显示一条</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查询一下有哪些同学有成绩</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">result</span>  <span class="hljs-comment">-- 查询全部的考试成绩</span><br><span class="hljs-keyword">SELECT</span> `studentno` <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">result</span><br><span class="hljs-comment">-- 需要去重</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> `studentno` <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">result</span><br></code></pre></td></tr></table></figure><blockquote><p>数据库的列（表达式）</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查询系统的版本</span><br><span class="hljs-keyword">SELECT</span> VERSION()  <span class="hljs-comment">-- 函数</span><br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-number">100</span><span class="hljs-operator">*</span><span class="hljs-number">3</span><span class="hljs-number">-1</span> <span class="hljs-keyword">AS</span> 计算结果  <span class="hljs-comment">-- 计算表达式</span><br><br><span class="hljs-keyword">SELECT</span> @<span class="hljs-variable">@auto</span>_increment_increment  <span class="hljs-comment">-- 查询自增的步长（变量）</span><br><br><span class="hljs-comment">-- 学员考试成绩+1分</span><br><span class="hljs-keyword">SELECT</span> `studentno`,`studentresult`<span class="hljs-operator">+</span><span class="hljs-number">1</span> <span class="hljs-keyword">AS</span> 提分后 <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">result</span><br></code></pre></td></tr></table></figure><p>数据库中的表达式：文本的值，列，NULL，函数，计算表达式… …</p><p>select 表达式 from 表</p><h3 id="where条件子句"><a href="#where条件子句" class="headerlink" title="where条件子句"></a>where条件子句</h3><p>作用：检索数据中符合条件的值</p><p>搜索的条件由一个或者多个表达式组成</p><blockquote><p>逻辑运算符</p></blockquote><p>与或非</p><p>and &amp;&amp;</p><p>or ||</p><p>Not !</p><p>尽量使用英文字母</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查询考试成绩在90-120之间</span><br><span class="hljs-keyword">SELECT</span> `studentno`,`studentresult` <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">result</span><br><span class="hljs-keyword">WHERE</span> `studentresult` <span class="hljs-operator">&gt;=</span> <span class="hljs-number">90</span> <span class="hljs-keyword">AND</span> `studentresult` <span class="hljs-operator">&lt;=</span> <span class="hljs-number">120</span><br><br><span class="hljs-comment">-- 模糊查询</span><br><span class="hljs-keyword">SELECT</span> `studentno`,`studentresult` <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">result</span><br><span class="hljs-keyword">WHERE</span> `studentresult` <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">95</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">120</span><br><br><span class="hljs-comment">-- 除了1000号学生之外的成绩</span><br><span class="hljs-keyword">SELECT</span> `studentno`,`studentresult` <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">result</span><br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">NOT</span> `studentno`<span class="hljs-operator">=</span><span class="hljs-number">1000</span><br><span class="hljs-comment">-- where `studentno` != 1000</span><br></code></pre></td></tr></table></figure><blockquote><p>模糊查询：比较运算符</p></blockquote><table><thead><tr><th>运算符</th><th>语法</th><th>描述</th></tr></thead><tbody><tr><td>IS NULL</td><td>a is null</td><td>如果操作符为null,则结果为真</td></tr><tr><td>IS NOT NULL</td><td>a is not null</td><td>如果操作符不为null，则结果为真</td></tr><tr><td>BETWEEN… AND…</td><td>a between b and c</td><td>a 在 b 和 c之间则返回真</td></tr><tr><td><strong>Like</strong></td><td>A LIke b</td><td>SQL匹配：如果a能够匹配到b，结果为真</td></tr><tr><td><strong>In</strong></td><td>a in (a1,a2,a3… )</td><td>假设a在a1,a2,a3…其中的某一个值中，则结果为真</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 模糊查询</span><br><span class="hljs-keyword">SELECT</span> `studentno`,`studentresult` <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">result</span><br><span class="hljs-keyword">WHERE</span> `studentresult` <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">95</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">120</span><br><br><span class="hljs-comment">-- 除了1000号学生之外的成绩</span><br><span class="hljs-keyword">SELECT</span> `studentno`,`studentresult` <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">result</span><br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">NOT</span> `studentno`<span class="hljs-operator">=</span><span class="hljs-number">1000</span><br><span class="hljs-comment">-- where `studentno` != 1000</span><br><br><span class="hljs-comment">-- 查询姓刘的同学</span><br><span class="hljs-comment">-- like结合 %(0到任意个字符) _（一个字符）</span><br><span class="hljs-keyword">SELECT</span> `studentno`,`studentname` <span class="hljs-keyword">FROM</span> student<br><span class="hljs-keyword">WHERE</span> `studentname` <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;刘%&#x27;</span><br><br><span class="hljs-comment">-- 查询姓刘的同学，名字后面只有一个字</span><br><span class="hljs-keyword">SELECT</span> `studentno`,`studentname` <span class="hljs-keyword">FROM</span> student<br><span class="hljs-keyword">WHERE</span> `studentname` <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;刘_&#x27;</span><br><br><span class="hljs-comment">-- 查询名字当中有伟字的同学</span><br><span class="hljs-keyword">SELECT</span> `studentno`,`studentname` <span class="hljs-keyword">FROM</span> student<br><span class="hljs-keyword">WHERE</span> `studentname` <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%伟%&#x27;</span><br><br><span class="hljs-comment">-- in（具体是一个或者多个值） 查询1001,1002,1003号学员信息</span><br><span class="hljs-keyword">SELECT</span> `studentno`,`studentname` <span class="hljs-keyword">FROM</span> student<br><span class="hljs-keyword">WHERE</span> `studentno` <span class="hljs-keyword">IN</span> (<span class="hljs-number">1001</span>,<span class="hljs-number">1002</span>,<span class="hljs-number">1003</span>);<br><br><span class="hljs-comment">-- 查询在北京的学生</span><br><span class="hljs-keyword">SELECT</span> `studentno`,`studentname` <span class="hljs-keyword">FROM</span> student<br><span class="hljs-keyword">WHERE</span> `address` <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%湖北%&#x27;</span>;<br><br><span class="hljs-keyword">SELECT</span> `studentno`,`studentname` <span class="hljs-keyword">FROM</span> student<br><span class="hljs-keyword">WHERE</span> `address`<span class="hljs-operator">=</span><span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-keyword">OR</span> address <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>;<br><br><span class="hljs-comment">-- 查询有出生日期的同学</span><br><span class="hljs-keyword">SELECT</span> `studentno`,`studentname` <span class="hljs-keyword">FROM</span> student<br><span class="hljs-keyword">WHERE</span>  `borndate` <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>;<br></code></pre></td></tr></table></figure><h3 id="联表查询"><a href="#联表查询" class="headerlink" title="联表查询"></a>联表查询</h3><blockquote><p>JOIN 对比</p></blockquote><p><img src="/2023/01/10/MySQL/image-20200920191058689.png" alt="image-20200920191058689"></p><p><img src="/2023/01/10/MySQL/image-20200920191421788.png" alt="image-20200920191421788"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 联表查询<br>-- 查询参加了考试的同学（学号，姓名，科目编号，分数）<br>SELECT * FROM student<br>SELECT * FROM result<br><br>/*<br>思路：<br>1.需求：分析查询的字段来自哪些表，（连接查询）<br>2.确定使用哪种连接查询？7种<br>3.确定一个交叉点（这两个表中哪个数据是相同的）<br>判断的条件：学生表中的studentno = 成绩表中的studentno<br>*/<br><br>-- join（连接的表） on（判断条件） 连接查询<br>-- where 等值查询<br><br><br>SELECT s.studentno, studentname, subjectno, studentresult<br>FROM student AS s<br>INNER JOIN result AS r<br>WHERE s.studentno = r.studentno<br><br>-- Right Join<br>SELECT s.studentno, studentname, subjectno, studentresult<br>FROM student AS s<br>RIGHT JOIN result AS r<br>ON s.studentno = r.studentno<br><br>SELECT s.studentno, studentname, subjectno, studentresult<br>FROM student AS s<br>LEFT JOIN result AS r<br>ON s.studentno = r.studentno<br>WHERE studentresult IS NULL<br><br>-- 查询了参加的考试的同学信息：学号，学生姓名，科目名称，分数<br>/*<br>思路：<br>1.需求：分析查询的字段来自哪些表，student, result, subject（连接查询）<br>2.确定使用哪种连接查询？7种<br>3.确定一个交叉点（这两个表中哪个数据是相同的） <br>判断的条件：学生表中的studentno = 成绩表中的studentno<br>*/<br><br>SELECT s.studentno, studentname, subjectname, studentresult<br>FROM student s<br>RIGHT JOIN result r<br>ON r.studentno = s.studentno<br>INNER JOIN `subject` sub<br>ON r.subjectno = sub.subjectno<br><br>-- 我要查询哪些数据 select ...<br>-- 从哪几个表中查 from 表 xxx join 表<br>-- on 交叉条件<br>-- 假设存在一种多张表查询，先查询两张表，然后再慢慢增加<br><br>-- from A left join B<br>-- from B right join A<br></code></pre></td></tr></table></figure><table><thead><tr><th>操作</th><th>描述</th></tr></thead><tbody><tr><td>inner join</td><td>如果表中至少有一个匹配，就返回行</td></tr><tr><td>left join</td><td>即使右表中没有匹配，也会从左表中返回对应的值</td></tr><tr><td>right join</td><td>和left join相反</td></tr></tbody></table><blockquote><p>自连接</p></blockquote><p> 自己的表和自己的表连接，核心：一张表拆为两张一样的表即可</p><p>示例表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `category`(<br>`categoryid` <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) UNSIGNED <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT COMMENT<span class="hljs-string">&#x27;主题id&#x27;</span>,<br>`pid` <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;父id&#x27;</span>,<br>`categoryName` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;主题名字&#x27;</span>,<br><span class="hljs-keyword">PRIMARY</span> KEY(`categoryid`)<br>)ENGINE<span class="hljs-operator">=</span>INNODB AUTO_INCREMENT<span class="hljs-operator">=</span><span class="hljs-number">9</span> <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `category` (`categoryid`, `pid`, `categoryName`)<br><span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;信息技术&#x27;</span>),<br>(<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;软件开发&#x27;</span>),<br>(<span class="hljs-string">&#x27;4&#x27;</span>,<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-string">&#x27;数据库&#x27;</span>),<br>(<span class="hljs-string">&#x27;5&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;美术设计&#x27;</span>),<br>(<span class="hljs-string">&#x27;6&#x27;</span>,<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-string">&#x27;web开发&#x27;</span>),<br>(<span class="hljs-string">&#x27;7&#x27;</span>,<span class="hljs-string">&#x27;5&#x27;</span>,<span class="hljs-string">&#x27;ps技术&#x27;</span>),<br>(<span class="hljs-string">&#x27;8&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&#x27;办公信息&#x27;</span>);<br></code></pre></td></tr></table></figure><p>父类</p><table><thead><tr><th>categoryid</th><th>categoryName</th></tr></thead><tbody><tr><td>2</td><td>信息技术</td></tr><tr><td>3</td><td>软件开发</td></tr><tr><td>5</td><td>美术设计</td></tr></tbody></table><p>子类</p><table><thead><tr><th>pid</th><th>categoryid</th><th>categoryName</th></tr></thead><tbody><tr><td>3</td><td>4</td><td>数据库</td></tr><tr><td>2</td><td>8</td><td>办公信息</td></tr><tr><td>3</td><td>6</td><td>web开发</td></tr><tr><td>5</td><td>7</td><td>美术设计</td></tr></tbody></table><p>操作：查询父类对应的子类关系</p><table><thead><tr><th>父类</th><th>子类</th></tr></thead><tbody><tr><td>信息技术</td><td>办公信息</td></tr><tr><td>软件开发</td><td>数据库</td></tr><tr><td>软件开发</td><td>web开发</td></tr><tr><td>美术设计</td><td>ps技术</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查询父类信息:把一张表分成两张一模一样的表</span><br><span class="hljs-keyword">SELECT</span> a.categoryName <span class="hljs-keyword">AS</span> <span class="hljs-string">&#x27;父栏目&#x27;</span>, b.categoryName <span class="hljs-keyword">AS</span> <span class="hljs-string">&#x27;子栏目&#x27;</span><br><span class="hljs-keyword">FROM</span> category <span class="hljs-keyword">AS</span> a, category <span class="hljs-keyword">AS</span> b<br><span class="hljs-keyword">WHERE</span> a.`categoryid` <span class="hljs-operator">=</span> b.`pid`<br></code></pre></td></tr></table></figure><h3 id="分页和排序"><a href="#分页和排序" class="headerlink" title="分页和排序"></a>分页和排序</h3><blockquote><p>排序</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 分页和排序 limit order by</span><br><span class="hljs-comment">-- 排序：升序ASC，降序DESC</span><br><span class="hljs-comment">-- order by 通过哪个字段排序，怎么排</span><br><br><span class="hljs-comment">-- 查询的结果根据成绩降序排序</span><br><span class="hljs-keyword">SELECT</span> s.studentno, studentname, subjectname, studentresult<br><span class="hljs-keyword">FROM</span> student s<br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> `<span class="hljs-keyword">result</span>` r<br><span class="hljs-keyword">ON</span> s.studentno <span class="hljs-operator">=</span> r.studentno<br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> `subject` sub<br><span class="hljs-keyword">ON</span> r.subjectno <span class="hljs-operator">=</span> sub.subjectno<br><span class="hljs-keyword">WHERE</span> subjectname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;高等数学-1&#x27;</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> studentresult <span class="hljs-keyword">ASC</span><br></code></pre></td></tr></table></figure><blockquote><p>分页</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 100万数据无法直接显示在前端</span><br><span class="hljs-comment">-- 分页的原因</span><br><span class="hljs-comment">-- 缓解数据压力，但也可以使用瀑布流（如百度图片）</span><br><span class="hljs-comment">-- 每页只显示5条数据</span><br><span class="hljs-comment">-- limit 起始位置, 页面的大小</span><br><span class="hljs-comment">-- limit 0,5 1~5</span><br><span class="hljs-comment">-- limit 1,5 2~6</span><br><span class="hljs-comment">-- limit 6,5 7~11</span><br><span class="hljs-comment">-- 网页应用：当前，总页数，页面的大小</span><br><span class="hljs-comment">-- 第一页 limit 0,5</span><br><span class="hljs-comment">-- 第二页 limit 5,5</span><br><span class="hljs-comment">-- 第三页 limit 10,5</span><br><span class="hljs-comment">-- 第n页 limit 5n-5, 5 (n-1)*pageSize, pageSize</span><br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> `subject`<br>LIMIT <span class="hljs-number">6</span>,<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>语法：limit (查询起始下标，pageSize)</p><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>where (这个值是计算出来的)</p><p>本质：在where语句中嵌套一个子查询语句</p><p>where(select * from )</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 1.查询 高等数学-1 的所有考试结果 （学号，科目编号， 成绩），降序排列</span><br><span class="hljs-comment">-- 方式一：使用连接查询</span><br><span class="hljs-keyword">SELECT</span> studentno, r.subjectno, studentresult<br><span class="hljs-keyword">FROM</span> <span class="hljs-keyword">result</span> r<br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> `subject` sub<br><span class="hljs-keyword">ON</span> r.subjectno <span class="hljs-operator">=</span> sub.subjectno<br><span class="hljs-keyword">WHERE</span> subjectname <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;高等数学-1&#x27;</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> studentresult <span class="hljs-keyword">DESC</span><br><br><span class="hljs-comment">-- 方式二：使用子查询(由里及外)</span><br><span class="hljs-keyword">SELECT</span> studentno, subjectno, studentresult<br><span class="hljs-keyword">FROM</span> <span class="hljs-keyword">result</span><br><span class="hljs-keyword">WHERE</span> subjectno <span class="hljs-operator">=</span> (<span class="hljs-keyword">SELECT</span> subjectno <span class="hljs-keyword">FROM</span> `subject` <span class="hljs-keyword">WHERE</span> subjectname <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;高等数学-1&#x27;</span>)<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> studentresult <span class="hljs-keyword">DESC</span><br><br><span class="hljs-comment">-- 查询分数不小于80的学生的学号和姓名，高等数学-2</span><br><span class="hljs-comment">-- 查询高等数学-2 的编号</span><br><span class="hljs-keyword">SELECT</span> studentname, s.studentno, studentresult<br><span class="hljs-keyword">FROM</span> student s<br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">result</span> r<br><span class="hljs-keyword">ON</span> s.studentno <span class="hljs-operator">=</span> r.studentno<br><span class="hljs-keyword">WHERE</span> r.studentresult <span class="hljs-operator">&gt;=</span> <span class="hljs-number">80</span> <span class="hljs-keyword">AND</span> subjectno <span class="hljs-operator">=</span> (<br><span class="hljs-keyword">SELECT</span> subjectno <span class="hljs-keyword">FROM</span> `subject`<br><span class="hljs-keyword">WHERE</span> subjectname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;高等数学-2&#x27;</span><br>)<br><br><span class="hljs-comment">-- 查询所有高等数学-1 的学生学号</span><br></code></pre></td></tr></table></figure><p>嵌套查询</p><p>在子查询语句里面再嵌套一层子查询语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 再改造</span><br><span class="hljs-keyword">SELECT</span> studentno, studentname<br><span class="hljs-keyword">FROM</span> student s<br><span class="hljs-comment">-- 如果查询的结果不唯一，则使用in</span><br><span class="hljs-keyword">WHERE</span> studentno <span class="hljs-keyword">IN</span> (<br><span class="hljs-keyword">SELECT</span> studentno <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">result</span> <span class="hljs-keyword">WHERE</span> studentresult <span class="hljs-operator">&gt;=</span> <span class="hljs-number">80</span><br><span class="hljs-keyword">AND</span><br>subjectno <span class="hljs-operator">=</span> (<br><span class="hljs-keyword">SELECT</span> subjectno <span class="hljs-keyword">FROM</span> `subject` <span class="hljs-keyword">WHERE</span> subjectname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;高等数学-2&#x27;</span><br>)<br>)<br></code></pre></td></tr></table></figure><h3 id="分组和过滤"><a href="#分组和过滤" class="headerlink" title="分组和过滤"></a>分组和过滤</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查询不同课程的平均分，最高分，最低分，平均分大于80</span><br><span class="hljs-comment">-- 核心：（根据不同的课程分组）</span><br><span class="hljs-keyword">SELECT</span> SubjectName, <span class="hljs-built_in">AVG</span>(StudentResult) <span class="hljs-keyword">AS</span> 平均分, <span class="hljs-built_in">MAX</span>(StudentResult) <span class="hljs-keyword">AS</span> 最高分, <span class="hljs-built_in">MIN</span>(StudentResult) <span class="hljs-keyword">AS</span> 最低分<br><span class="hljs-keyword">FROM</span> <span class="hljs-keyword">result</span> r<br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> `subject` sub<br><span class="hljs-keyword">ON</span> r.`subjectno` <span class="hljs-operator">=</span> sub.`subjectno`<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> r.`subjectno`   <span class="hljs-comment">-- 通过什么字段来分组</span><br><span class="hljs-keyword">HAVING</span> 平均分 <span class="hljs-operator">&gt;</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><h2 id="MySQL函数"><a href="#MySQL函数" class="headerlink" title="MySQL函数"></a>MySQL函数</h2><p>官网地址：<a href="https://dev.mysql.com/doc/refman/5.7/en/func-op-summary-ref.html">https://dev.mysql.com/doc/refman/5.7/en/func-op-summary-ref.html</a></p><h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 数学运算</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">ABS</span>(<span class="hljs-number">-8</span>)  <span class="hljs-comment">-- 绝对值</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">CEILING</span>(<span class="hljs-number">1.1</span>) <span class="hljs-comment">-- 向上取整</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">FLOOR</span>(<span class="hljs-number">1.3</span>) <span class="hljs-comment">-- 向下取整</span><br><span class="hljs-keyword">SELECT</span> RAND() <span class="hljs-comment">-- 返回一个[0,1]之间的随机数</span><br><span class="hljs-keyword">SELECT</span> SIGN(<span class="hljs-number">-5</span>) <span class="hljs-comment">-- 判断符号 负数返回-1，正数返回1,0返回0</span><br><br><span class="hljs-comment">-- 字符串</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">CHAR_LENGTH</span>(<span class="hljs-string">&#x27;好&#x27;</span>) <span class="hljs-keyword">AS</span> len  <span class="hljs-comment">-- 字符串长度</span><br><span class="hljs-keyword">SELECT</span> CONCAT(<span class="hljs-string">&#x27;我爱&#x27;</span>,<span class="hljs-string">&#x27;Java&#x27;</span>) <span class="hljs-keyword">AS</span> str  <span class="hljs-comment">-- 拼接字符串</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">INSERT</span>(<span class="hljs-string">&#x27;I love code&#x27;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;truly &#x27;</span>) <span class="hljs-comment">-- 插入，替换</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">LOWER</span>(<span class="hljs-string">&#x27;ABC&#x27;</span>)<br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">UPPER</span>(<span class="hljs-string">&#x27;abc&#x27;</span>)<br><span class="hljs-keyword">SELECT</span> INSTR(<span class="hljs-string">&#x27;kuang&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>) <span class="hljs-comment">-- 查找子串在字符串中的位置</span><br><span class="hljs-keyword">SELECT</span> REPLACE(<span class="hljs-string">&#x27;life&#x27;</span>,<span class="hljs-string">&#x27;f&#x27;</span>,<span class="hljs-string">&#x27;v&#x27;</span>)  <span class="hljs-comment">-- 替换所有的指定字符串</span><br><span class="hljs-keyword">SELECT</span> SUBSTR(<span class="hljs-string">&#x27;livvve&#x27;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">-- 返回指定被截取子串</span><br><span class="hljs-keyword">SELECT</span> REVERSE(<span class="hljs-string">&#x27;hello&#x27;</span>) <span class="hljs-comment">-- 反转</span><br><br><span class="hljs-comment">-- 查询姓周的同学,将刘改为邹</span><br><span class="hljs-keyword">SELECT</span> REPLACE(studentname, <span class="hljs-string">&#x27;刘&#x27;</span>, <span class="hljs-string">&#x27;邹&#x27;</span>) <span class="hljs-keyword">FROM</span> student<br><span class="hljs-keyword">WHERE</span> studentname <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;刘%&#x27;</span><br><br><span class="hljs-comment">-- 时间和日期函数（记住）</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">CURRENT_DATE</span>() <span class="hljs-comment">-- 获取当前日期</span><br><span class="hljs-keyword">SELECT</span> CURDATE()<br><span class="hljs-keyword">SELECT</span> NOW()  <span class="hljs-comment">-- 获取当前时间</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">LOCALTIME</span>()  <span class="hljs-comment">-- 获取本地时间</span><br><span class="hljs-keyword">SELECT</span> SYSDATE()  <span class="hljs-comment">-- 获取系统时间</span><br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">YEAR</span>(NOW());<br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">MONTH</span>(NOW());<br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DAY</span>(NOW());<br><span class="hljs-keyword">SELECT</span>  <span class="hljs-keyword">HOUR</span>(NOW());<br><span class="hljs-keyword">SELECT</span>  <span class="hljs-keyword">MINUTE</span>(NOW());<br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">SECOND</span>(NOW())<br><br><span class="hljs-comment">-- 系统</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">SYSTEM_USER</span>()<br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">USER</span>()<br><span class="hljs-keyword">SELECT</span> VERSION()<br></code></pre></td></tr></table></figure><h3 id="聚合函数（更常用）"><a href="#聚合函数（更常用）" class="headerlink" title="聚合函数（更常用）"></a>聚合函数（更常用）</h3><table><thead><tr><th>函数名称</th><th>描述</th></tr></thead><tbody><tr><td>COUNT()</td><td></td></tr><tr><td>SUM()</td><td></td></tr><tr><td>AVG()</td><td></td></tr><tr><td>MAX()</td><td></td></tr><tr><td>MIN()</td><td></td></tr><tr><td>…</td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 聚合函数</span><br><span class="hljs-comment">-- 都能统计表中的数据</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(studentname) <span class="hljs-keyword">FROM</span> student;  <span class="hljs-comment">-- Count(字段)，会忽略所有的null值</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> student;   <span class="hljs-comment">-- Count(*)，不会忽略null值，本质计算行数</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">result</span>;    <span class="hljs-comment">-- Count(1)，不会忽略null值，本质计算行数，但只会检查一列</span><br><br></code></pre></td></tr></table></figure><h3 id="数据库级别的MD5加密"><a href="#数据库级别的MD5加密" class="headerlink" title="数据库级别的MD5加密"></a>数据库级别的MD5加密</h3><p>MD5：主要增强算法的复杂度和不可逆性。</p><p>MD5不可逆，具体的值md5是一样的</p><p>MD5破解网站的原理：背后有一个字典，MD5加密后的值 对比 加密前的值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 测试MD5 加密</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `testmd5`(<br>`id` <span class="hljs-type">INT</span>(<span class="hljs-number">4</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>`name` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>`pwd` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br><span class="hljs-keyword">PRIMARY</span> KEY(`id`)<br>)ENGINE<span class="hljs-operator">=</span>INNODB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8<br><br><span class="hljs-comment">-- 明文密码</span><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `testmd5` <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;zhangsan&#x27;</span>, <span class="hljs-string">&#x27;123456&#x27;</span>),<br>(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;lisi&#x27;</span>, <span class="hljs-string">&#x27;134567&#x27;</span>),<br>(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;wangwu&#x27;</span>, <span class="hljs-string">&#x27;134567&#x27;</span>);<br><br><span class="hljs-comment">-- 加密</span><br><span class="hljs-keyword">UPDATE</span> testmd5 <span class="hljs-keyword">SET</span> pwd<span class="hljs-operator">=</span>MD5(pwd);<br><br><span class="hljs-comment">-- 插入的时候加密</span><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> testmd5 <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;xiaoming&#x27;</span>, MD5(<span class="hljs-string">&#x27;123456&#x27;</span>));<br><br><span class="hljs-comment">-- 校验:将用户传递进来的密码进行md5加密，比对加密后的值</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> testmd5 <span class="hljs-keyword">WHERE</span> `name`<span class="hljs-operator">=</span><span class="hljs-string">&#x27;xiaoming&#x27;</span> <span class="hljs-keyword">AND</span> pwd <span class="hljs-operator">=</span> MD5(<span class="hljs-string">&#x27;123456&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>核心：将一组SQL放在一个批次中去执行</p><blockquote><p>事务的原则：ACID原则</p><p>原子性，一致性，隔离性，持久性  （脏读，幻读…）</p><p>详细介绍链接：<a href="https://blog.csdn.net/dengjili/article/details/82468576">https://blog.csdn.net/dengjili/article/details/82468576</a></p></blockquote><h3 id="原子性（Atomicity）"><a href="#原子性（Atomicity）" class="headerlink" title="原子性（Atomicity）"></a>原子性（Atomicity）</h3><p>要么成功，要么失败</p><ol><li>SQL执行  A 给 B 转账  A 1000 -&gt;200 B 200</li><li>SQL执行  B 收到 A 的钱  A  800  B 400</li></ol><h3 id="一致性（Consistency）"><a href="#一致性（Consistency）" class="headerlink" title="一致性（Consistency）"></a>一致性（Consistency）</h3><p>事务前后的数据完整性保持一致，比如最终一致性，A和B的总钱数不会变化，始终为1200</p><h3 id="隔离性（Isolation）"><a href="#隔离性（Isolation）" class="headerlink" title="隔离性（Isolation）"></a>隔离性（Isolation）</h3><p>多个用户并发访问数据库时，数据库为每一个用户开启的事务，不会被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。</p><blockquote><p>隔离所导致的一些问题：</p></blockquote><ul><li><p>脏读：</p><p>  指一个事务读取了另外一个事物未提交的数据。</p></li><li><p>不可重复读：</p><p>  在一个事务内读取表中的某一行数据，多次读取的结果不同。</p></li><li><p>虚读（幻读）：</p><p>  在一个事务内读取到了别的事务插入的数据，导致前后读取不一致。</p></li></ul><h3 id="持久性（Durability）"><a href="#持久性（Durability）" class="headerlink" title="持久性（Durability）"></a>持久性（Durability）</h3><p>– 事务提交</p><p>事务一旦提交则不可逆，被持久化到数据库中</p><blockquote><p>执行事务</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- MySQL默认开启事务自动提交</span><br><span class="hljs-keyword">SET</span> autocommit <span class="hljs-operator">=</span> <span class="hljs-number">0</span>  <span class="hljs-comment">-- 关闭</span><br><span class="hljs-keyword">SET</span> autocommit <span class="hljs-operator">=</span> <span class="hljs-number">1</span>  <span class="hljs-comment">-- 开启</span><br><br><span class="hljs-comment">-- 手动处理事务</span><br><span class="hljs-keyword">SET</span> autocommit <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">-- 关闭自动提交</span><br><br><span class="hljs-comment">-- 事务开启</span><br><span class="hljs-keyword">START</span> TRANSACTION  <span class="hljs-comment">-- 标记一个事务的开始，从这之后的sql 都在同一个事务内</span><br><br><span class="hljs-comment">-- 提交： 持久化(成功）</span><br><span class="hljs-keyword">COMMIT</span><br><span class="hljs-comment">-- 回滚： 回到原来的样子（失败）</span><br><span class="hljs-keyword">ROLLBACK</span><br><span class="hljs-comment">-- 事务结束</span><br><span class="hljs-keyword">SET</span> autocommit <span class="hljs-operator">=</span> <span class="hljs-number">1</span>  <span class="hljs-comment">-- 开启自动提交</span><br><br><span class="hljs-keyword">SAVEPOINT</span> 保存点名 <span class="hljs-comment">-- 设置一个事务的保存点</span><br><span class="hljs-keyword">ROLLBACK</span> <span class="hljs-keyword">TO</span> <span class="hljs-keyword">SAVEPOINT</span> 保存点名  <span class="hljs-comment">-- 回滚到保存点</span><br><span class="hljs-keyword">RELEASE</span> <span class="hljs-keyword">SAVEPOINT</span> 保存点名    <span class="hljs-comment">-- 撤销保存点</span><br></code></pre></td></tr></table></figure><p><img src="/2023/01/10/MySQL/image-20201001133509760.png" alt="image-20201001133509760"></p><p>转账实例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- ===============================</span><br><span class="hljs-comment">-- 转账</span><br><span class="hljs-keyword">CREATE</span> DATABASE shop <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8 <span class="hljs-keyword">COLLATE</span> utf8_general_ci<br>USE shop<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `account`(<br>`id` <span class="hljs-type">INT</span>(<span class="hljs-number">3</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>`name` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>`money` <span class="hljs-type">DECIMAL</span>(<span class="hljs-number">9</span>, <span class="hljs-number">2</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,   <span class="hljs-comment">-- 9位数，其中小数点两位</span><br><span class="hljs-keyword">PRIMARY</span> KEY (`id`) <br>)ENGINE<span class="hljs-operator">=</span>INNODB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `account`(`name`, `money`)<br><span class="hljs-keyword">VALUES</span><br>(<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-number">2000.00</span>),<br>(<span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-number">10000.00</span>)<br><br><span class="hljs-comment">-- 模拟转账: 事务</span><br><span class="hljs-keyword">SET</span> autocommit <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;   <span class="hljs-comment">-- 关闭自动提交</span><br><span class="hljs-keyword">START</span> TRANSACTION; <span class="hljs-comment">-- 开启事务;</span><br><span class="hljs-keyword">UPDATE</span> account <span class="hljs-keyword">SET</span> money <span class="hljs-operator">=</span> money <span class="hljs-operator">-</span> <span class="hljs-number">500</span> <span class="hljs-keyword">WHERE</span> `name` <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;A&#x27;</span>;  <span class="hljs-comment">-- A减500</span><br><span class="hljs-keyword">UPDATE</span> account <span class="hljs-keyword">SET</span> money <span class="hljs-operator">=</span> money <span class="hljs-operator">+</span> <span class="hljs-number">500</span> <span class="hljs-keyword">WHERE</span> `name` <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;B&#x27;</span>;  <span class="hljs-comment">-- B加500</span><br><br><span class="hljs-keyword">COMMIT</span>;  <span class="hljs-comment">-- 提交事务</span><br><span class="hljs-keyword">ROLLBACK</span>;  <span class="hljs-comment">-- 回滚，一旦提交数据就被持久化而不能回滚了</span><br><br><span class="hljs-keyword">SET</span> autocommit <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">-- 恢复默认值</span><br><span class="hljs-comment">-- ========================</span><br></code></pre></td></tr></table></figure><p>在Java中的使用情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Function&#123;<br>    <span class="hljs-keyword">try</span>()&#123;<br>        something;<br>        commit();<br>    &#125;<span class="hljs-keyword">catch</span>(Exception)&#123;<br>        rollback();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>详细介绍链接：<a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">http://blog.codinglabs.org/articles/theory-of-mysql-index.html</a></p><blockquote><p>MySQL官方对索引的定义为：<strong>索引（Index）是帮助MySQL高效获取数据的数据结构</strong>。</p><p>提取句子主干，就可以得到索引的本质：索引是数据结构。</p></blockquote><h3 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h3><blockquote><p>在一个表中，主键索引只能有一个，唯一索引可以有多个</p></blockquote><ul><li>主键索引 PRIMARY KEY<ul><li>唯一的标识，主键不可重复，只能有一个列作为主键</li></ul></li><li>唯一索引 UNIQUE KEY<ul><li>避免重复的列出现，唯一索引可以重复，多个列都可以标识为唯一索引</li></ul></li><li>常规索引 KEY&#x2F;INDEX<ul><li>默认的，index，key关键字来设置</li></ul></li><li>全文索引 FullText<ul><li>在特定的数据库引擎下才有，如MyISAM</li><li>快速定位数据</li></ul></li></ul><p>基础语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 索引的使用</span><br><span class="hljs-comment">-- 1.在创建表的时候给字段增加索引</span><br><span class="hljs-comment">-- 2.创建完毕后增加索引</span><br><br><span class="hljs-comment">-- 显示所有索引信息</span><br><span class="hljs-keyword">SHOW</span> INDEX <span class="hljs-keyword">FROM</span> student<br><br><span class="hljs-comment">-- 增加一个索引(索引名，类名)</span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> school.`student` <span class="hljs-keyword">ADD</span> FULLTEXT INDEX `studentname`(`studentname`)<br><br><span class="hljs-comment">-- 分析SQL执行的状况</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> student; <span class="hljs-comment">-- 常规索引，非全文索引</span><br><br>EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">MATCH</span>(studentname) AGAINST(<span class="hljs-string">&#x27;刘&#x27;</span>);   <span class="hljs-comment">-- 全文索引</span><br></code></pre></td></tr></table></figure><h3 id="测试索引"><a href="#测试索引" class="headerlink" title="测试索引"></a>测试索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `app_user`(<br>`id` <span class="hljs-type">BIGINT</span>(<span class="hljs-number">20</span>) UNSIGNED <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>`name` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span> COMMENT <span class="hljs-string">&#x27;用户昵称&#x27;</span>,<br>`email` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;用户邮箱&#x27;</span>,<br>`phone` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span> COMMENT <span class="hljs-string">&#x27;手机号&#x27;</span>,<br>`gender` TINYINT(<span class="hljs-number">4</span>) UNSIGNED <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span> COMMENT <span class="hljs-string">&#x27;性别（0：男，1：女）&#x27;</span>,<br>`password` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;密码&#x27;</span>,<br>`age` TINYINT(<span class="hljs-number">4</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span> COMMENT <span class="hljs-string">&#x27;年龄&#x27;</span>,<br>`create_time` DATETIME <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>,<br>`update_time` <span class="hljs-type">TIMESTAMP</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>,<br><span class="hljs-keyword">PRIMARY</span> KEY (`id`)<br>) ENGINE<span class="hljs-operator">=</span>INNODB CHARSET<span class="hljs-operator">=</span>utf8mb4  COMMENT<span class="hljs-operator">=</span><span class="hljs-string">&#x27;app用户表&#x27;</span><br><br><span class="hljs-comment">-- 插入100万数据</span><br>DELIMITER $$ <span class="hljs-comment">-- 写函数之前必须要写，标志</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> `mock_data`()<br><span class="hljs-keyword">RETURNS</span> <span class="hljs-type">INT</span><br><span class="hljs-keyword">DETERMINISTIC</span><br><span class="hljs-keyword">BEGIN</span><br><span class="hljs-keyword">DECLARE</span> num <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">1000000</span>;<br><span class="hljs-keyword">DECLARE</span> i <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span>;<br><br>WHILE i <span class="hljs-operator">&lt;</span> num DO<br><span class="hljs-comment">-- 插入语句</span><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> app_user(`name`, `email`, `phone`,`gender`, `password`, `age`)<br><span class="hljs-keyword">VALUES</span>(<br>CONCAT(<span class="hljs-string">&#x27;用户&#x27;</span>, i),<br><span class="hljs-string">&#x27;54323456@qq.com&#x27;</span>, <br>CONCAT(<span class="hljs-string">&#x27;18&#x27;</span>, <span class="hljs-built_in">FLOOR</span>(RAND() <span class="hljs-operator">*</span> ((<span class="hljs-number">999999999</span><span class="hljs-number">-100000000</span>) <span class="hljs-operator">+</span> <span class="hljs-number">100000000</span>)) ),<br><span class="hljs-built_in">FLOOR</span>(RAND() <span class="hljs-operator">*</span> <span class="hljs-number">2</span>),<br>UUID(),<br><span class="hljs-built_in">FLOOR</span>(RAND() <span class="hljs-operator">*</span> <span class="hljs-number">100</span>)<br>);<br><br><span class="hljs-keyword">SET</span> i <span class="hljs-operator">=</span> i <span class="hljs-operator">+</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">END</span> WHILE;<br><span class="hljs-keyword">RETURN</span> i;<br><span class="hljs-keyword">END</span>;<br><span class="hljs-keyword">SELECT</span> mock_data();<br><br><span class="hljs-comment">-- 创建索引前</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> app_user <span class="hljs-keyword">WHERE</span> `name`<span class="hljs-operator">=</span><span class="hljs-string">&#x27;用户9999&#x27;</span>;  <span class="hljs-comment">-- 0.518sec</span><br><br><span class="hljs-comment">-- id _ 表名 _ 字段名</span><br><span class="hljs-comment">-- create index 索引名 on 表（字段）</span><br><span class="hljs-keyword">CREATE</span> INDEX id_app_user_name <span class="hljs-keyword">ON</span> app_user(`name`);<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> app_user <span class="hljs-keyword">WHERE</span> `name`<span class="hljs-operator">=</span><span class="hljs-string">&#x27;用户9999&#x27;</span>;  <span class="hljs-comment">-- 0.002 sec</span><br></code></pre></td></tr></table></figure><p>索引在小数据量的时候，用处不大，但是在大数据的时候，区别十分明显~</p><h3 id="索引原则"><a href="#索引原则" class="headerlink" title="索引原则"></a>索引原则</h3><ul><li>索引不是越多越好</li><li>不要对经常变动的数据加索引</li><li>小数据量的表不需要加索引</li><li>索引一般加在常用来查询的字段上（提高查询速度）</li></ul><blockquote><p>索引的数据结构</p></blockquote><p>Hash 类型的索引</p><p>Btree：INNODB的默认数据结构</p><h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><blockquote><p>SQL yog 可视化管理</p></blockquote><p><img src="/2023/01/10/MySQL/image-20201001160431570.png" alt="image-20201001160431570"></p><blockquote><p>SQL 命令操作</p></blockquote><p>用户表：mysql.user</p><p>本质：对这张表进行增删改查</p><p>详细命令链接：<a href="https://blog.csdn.net/zy_1995/article/details/102708482">https://blog.csdn.net/zy_1995/article/details/102708482</a></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 创建用户</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> kuangshen IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;123456&#x27;</span><br><br><span class="hljs-comment">-- 修改密码</span><br><span class="hljs-comment">-- set password for kuangshen@localhost = password(&#x27;111111&#x27;)  旧版本</span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">&#x27;kuangshen&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;111111&#x27;</span><br><span class="hljs-keyword">SET</span> PASSWORD <span class="hljs-keyword">FOR</span> <span class="hljs-string">&#x27;kuangshen2&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;2222222&#x27;</span><br><br><span class="hljs-comment">-- 给用户重命名</span><br>RENAME <span class="hljs-keyword">USER</span> <span class="hljs-string">&#x27;kuangshen&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> <span class="hljs-keyword">TO</span> <span class="hljs-string">&#x27;kuangshen2&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span><br><br><span class="hljs-comment">-- 给用户授权 ALL PRIVILEGES *.* 会授予除GRANT以外的所有权限, 要授予GRANT需加上WITH GRANT OPTION</span><br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> PRIVILEGES <span class="hljs-keyword">ON</span> <span class="hljs-operator">*</span>.<span class="hljs-operator">*</span> <span class="hljs-keyword">TO</span> <span class="hljs-string">&#x27;kuangshen&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span><br><br><span class="hljs-comment">-- 删除用户</span><br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">&#x27;kuangshen&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span><br><br><span class="hljs-comment">-- 查询权限</span><br><span class="hljs-keyword">SHOW</span> GRANTS <span class="hljs-keyword">FOR</span> <span class="hljs-string">&#x27;kuangshen&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span>  <span class="hljs-comment">-- 查看指定用户的权限</span><br><span class="hljs-keyword">SHOW</span> GRANTS <span class="hljs-keyword">FOR</span> root<span class="hljs-variable">@localhost</span><br><br><span class="hljs-comment">-- 撤销权限 revoke 哪些权限 ，在哪个库撤销， 给谁撤销</span><br><span class="hljs-keyword">REVOKE</span> <span class="hljs-keyword">ALL</span> PRIVILEGES <span class="hljs-keyword">ON</span> <span class="hljs-operator">*</span>.<span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> kuangshen2<span class="hljs-variable">@localhost</span><br></code></pre></td></tr></table></figure><h3 id="MySQL备份"><a href="#MySQL备份" class="headerlink" title="MySQL备份"></a>MySQL备份</h3><ul><li>保证重要的数据不丢失</li><li>数据转移</li></ul><p>MySQL数据库备份的方式：</p><ul><li><p>直接拷贝物理文件…..&#x2F;data</p></li><li><p>在SQL yog可视化工具中手动导出</p><ul><li>在左栏右键选择导出转储，选择结构和数据，指定导出的位置</li><li>将文件直接拉入yog中即可使用</li></ul></li><li><p>使用命令行 mysqldump  在命令行中使用</p>  <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmd"># mysqldump -h主机 -u用户名 -p密码 数据库名 [表<span class="hljs-number">1</span> 表<span class="hljs-number">2</span> 表<span class="hljs-number">3</span> ...] &gt; 物理磁盘位置<br>mysqldump -hlocalhost -uroot -pxxxxxx school student &gt;D:/a.sql<br></code></pre></td></tr></table></figure><p>  导入方法：</p>  <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmd"># 登录后使用source命令<br>mysql -uroot -pxxxxxx<br>source .sql文件位置<br></code></pre></td></tr></table></figure></li></ul><h2 id="规范数据设计"><a href="#规范数据设计" class="headerlink" title="规范数据设计"></a>规范数据设计</h2><h3 id="为什么需要设计？"><a href="#为什么需要设计？" class="headerlink" title="为什么需要设计？"></a>为什么需要设计？</h3><p>当数据库比较复杂的时候，就需要进行设计。</p><p>糟糕的数据库设计：</p><ul><li>数据冗余，浪费空间</li><li>数据库插入和删除都会很麻烦，异常（屏蔽使用物理外键）</li><li>程序性能差</li></ul><p>良好的数据库设计：</p><ul><li>节省内存空间</li><li>保证数据库的完整性</li><li>方便开发系统</li></ul><p><strong>软件开发中，关于数据库的设计</strong></p><ul><li>分析需求：分析业务和需要处理的数据库的需求</li><li>概要设计：设计关系图 E-R 图</li></ul><p><strong>设计数据库的步骤：（个人博客）</strong></p><ul><li>收集信息，分析需求<ul><li>用户表（用户登录注销，用户的个人信息，写博客，创建分类）</li><li>分类表（文章分类，谁创建的）</li><li>文章表（文章的信息）</li><li>评论表（评论）</li><li>友链表（友链信息）</li><li>自定义表（系统信息，某个关键的字或者一些主字段） key: value</li><li>说说表（发表心情  id  content  create_time）</li></ul></li><li>标识实体（把需求落地到每个字段）</li><li>标识实体之间的关系<ul><li>写博客 user -&gt; blog</li><li>创建分类 user -&gt; category</li><li>关注 user -&gt; user</li><li>友链 links</li><li>评论 user-user-blog</li></ul></li></ul><h3 id="三大范式"><a href="#三大范式" class="headerlink" title="三大范式"></a>三大范式</h3><p><strong>为什么需要数据规范化？</strong></p><p>可能出现的问题：</p><ul><li>信息重复</li><li>更新异常</li><li>插入异常<ul><li>无法正常显示信息</li></ul></li><li>删除异常<ul><li>丢失一些有效的信息</li></ul></li></ul><p>详细链接：<a href="https://www.cnblogs.com/wsg25/p/9615100.html">https://www.cnblogs.com/wsg25/p/9615100.html</a></p><h4 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h4><p>原子性：保证每一列不可再分</p><h4 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h4><p>前提：满足第一范式</p><p>每张表只描述一件事情</p><h4 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h4><p>前提：满足第一范式和第二范式</p><p>确保数据表中的每一列数据都和主键直接相关，而不能间接相关</p><p><strong>规范性和性能的问题</strong></p><p>关联查询的表不能超过三张表</p><ul><li>考虑商业化的需求和目标，（成本，用户体验）数据库的性能更加重要</li><li>规范性能的问题时，需要适当考虑规范性</li><li>故意给某些表增加一些冗余的字段（从多表查询变为单表查询）</li><li>故意增加一些计算列（从大数据量降低为小数据量查询：索引）</li></ul><h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><h3 id="数据库驱动"><a href="#数据库驱动" class="headerlink" title="数据库驱动"></a>数据库驱动</h3><p><img src="/2023/01/10/MySQL/image-20201002111118497.png" alt="image-20201002111118497"></p><p>程序会通过数据库驱动，和数据库打交道。</p><h3 id="JDBC概念"><a href="#JDBC概念" class="headerlink" title="JDBC概念"></a>JDBC概念</h3><p>SUN公司为了简化开发人员的（对数据库统一）的操作，提供了一个（java操作数据库的）规范，称为JDBC。</p><p>这些规范的实现由具体的厂商去做。</p><p>对于开发人员，只需要操纵API即可。</p><p><img src="/2023/01/10/MySQL/image-20201002111425645.png" alt="image-20201002111425645"></p><p>java.sql</p><p>javax.sql</p><p>还需要导入一个数据库驱动包</p><p>mysql-connector-java.jar</p><h3 id="第一个JDBC程序"><a href="#第一个JDBC程序" class="headerlink" title="第一个JDBC程序"></a>第一个JDBC程序</h3><blockquote><p>创建测试数据库</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> DATABASE jdbcstudy <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8 <span class="hljs-keyword">COLLATE</span> utf8_general_ci;<br><br>USE jdbcstudy;<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> users(<br>id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,<br>NAME <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">40</span>),<br>PASSWORD <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">40</span>),<br>email <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">60</span>),<br>birthday <span class="hljs-type">DATE</span><br>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> users(id, NAME, PASSWORD, email, birthday)<br><span class="hljs-keyword">VALUES</span><br>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;zhansan&#x27;</span>, <span class="hljs-string">&#x27;123456&#x27;</span>, <span class="hljs-string">&#x27;zs@sina.com&#x27;</span>, <span class="hljs-string">&#x27;1980-12-04&#x27;</span>),<br>(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;lisi&#x27;</span>, <span class="hljs-string">&#x27;123456&#x27;</span>, <span class="hljs-string">&#x27;lisi@sina.com&#x27;</span>, <span class="hljs-string">&#x27;1981-12-04&#x27;</span>),<br>(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;wangwu&#x27;</span>, <span class="hljs-string">&#x27;123456&#x27;</span>, <span class="hljs-string">&#x27;wangwu@sina.com&#x27;</span>, <span class="hljs-string">&#x27;1979-12-04&#x27;</span>);<br></code></pre></td></tr></table></figure><ol><li><p>创建一个普通项目</p></li><li><p>导入数据库驱动</p></li><li><p>编写测试代码</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.sql.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">jdbcFirstDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, SQLException &#123;<br>        <span class="hljs-comment">//1. 加载驱动</span><br>        Class.forName(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);  <span class="hljs-comment">//固定写法，加载驱动</span><br>        <span class="hljs-comment">//2. 用户信息和url</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/jdbcstudy?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=true&amp;serverTimezone=GMT&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;root&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123456&quot;</span>;<br>        <span class="hljs-comment">//3. 连接成功，数据库对象 Connection 代表数据库</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url, username, password);<br><br>        <span class="hljs-comment">//4. 执行SQL的对象</span><br>        <span class="hljs-type">Statement</span> <span class="hljs-variable">statement</span> <span class="hljs-operator">=</span> connection.createStatement();<br><br>        <span class="hljs-comment">//5. 执行SQL的对象去执行SQL，可能存在结果，返回结果</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from users&quot;</span>;<br>        <span class="hljs-type">ResultSet</span> <span class="hljs-variable">resultSet</span> <span class="hljs-operator">=</span> statement.executeQuery(sql);   <span class="hljs-comment">//返回结果集，封装了全部查询出来的结果</span><br><br>        <span class="hljs-keyword">while</span>(resultSet.next())&#123;<br>            System.out.println(<span class="hljs-string">&quot;id=&quot;</span> + resultSet.getObject(<span class="hljs-string">&quot;id&quot;</span>));<br>            System.out.println(<span class="hljs-string">&quot;name=&quot;</span> + resultSet.getObject(<span class="hljs-string">&quot;name&quot;</span>));<br>            System.out.println(<span class="hljs-string">&quot;password=&quot;</span> + resultSet.getObject(<span class="hljs-string">&quot;password&quot;</span>));<br>            System.out.println(<span class="hljs-string">&quot;email=&quot;</span> + resultSet.getObject(<span class="hljs-string">&quot;email&quot;</span>));<br>            System.out.println(<span class="hljs-string">&quot;birthday=&quot;</span> + resultSet.getObject(<span class="hljs-string">&quot;birthday&quot;</span>));<br>            System.out.println(<span class="hljs-string">&quot;===========================&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//6. 释放连接</span><br>        resultSet.close();<br>        statement.close();<br>        connection.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>步骤总结：</p><ol><li>加载驱动</li><li>连接数据库 DriverManager</li><li>获取执行SQL的对象 Statement</li><li>获取返回的结果集</li><li>释放连接</li></ol><blockquote><p>DriveManager</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">Class.forName(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);  <span class="hljs-comment">//固定写法，加载驱动</span><br><br><span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url, username, password);<br><span class="hljs-comment">//connection 代表数据库</span><br><span class="hljs-comment">//数据库设置自动提交</span><br>connection.setAutoCommit();<br><span class="hljs-comment">//事务提交</span><br>connection.commit();<br><span class="hljs-comment">//事务回滚</span><br>connection.rollback();<br></code></pre></td></tr></table></figure><blockquote><p>url</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/jdbcstudy?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=true&amp;serverTimezone=GMT&quot;</span>;<br><span class="hljs-comment">//mysql --3306</span><br><span class="hljs-comment">//jdbc:mysql:(协议)/localhost:3306/数据库名?参数1&amp;参数2&amp;参数3...</span><br><br><span class="hljs-comment">//oracle --2521</span><br><span class="hljs-comment">//jdbc:oracle:thin:@localhost:1521:sid</span><br></code></pre></td></tr></table></figure><blockquote><p>Statement –执行SQL 的对象   PrepareStatement</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//编写sql</span><br><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from users&quot;</span>;<br><br>statement.executeQuery(<span class="hljs-string">&quot;&quot;</span>);  <span class="hljs-comment">//查询操作，返回结果集</span><br>statement.execute(<span class="hljs-string">&quot;&quot;</span>);       <span class="hljs-comment">//执行任何sql</span><br>statement.executeUpdate(<span class="hljs-string">&quot;&quot;</span>); <span class="hljs-comment">//更新，插入，删除，返回受影响的行数</span><br></code></pre></td></tr></table></figure><blockquote><p>ResultSet查询的结果集：封装了所有的查询结果</p></blockquote><p>获取指定的数据类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">resultSet.getInt();<br>resultSet.getString();<br>resultSet.getDate();<br>resultSet.getObject();   <span class="hljs-comment">//不知道列的类型时使用</span><br>...<br></code></pre></td></tr></table></figure><p>遍历，指针</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">resultSet.beforeFirst();  <span class="hljs-comment">//移动到最前面</span><br>resultSet.afterLast();    <span class="hljs-comment">//移动到最后面</span><br>resultSet.next();         <span class="hljs-comment">//移动到下一个数据</span><br>resultSet.previous();    <span class="hljs-comment">//移动到前一行</span><br>resultSet.absolute(row);  <span class="hljs-comment">//移动到指定行</span><br></code></pre></td></tr></table></figure><blockquote><p>释放资源</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//释放连接</span><br>resultSet.close();<br>statement.close();<br>connection.close();<br></code></pre></td></tr></table></figure><h3 id="statement对象"><a href="#statement对象" class="headerlink" title="statement对象"></a>statement对象</h3><p>jdbc中的statement对象用于向数据库发送SQL语句，想完成数据库的增删改查，只需要通过这个对象向数据库发送增删改查语句即可。</p><p>Statement对象的executeUpdate方法，用于向数据库发送增删改的SQL语句，executeUpdate执行完后，将会返回一个整数（变化的行数）。</p><p>Statement.executeQuery方法用于向数据库发送查询语句，executeQuery方法返回查询结果的ResultSet对象。</p><blockquote><p>CRUD操作- create</p></blockquote><p>使用executeUpdate（String sql）方法完成数据添加操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Statement</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> connection.createStatement();<br><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;insert into user(...) values(...)&quot;</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> st.executeUpdate(sql);<br><span class="hljs-keyword">if</span>(num &gt; <span class="hljs-number">0</span>)&#123;<br>    System.out.println(<span class="hljs-string">&quot;插入成功！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>CRUD操作- delete</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Statement</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> connection.createStatement();<br><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;delete from user where id = 1&quot;</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> st.executeUpdate(sql);<br><span class="hljs-keyword">if</span>(num &gt; <span class="hljs-number">0</span>)&#123;<br>    System.out.println(<span class="hljs-string">&quot;删除成功！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>CRUD操作- update</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">...;<br><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;update user set name = &#x27;&#x27; where name = &#x27;&#x27; &quot;</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> st.executeUpdate(sql);<br>...;<br></code></pre></td></tr></table></figure><blockquote><p>CRUD操作- read</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">...;<br><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from user where id = 1&quot;</span>;<br><span class="hljs-type">ResultSet</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> st.executeQuery(sql);<br><span class="hljs-keyword">while</span>(rs.next())&#123;<br>    ...;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p> 代码实现</p></blockquote><ol><li><p>提取工具类</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> utils;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><span class="hljs-keyword">import</span> java.sql.*;<br><span class="hljs-keyword">import</span> java.util.Properties;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JdbcUtils</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">driver</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">static</span>&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-comment">//获取文件信息</span><br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> JdbcUtils.class.getClassLoader().getResourceAsStream(<span class="hljs-string">&quot;db.properties&quot;</span>);<br>            <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>            properties.load(inputStream);<br><br>            driver = properties.getProperty(<span class="hljs-string">&quot;driver&quot;</span>);<br>            url = properties.getProperty(<span class="hljs-string">&quot;url&quot;</span>);<br>            username = properties.getProperty(<span class="hljs-string">&quot;username&quot;</span>);<br>            password = properties.getProperty(<span class="hljs-string">&quot;password&quot;</span>);<br><br>            <span class="hljs-comment">//1. 驱动只用加载一次</span><br>            Class.forName(driver);<br><br>        &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//获取连接</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> DriverManager.getConnection(url, username, password);<br>    &#125;<br>    <span class="hljs-comment">//释放连接资源</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">(Connection connection, Statement statement, ResultSet resultSet)</span>&#123;<br>        <span class="hljs-keyword">if</span>(resultSet != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                resultSet.close();<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException throwables) &#123;<br>                throwables.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(statement != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                statement.close();<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException throwables) &#123;<br>                throwables.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(connection != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                connection.close();<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException throwables) &#123;<br>                throwables.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> db.properties文件：</p> <figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">driver</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br><span class="hljs-attr">url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/jdbcstudy?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=true&amp;serverTimezone=GMT</span><br><span class="hljs-attr">username</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">password</span>=<span class="hljs-string">123456</span><br></code></pre></td></tr></table></figure></li><li><p>编写增删改查的方法</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//增删改</span><br><span class="hljs-keyword">import</span> utils.JdbcUtils;<br><br><span class="hljs-keyword">import</span> java.sql.Connection;<br><span class="hljs-keyword">import</span> java.sql.ResultSet;<br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><span class="hljs-keyword">import</span> java.sql.Statement;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestInsert</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Statement</span> <span class="hljs-variable">statement</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ResultSet</span> <span class="hljs-variable">resultSet</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            connection = JdbcUtils.getConnection();  <span class="hljs-comment">//获取数据库连接</span><br>            statement = connection.createStatement();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> SQL语句;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> statement.executeUpdate(sql);<br>            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span>)&#123;<br>                System.out.println(<span class="hljs-string">&quot;success!&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException sqlException) &#123;<br>            sqlException.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            JdbcUtils.release(connection, statement, resultSet);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//查询</span><br><span class="hljs-keyword">import</span> utils.JdbcUtils;<br><br><span class="hljs-keyword">import</span> java.sql.Connection;<br><span class="hljs-keyword">import</span> java.sql.ResultSet;<br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><span class="hljs-keyword">import</span> java.sql.Statement;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestInsert</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Statement</span> <span class="hljs-variable">statement</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ResultSet</span> <span class="hljs-variable">resultSet</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            connection = JdbcUtils.getConnection();  <span class="hljs-comment">//获取数据库连接</span><br>            statement = connection.createStatement();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from users&quot;</span>;<br>            resultSet = statement.executeQuery(sql);<br>            <span class="hljs-keyword">if</span>(resultSet != <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">while</span>(resultSet.next())&#123;<br>                    System.out.println(<span class="hljs-string">&quot;id=&quot;</span> + resultSet.getObject(<span class="hljs-string">&quot;id&quot;</span>));<br>                    System.out.println(<span class="hljs-string">&quot;name=&quot;</span> + resultSet.getObject(<span class="hljs-string">&quot;name&quot;</span>));<br>                    System.out.println(<span class="hljs-string">&quot;password=&quot;</span> + resultSet.getObject(<span class="hljs-string">&quot;password&quot;</span>));<br>                    System.out.println(<span class="hljs-string">&quot;email=&quot;</span> + resultSet.getObject(<span class="hljs-string">&quot;email&quot;</span>));<br>                    System.out.println(<span class="hljs-string">&quot;birthday=&quot;</span> + resultSet.getObject(<span class="hljs-string">&quot;birthday&quot;</span>));<br>                    System.out.println(<span class="hljs-string">&quot;===========================&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException sqlException) &#123;<br>            sqlException.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            JdbcUtils.release(connection, statement, resultSet);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="SQL注入问题-sql-injection"><a href="#SQL注入问题-sql-injection" class="headerlink" title="SQL注入问题  (sql injection)"></a>SQL注入问题  (sql injection)</h3><p>sql存在漏洞，会被攻击导致数据泄露 <strong>SQL会拼接or</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">sql = <span class="hljs-string">&quot;select * from users where name =&#x27;&quot;</span> + username + <span class="hljs-string">&quot;&#x27; and password = &#x27;&quot;</span> + password + <span class="hljs-string">&quot;&#x27;&quot;</span>;<br><span class="hljs-comment">//此时如果username和password为：</span><br>username = <span class="hljs-string">&quot;&#x27; or &#x27;1=1&#x27;&quot;</span>;<br>password = <span class="hljs-string">&quot;&#x27; or &#x27;1=1&#x27;&quot;</span>;<br><span class="hljs-comment">//则表达式恒成立，用户的所有数据将被盗取</span><br></code></pre></td></tr></table></figure><h3 id="PreparedStatement对象"><a href="#PreparedStatement对象" class="headerlink" title="PreparedStatement对象"></a>PreparedStatement对象</h3><p>PreparedStatement 可以防止SQL注入，并且效率更高。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> utils.JdbcUtils;<br><br><span class="hljs-keyword">import</span> java.sql.Connection;<br><span class="hljs-keyword">import</span> java.sql.PreparedStatement;<br><span class="hljs-keyword">import</span> java.sql.ResultSet;<br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestSelect1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">preparedStatement</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ResultSet</span> <span class="hljs-variable">resultSet</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;shuwen&quot;</span>;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123456&quot;</span>;<br>            connection = JdbcUtils.getConnection();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from users where name = ? and password = ?&quot;</span>;<br><br>            <span class="hljs-comment">//preparedStatement本质：把传递进来的参数当做字符，即用引号包裹，如果存在转义字符，如&#x27;，则直接忽略</span><br>            preparedStatement = connection.prepareStatement(sql);  <span class="hljs-comment">//预编译</span><br><br>            preparedStatement.setString(<span class="hljs-number">1</span>, username);<br>            preparedStatement.setString(<span class="hljs-number">2</span>, password);<br><br>            resultSet = preparedStatement.executeQuery();  <span class="hljs-comment">//执行</span><br><br>            <span class="hljs-keyword">if</span>(resultSet.next())&#123;<br>                System.out.println(resultSet.getString(<span class="hljs-string">&quot;name&quot;</span>));<br>            &#125;<br><br>        &#125; <span class="hljs-keyword">catch</span> (SQLException throwables) &#123;<br>            throwables.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            JdbcUtils.release(connection, preparedStatement, resultSet);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用IDEA连接数据库"><a href="#使用IDEA连接数据库" class="headerlink" title="使用IDEA连接数据库"></a>使用IDEA连接数据库</h3><p>在右侧栏添加数据库</p><p><img src="/2023/01/10/MySQL/image-20201002173513965.png" alt="image-20201002173513965"></p><p><img src="/2023/01/10/MySQL/image-20201002173726030.png" alt="image-20201002173726030"></p><p><img src="/2023/01/10/MySQL/image-20201002173822608.png" alt="image-20201002173822608"></p><p>连接成功后，可以选择数据库</p><p><img src="/2023/01/10/MySQL/image-20201002174038984.png" alt="image-20201002174038984"></p><p><img src="/2023/01/10/MySQL/image-20201002174055364.png" alt="image-20201002174055364"></p><p>如果连接失败，可以在设置-》驱动里面查看版本是否正确，或者类是否正确。</p><h3 id="JDBC处理事务"><a href="#JDBC处理事务" class="headerlink" title="JDBC处理事务"></a>JDBC处理事务</h3><p><strong>回顾</strong></p><p>要么都成功，要么都失败</p><blockquote><p>ACID原则</p></blockquote><p>原子性：要么全部完成，要么都不完成</p><p>一致性：总数不变</p><p>隔离性：多个进程互不干扰</p><p>持久性：一旦提交不可逆，持久化到数据库</p><p>隔离性的问题：</p><p>脏读：一个事务读取了另一个没有提交的事务</p><p>不可重复读：在同一个事务内，重复读取表中的数据，数据发生了改变</p><p>幻读：在一个事务内，读取到了别人插入的数据，导致前后读出来的结果不一致</p><br><p><strong>代码实现：</strong></p><ol><li>开启事务<code>connection.setAutoCommit(false);</code></li><li>一组业务执行完毕，提交事务</li><li>可以在catch语句中显式定义回滚语句，但默认会回滚</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> utils.JdbcUtils;<br><br><span class="hljs-keyword">import</span> java.sql.Connection;<br><span class="hljs-keyword">import</span> java.sql.PreparedStatement;<br><span class="hljs-keyword">import</span> java.sql.ResultSet;<br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestTransaction</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">preparedStatement</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ResultSet</span> <span class="hljs-variable">resultSet</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            connection = JdbcUtils.getConnection();<br>            <span class="hljs-comment">//关闭数据库的自动提交功能,自动回开启事务</span><br>            connection.setAutoCommit(<span class="hljs-literal">false</span>);  <span class="hljs-comment">//开启事务</span><br><br>            <span class="hljs-type">String</span> <span class="hljs-variable">sql1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;update account set money = money - 100 where name = &#x27;A&#x27;&quot;</span>;<br>            preparedStatement = connection.prepareStatement(sql1);<br>            preparedStatement.execute();<br><br>            <span class="hljs-type">String</span> <span class="hljs-variable">sql2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;update account set money = money + 100 where name = &#x27;B&#x27;&quot;</span>;<br>            preparedStatement = connection.prepareStatement(sql2);<br>            preparedStatement.execute();<br><br>            <span class="hljs-comment">//业务完毕，提交事务</span><br>            connection.commit();<br>            System.out.println(<span class="hljs-string">&quot;success!&quot;</span>);<br><br>        &#125; <span class="hljs-keyword">catch</span> (Exception throwables) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                connection.rollback();   <span class="hljs-comment">//如果失败则回滚事务</span><br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-comment">//如果失败也会默认回滚</span><br>            throwables.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            JdbcUtils.release(connection, preparedStatement, resultSet);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h3><p>数据库连接–执行完毕–释放 </p><p>但是连接到释放会十分浪费系统资源</p><p><strong>池化技术：准备一些预先的资源，过来就连接预先准备好的</strong></p><p>最小连接数：10</p><p>最大连接数：100  业务最高承载上限</p><p>等待超时：100ms</p><p>编写连接池，实现一个接口  DataSource</p><blockquote><p>开源数据源实现（拿来即用）</p></blockquote><p>DBCP</p><p>C3P0</p><p>Druid：阿里巴巴</p><p>使用了这些数据库连接池之后，我们在项目开发中就不需要编写连接数据库的代码了。</p><blockquote><p>DBCP</p></blockquote><p>需要用到的jar包：</p><p>commons-dbcp,commons-pool</p><p>dbcpconfig.properties</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs pro"># 连接设置 这里面的名字，是DBCP数据源定义好的<br>driverClassName=com.mysql.cj.jdbc.Driver<br>url=jdbc:mysql://localhost:3306/jdbcstudy?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=true&amp;serverTimezone=GMT<br>username=root<br>password=123456<br><br>#&lt;!-- 初始化连接 --&gt;<br>initialSize=10<br><br>#最大连接数量<br>maxActive=50<br><br>#&lt;!-- 最大空闲连接 --&gt;<br>maxIdle=20<br><br>#&lt;!-- 最小空闲连接 --&gt;<br>minIdle=5<br><br>#&lt;!-- 超时等待时间以毫秒为单位 6000毫秒/1000等于60秒 --&gt;<br>maxWait=60000<br><br><br>#JDBC驱动建立连接时附带的连接属性属性的格式必须为这样：[属性名=property;]<br>#注意：&quot;user&quot; 与 &quot;password&quot; 两个属性会被明确地传递，因此这里不需要包含他们。<br>connectionProperties=useUnicode=true;characterEncoding=utf8<br><br>#指定由连接池所创建的连接的自动提交（auto-commit）状态。<br>defaultAutoCommit=true<br><br>#driver default 指定由连接池所创建的连接的事务级别（TransactionIsolation）。<br>#可用值为下列之一：（详情可见javadoc。）NONE,READ_UNCOMMITTED, READ_COMMITTED, REPEATABLE_READ, SERIALIZABLE<br>defaultTransactionIsolation=READ_UNCOMMITTED<br></code></pre></td></tr></table></figure><p>JdbcUtils_DBCP.java 利用工厂模式创建数据库连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> utils;<br><br><span class="hljs-keyword">import</span> org.apache.commons.dbcp.BasicDataSourceFactory;<br><br><span class="hljs-keyword">import</span> javax.sql.DataSource;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><span class="hljs-keyword">import</span> java.sql.*;<br><span class="hljs-keyword">import</span> java.util.Properties;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JdbcUtils_DBCP</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">DataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">static</span>&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-comment">//获取文件信息</span><br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> JdbcUtils.class.getClassLoader().getResourceAsStream(<span class="hljs-string">&quot;dbcpconfig.properties&quot;</span>);<br>            <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>            properties.load(inputStream);<br><br>            <span class="hljs-comment">//创建数据源 工厂模式 --》 创建</span><br>            dataSource = BasicDataSourceFactory.createDataSource(properties);<br><br>        &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//获取连接</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> dataSource.getConnection();  <span class="hljs-comment">//从数据源中获取连接</span><br>    &#125;<br>    <span class="hljs-comment">//释放连接资源</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">(Connection connection, Statement statement, ResultSet resultSet)</span>&#123;<br>        <span class="hljs-keyword">if</span>(resultSet != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                resultSet.close();<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException throwables) &#123;<br>                throwables.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(statement != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                statement.close();<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException throwables) &#123;<br>                throwables.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(connection != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                connection.close();<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException throwables) &#123;<br>                throwables.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>插入数据测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> utils.JdbcUtils;<br><span class="hljs-keyword">import</span> utils.JdbcUtils_DBCP;<br><br><span class="hljs-keyword">import</span> java.sql.Connection;<br><span class="hljs-keyword">import</span> java.sql.ResultSet;<br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><span class="hljs-keyword">import</span> java.sql.Statement;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestDBCP</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Statement</span> <span class="hljs-variable">statement</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ResultSet</span> <span class="hljs-variable">resultSet</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            connection = JdbcUtils_DBCP.getConnection();  <span class="hljs-comment">//获取数据库连接</span><br><br>            statement = connection.createStatement();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from users&quot;</span>;<br>            resultSet = statement.executeQuery(sql);<br>            <span class="hljs-keyword">if</span>(resultSet != <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">while</span>(resultSet.next())&#123;<br>                    System.out.println(<span class="hljs-string">&quot;id=&quot;</span> + resultSet.getObject(<span class="hljs-string">&quot;id&quot;</span>));<br>                    System.out.println(<span class="hljs-string">&quot;name=&quot;</span> + resultSet.getObject(<span class="hljs-string">&quot;name&quot;</span>));<br>                    System.out.println(<span class="hljs-string">&quot;password=&quot;</span> + resultSet.getObject(<span class="hljs-string">&quot;password&quot;</span>));<br>                    System.out.println(<span class="hljs-string">&quot;email=&quot;</span> + resultSet.getObject(<span class="hljs-string">&quot;email&quot;</span>));<br>                    System.out.println(<span class="hljs-string">&quot;birthday=&quot;</span> + resultSet.getObject(<span class="hljs-string">&quot;birthday&quot;</span>));<br>                    System.out.println(<span class="hljs-string">&quot;===========================&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException sqlException) &#123;<br>            sqlException.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            JdbcUtils_DBCP.release(connection, statement, resultSet);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>C3P0</p></blockquote><p>需要用到的jar包</p><p>c3p0, mchange-commons-java</p><blockquote><p>结论</p></blockquote><p>无论使用什么数据源，本质相同：DataSource接口不会变，方法就不会变</p><blockquote><p>Druid</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux脏牛漏洞</title>
    <link href="/2023/01/10/Linux%E8%84%8F%E7%89%9B%E6%BC%8F%E6%B4%9E/"/>
    <url>/2023/01/10/Linux%E8%84%8F%E7%89%9B%E6%BC%8F%E6%B4%9E/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux脏牛漏洞"><a href="#Linux脏牛漏洞" class="headerlink" title="Linux脏牛漏洞"></a>Linux脏牛漏洞</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>脏牛漏洞</strong>，又叫Dirty COW，存在Linux内核中已经有长达9年的时间，在2007年发布的Linux内核版本中就已经存在此漏洞。Linux kernel团队在2016年10月18日已经对此进行了修复。</p><p>该漏洞具体为，Linux内核的内存子系统在处理写入复制（copy-on-write, COW）时产生了竞争条件（race condition）。恶意用户可利用此漏洞，来获取高权限，对只读内存映射进行写访问。竞争条件，指的是任务执行顺序异常，可导致应用崩溃，或令攻击者有机可乘，进一步执行其他代码。利用这一漏洞，攻击者可在其目标系统提升权限，甚至可能获得root权限。</p><h2 id="触发机制"><a href="#触发机制" class="headerlink" title="触发机制"></a>触发机制</h2><p>该漏洞的原因是get_user_page内核函数在处理Copy-on-Write(以下使用COW表示)的过程中，可能产出竞态条件造成COW过程被破坏，导致出现写数据到进程地址空间内只读内存区域的机会。当我们向带有MAP_PRIVATE标记的只读文件映射区域写数据时，会产生一个映射文件的复制(COW)，对此区域的任何修改都不会写回原来的文件，如果上述的竞态条件发生，就能成功的写回原来的文件。比如我们修改su或者passwd程序就可以达到root的目的。</p><h2 id="漏洞影响"><a href="#漏洞影响" class="headerlink" title="漏洞影响"></a>漏洞影响</h2><p>攻击者可以在其目标系统提升权限，甚至可能获得root权限</p><h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><p>现在不再是把FOLL_WRITE标记去掉，而是添加了一个FOLL_COW标志来表示获取一个COW分配的页。即使是竞态条件破坏了一次完整的获取页的过程，但是因为FOLL_WRITE标志还在，所以会重头开始分配一个COW页，从而保证该过程的完整性。</p><h2 id="CVE-x2F-ExploitDB"><a href="#CVE-x2F-ExploitDB" class="headerlink" title="CVE&#x2F;ExploitDB"></a>CVE&#x2F;ExploitDB</h2><p>CVE：Common Vulnerabilities &amp; Exposures公共漏洞和暴露，为广泛认同的信息安全漏洞或者已经暴露出来的弱点给出一个公共名称</p><p>ExploitDB：漏洞信息库，可以快速查找漏洞源代码</p><p>参考文章：</p><p><a href="https://www.anquanke.com/post/id/84784">https://www.anquanke.com/post/id/84784</a></p><p><a href="https://zhuanlan.zhihu.com/p/25918300?from_voters_page=true">https://zhuanlan.zhihu.com/p/25918300?from_voters_page=true</a></p><p>一篇讲的非常详细的文章:<a href="https://xuanxuanblingbling.github.io/ctf/pwn/2019/11/18/race/">https://xuanxuanblingbling.github.io/ctf/pwn/2019/11/18/race/</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java文件和流</title>
    <link href="/2023/01/10/Java%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/"/>
    <url>/2023/01/10/Java%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h1 id="Java文件和流"><a href="#Java文件和流" class="headerlink" title="Java文件和流"></a>Java文件和流</h1><h2 id="基本文件格式"><a href="#基本文件格式" class="headerlink" title="基本文件格式"></a>基本文件格式</h2><p>在Java 中，一切文件皆是流。</p><ul><li>以字节为基础的流：输出或者输入的数据是二进制格式的。</li><li>以字符为基础的流：输出或者输入的数据是字符串序列，每个字符占2字节。</li></ul><h2 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h2><ul><li>Path接口：用来存放文件或者文件夹的地址</li><li>Paths类：利用静态方法来获取一个Path对象</li><li>Files类：提供静态方法来处理文件和文件夹</li><li>DirectoryStream接口：允许程序遍历文件夹内容</li><li>InputStreamReader类：读取器，用于读取某个流中的数据</li><li>FileInputStream类：将一个文件打开为流</li></ul><p><strong>路径相关操作</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Path</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> Paths.get(input.nextLine());  <span class="hljs-comment">//根据文件名创建路径对象</span><br>path.getFileName();<br>path.isAbsolute();  <span class="hljs-comment">//判断是否为绝对路径</span><br>path.toAbsolutePath(); <span class="hljs-comment">//转换为绝对路径</span><br></code></pre></td></tr></table></figure><p><strong>文件相关操作</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Files.exists(path);  <span class="hljs-comment">//判断文件是否存在</span><br>Files.isDirectory(path);  <span class="hljs-comment">//判断是否为文件夹</span><br>Files.getLastModifiedTime(path);  <span class="hljs-comment">//获取最后一次的修改日期</span><br>Files.size(path); <span class="hljs-comment">//获取文件大小</span><br><span class="hljs-comment">//创建文件夹流，其基本元素为</span><br>DirectoryStream&lt;Path&gt; directoryStream = Files.newDirectoryStream(path);<br></code></pre></td></tr></table></figure><h2 id="Formatter类"><a href="#Formatter类" class="headerlink" title="Formatter类"></a>Formatter类</h2><p>用于将数据输出到指定的位置</p><p>用法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Formatter</span> <span class="hljs-variable">output</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Formatter</span>(String);   <span class="hljs-comment">//创建一个输出流</span><br>output.format(format, ...args);  <span class="hljs-comment">//将内容输出到指定位置</span><br>output.close();   <span class="hljs-comment">//关闭输出流</span><br></code></pre></td></tr></table></figure><p><strong>文件结束标志：</strong></p><p>Linux：&lt; Enter &gt;&lt; Ctrl &gt;d</p><p>Windows: &lt; Ctrl &gt; z</p><h2 id="Scanner类"><a href="#Scanner类" class="headerlink" title="Scanner类"></a>Scanner类</h2><p>从指定位置中读取数据到内存中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Scanner</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(Path);<br>input.hasNext();  <span class="hljs-comment">//if there is more to read</span><br>input.nextInt();  <span class="hljs-comment">//输入一个整数</span><br>input.next();     <span class="hljs-comment">//输入一个单词</span><br>input.nextLine(); <span class="hljs-comment">//输入一行</span><br>input.close();    <span class="hljs-comment">//关闭输入流</span><br></code></pre></td></tr></table></figure><h2 id="InputStreamReader类"><a href="#InputStreamReader类" class="headerlink" title="InputStreamReader类"></a>InputStreamReader类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">InputStreamReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(FileInputStream(<span class="hljs-string">&quot;test.c&quot;</span>));        <br>reader.read();                         <span class="hljs-comment">//返回下一个字符，读取失败返回-1</span><br>reader.read(cbuf, offset, length);     <span class="hljs-comment">//读取特定长度字符到cbuf中，返回长度或-1</span><br>reader.ready();                        <span class="hljs-comment">//判断是否读取阻塞</span><br></code></pre></td></tr></table></figure><h2 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a>对象序列化</h2><p>Java可以将对象直接存储在文件中，然后直接从此类文件读取内容到对象内。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassName</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span>;   <span class="hljs-comment">//需要实现Serializable接口</span><br><br><span class="hljs-comment">//输出对象</span><br><span class="hljs-comment">//解释：</span><br><span class="hljs-comment">//首先创建了一个对象输出流，这个流定向先定向到文件输出流，然后文件输出流再定向到文件</span><br><span class="hljs-comment">//相当于数据逐层转化输出的过程</span><br><span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">output</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<br>Files.newOutputStream(Paths.get(String fileName)));<br><br>output.writeObject(objectName);    <span class="hljs-comment">//将参数中的对象写到定向位置</span><br><br><span class="hljs-comment">//输入对象</span><br><span class="hljs-comment">//解释：</span><br><span class="hljs-comment">//这个过程正好和输出对象相反，先把文件数据转换成文件输入流，然后把文件输入流转换成对象输入流</span><br><span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<br>    Files.newInputStream(Paths.get(fileName)));<br><br><span class="hljs-type">myObject</span> <span class="hljs-variable">objectName</span> <span class="hljs-operator">=</span> (myObject)input.readObject();  <span class="hljs-comment">//把文件中的对象读取到内存中</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>流</tag>
      
      <tag>文件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OrangeOS-alloc_free</title>
    <link href="/2023/01/10/OrangeOS-alloc_free/"/>
    <url>/2023/01/10/OrangeOS-alloc_free/</url>
    
    <content type="html"><![CDATA[<h1 id="OrangeOS-alloc-free"><a href="#OrangeOS-alloc-free" class="headerlink" title="OrangeOS-alloc_free"></a>OrangeOS-alloc_free</h1><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>以alloc为例，在测试文件中调用alloc函数分配指定大小的内存，该函数会调用<code>alloc(u32 size)</code>函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">PUBLIC <span class="hljs-type">void</span>* <span class="hljs-title function_">alloc</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> size)</span><br>&#123;<br>    MESSAGE msg;<br>    msg.type = ALLOC;<br>    msg.MM_SIZE = size;<br><br>send_recv(BOTH, TASK_MM, &amp;msg);<br>assert(msg.type == SYSCALL_RET);<br>assert(msg.RETVAL == <span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">return</span> msg.MM_ADDR;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数通过消息传递的方式和内核中的任务进行通信，消息类型为ALLOC，消息内容为分配内存的大小，之后将消息发送给TASK_MM，由task_mm()将消息转交给<code>do_alloc()</code>函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">task_mm()&#123;<br>...<br><span class="hljs-comment">// FREE &amp; ALLOC</span><br><span class="hljs-keyword">case</span> ALLOC:<br>mm_msg.RETVAL = do_alloc();<br><span class="hljs-keyword">break</span>;<br>       ...<br>   &#125;<br></code></pre></td></tr></table></figure><p>接下来，<code>do_alloc()</code>函数调用<code>tree_alloc</code>函数计算分配给该内存的地址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// mm/alloc.c</span><br>PUBLIC <span class="hljs-type">int</span> <span class="hljs-title function_">do_alloc</span><span class="hljs-params">()</span><br>&#123;<br>    printl(<span class="hljs-string">&quot;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n&quot;</span>);<br>    printl(<span class="hljs-string">&quot;Alloc 0x%x byte(s):\n&quot;</span>, mm_msg.MM_SIZE);<br><br>    mm_msg.MM_ADDR = tree_alloc(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, mm_msg.MM_SIZE);<br><br>    printl(<span class="hljs-string">&quot;Alloc at: 0x%x\n&quot;</span>, mm_msg.MM_ADDR);<br><br>    printl(<span class="hljs-string">&quot;Alloc Status:\n&quot;</span>);<br>    output(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    printl(<span class="hljs-string">&quot;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>tree_alloc(root, depth, addr)</code>函数使用伙伴算法对内存进行分配：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">递归分配内存</span><br><span class="hljs-string">root: 当前根结点编号</span><br><span class="hljs-string">depth: 当前结点深度</span><br><span class="hljs-string">size: 所需分配大小</span><br><span class="hljs-string">return: 分配地址，如果不够分配返回None</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">tree_alloc</span>(<span class="hljs-params">root, depth, size</span>):<br>    <span class="hljs-comment"># 计算划分层大小</span><br>    cur_pg_cnt = pg_cnt(depth)<br>    child_pg_cnt = floor(cur_pg_cnt / <span class="hljs-number">2</span>)<br>    cur_size = cur_pg_cnt * PAGE_SIZE<br>    child_size = child_pg_cnt * PAGE_SIZE<br>    <br>    <span class="hljs-comment"># 比最大可分配空间还要大，无法分配</span><br>    <span class="hljs-keyword">if</span> root == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> size &gt; cur_size:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br>    <span class="hljs-comment"># 判断当前结点属性</span><br>    <span class="hljs-comment"># 被占用，无法分配</span><br>    <span class="hljs-keyword">if</span> nodes[root] == BD_OCCUPIED:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>    <span class="hljs-comment"># 空闲状态，根据size决定是否划分</span><br>    <span class="hljs-keyword">elif</span> nodes[root] == BD_FREE:<br>        <span class="hljs-comment"># child &lt; size &lt;= cur 更新状态为占用，使用该结点分配</span><br>        <span class="hljs-keyword">if</span> size &gt; child_size:<br>            nodes[root] = BD_OCCUPIED<br>            <span class="hljs-keyword">return</span> base_addr(root, depth)<br>        <span class="hljs-comment"># size &lt;= child 划分该结点，并在左子树进行分配</span><br>        <span class="hljs-keyword">elif</span> size &lt;= child_size:<br>            nodes[root] = BD_SPLIT<br>            nodes[child_left(root)] = BD_FREE<br>            nodes[child_right(root)] = BD_FREE<br>            <span class="hljs-keyword">return</span> tree_alloc(child_left(root), depth + <span class="hljs-number">1</span>, size)<br><br>    <span class="hljs-comment"># 已划分状态，根据size决定是否能够分配</span><br>    <span class="hljs-keyword">elif</span> nodes[root] == BD_SPLIT:<br>        <span class="hljs-comment"># child &lt; size &lt;= cur 无法分配</span><br>        <span class="hljs-keyword">if</span> size &gt; child_size:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        <span class="hljs-comment"># size &lt;= child 尝试在子结点分配</span><br>        <span class="hljs-keyword">elif</span> size &lt;= child_size:<br>            <span class="hljs-comment"># 尝试在左子结点分配</span><br>            laddr = tree_alloc(child_left(root), depth + <span class="hljs-number">1</span>, size)<br>            <span class="hljs-comment"># 左子结点分配成功，返回该地址</span><br>            <span class="hljs-keyword">if</span> laddr != <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span> laddr<br>            <span class="hljs-comment"># 左子结点分配失败，尝试在右子结点分配</span><br>            <span class="hljs-keyword">else</span>:<br>                raddr = tree_alloc(child_right(root), depth + <span class="hljs-number">1</span>, size)<br>                <span class="hljs-comment"># 右子结点分配成功，返回该地址</span><br>                <span class="hljs-keyword">if</span> raddr != <span class="hljs-literal">None</span>:<br>                    <span class="hljs-keyword">return</span> raddr<br>                <span class="hljs-comment"># 右子结点分配失败，则无法在该子树分配</span><br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>    <span class="hljs-comment"># 未知逻辑</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">assert</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>算法说明：</p><p>定义区域<code>0x1C00000</code>~&#96;&#96;0x2000000&#96;&#96;为可分配空间，最小分配内存为4096KB，即一个页的大小，该大小是可调节的。之后定义一棵二叉树，该树的大小为$$2^{11} - 1$$，该大小取决于最大可分配空间和最小可分配空间。树的结点有以下定义方式：</p><p>SPLIT: 该结点是分支结点，有2个孩子结点，且该区域已经被划分</p><p>FREE:  该结点是孩子结点，且该区域没有被占用</p><p>OCCUPIED: 该结点是孩子结点，且该区域已经被占用</p><p>NONE: 空结点</p><p>算法执行流程见代码注释，其中，结点的基地址计算方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 结点的基地址</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">base_addr</span>(<span class="hljs-params">i, depth</span>):<br>    <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> ALLOC_BASE<br><br>    cur_pg_cnt = pg_cnt(depth)<br>    <span class="hljs-keyword">if</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> base_addr(parent(i), depth - <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> base_addr(parent(i), depth - <span class="hljs-number">1</span>) + cur_pg_cnt * PAGE_SIZE<br></code></pre></td></tr></table></figure><p>内存释放使用类似的算法，代码及注释如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">递归释放内存</span><br><span class="hljs-string">root: 当前根结点编号</span><br><span class="hljs-string">depth: 当前结点深度</span><br><span class="hljs-string">addr: 内存的基地址</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">tree_free</span>(<span class="hljs-params">root, depth, addr</span>):<br>    <span class="hljs-comment"># 空地址异常</span><br>    <span class="hljs-keyword">if</span> addr == <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">assert</span> <span class="hljs-literal">False</span><br>    <span class="hljs-comment"># 计算根结点的地址范围</span><br>    rt_addr_low = base_addr(root, depth)<br>    rt_addr_high = rt_addr_low + pg_cnt(depth) * PAGE_SIZE<br>    <span class="hljs-comment"># 地址越界，异常</span><br>    <span class="hljs-keyword">if</span> addr &lt; rt_addr_low <span class="hljs-keyword">or</span> addr &gt;= rt_addr_high:<br>        <span class="hljs-keyword">assert</span> <span class="hljs-literal">False</span><br><br>    <span class="hljs-comment"># 判断当前结点状态</span><br>    <span class="hljs-comment"># 当前结点被占用，判断地址是否相等</span><br>    <span class="hljs-keyword">if</span> nodes[root] == BD_OCCUPIED:<br>        <span class="hljs-comment"># 地址相等，更新状态FREE，直接释放</span><br>        <span class="hljs-keyword">if</span> rt_addr_low == addr:<br>            nodes[root] = BD_FREE<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-comment"># 地址不相等，异常</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">assert</span> <span class="hljs-literal">False</span><br>    <span class="hljs-comment"># 当前结点被划分，尝试在子结点中寻找</span><br>    <span class="hljs-keyword">elif</span> nodes[root] == BD_SPLIT:<br>        <span class="hljs-comment"># 计算子结点的基地址</span><br>        l_addr = base_addr(child_left(root), depth + <span class="hljs-number">1</span>)<br>        r_addr = base_addr(child_right(root), depth + <span class="hljs-number">1</span>)<br><br>        <span class="hljs-comment"># 判断地址的范围</span><br>        <span class="hljs-comment"># l_addr &lt;= addr &lt; r_addr 在左子结点中寻找</span><br>        <span class="hljs-keyword">if</span> addr &gt;= l_addr <span class="hljs-keyword">and</span> addr &lt; r_addr:<br>            tree_free(child_left(root), depth + <span class="hljs-number">1</span>, addr)<br>            <span class="hljs-comment"># 左子结点释放成功，判断是否能合并</span><br>            <span class="hljs-comment"># 根据左子结点的状态判断</span><br>            <span class="hljs-comment"># 左子结点为FREE，可能合并</span><br>            <span class="hljs-keyword">if</span> nodes[child_left(root)] == BD_FREE:<br>                <span class="hljs-comment"># 如果右子结点也为FREE，则合并结点，更新状态</span><br>                <span class="hljs-keyword">if</span> nodes[child_right(root)] == BD_FREE:<br>                    nodes[root] = BD_FREE<br>                    nodes[child_left(root)] = BD_NONE<br>                    nodes[child_right(root)] = BD_NONE<br>                    <span class="hljs-keyword">return</span><br>                <span class="hljs-comment"># 否则不做处理</span><br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">return</span><br>            <span class="hljs-comment"># 左子结点为SPLIT，不能合并</span><br>            <span class="hljs-keyword">elif</span> nodes[child_left(root)] == BD_SPLIT:<br>                <span class="hljs-keyword">return</span><br>            <span class="hljs-comment"># 左子结点为OCCUPIED, 异常</span><br>            <span class="hljs-keyword">elif</span> nodes[child_left(root)] == BD_OCCUPIED:<br>                <span class="hljs-keyword">assert</span> <span class="hljs-literal">False</span><br>            <span class="hljs-comment"># 左子结点为NONE, 异常</span><br>            <span class="hljs-keyword">elif</span> nodes[child_left(root)] == BD_NONE:<br>                <span class="hljs-keyword">assert</span> <span class="hljs-literal">False</span><br>            <span class="hljs-comment"># 未知逻辑，异常</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">assert</span> <span class="hljs-literal">False</span><br>        <span class="hljs-comment"># addr &gt;= r_addr 在右子结点中寻找</span><br>        <span class="hljs-keyword">elif</span> addr &gt;= r_addr:<br>            tree_free(child_right(root), depth + <span class="hljs-number">1</span>, addr)<br>            <span class="hljs-comment"># 右子结点释放成功，判断是否能合并</span><br>            <span class="hljs-comment"># 根据右子结点的状态判断</span><br>            <span class="hljs-comment"># 右子结点为FREE，可能合并</span><br>            <span class="hljs-keyword">if</span> nodes[child_right(root)] == BD_FREE:<br>                <span class="hljs-comment"># 如果左子结点也为FREE，则合并结点，更新状态</span><br>                <span class="hljs-keyword">if</span> nodes[child_left(root)] == BD_FREE:<br>                    nodes[root] = BD_FREE<br>                    nodes[child_left(root)] = BD_NONE<br>                    nodes[child_right(root)] = BD_NONE<br>                    <span class="hljs-keyword">return</span><br>                <span class="hljs-comment"># 否则不做处理</span><br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">return</span><br>            <span class="hljs-comment"># 右子结点为SPLIT，不能合并</span><br>            <span class="hljs-keyword">elif</span> nodes[child_right(root)] == BD_SPLIT:<br>                <span class="hljs-keyword">return</span><br>            <span class="hljs-comment"># 右子结点为OCCUPIED, 异常</span><br>            <span class="hljs-keyword">elif</span> nodes[child_right(root)] == BD_OCCUPIED:<br>                <span class="hljs-keyword">assert</span> <span class="hljs-literal">False</span><br>            <span class="hljs-comment"># 右子结点为NONE, 异常</span><br>            <span class="hljs-keyword">elif</span> nodes[child_right(root)] == BD_NONE:<br>                <span class="hljs-keyword">assert</span> <span class="hljs-literal">False</span><br>            <span class="hljs-comment"># 未知逻辑，异常</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">assert</span> <span class="hljs-literal">False</span><br>        <span class="hljs-comment"># 未知逻辑，异常</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">assert</span> <span class="hljs-literal">False</span><br>    <span class="hljs-comment"># 当前结点空闲，异常</span><br>    <span class="hljs-keyword">elif</span> nodes[root] == BD_FREE:<br>        <span class="hljs-keyword">assert</span> <span class="hljs-literal">False</span><br>    <span class="hljs-comment"># 当前结点不存在，异常</span><br>    <span class="hljs-keyword">elif</span> nodes[root] == BD_NONE:<br>        <span class="hljs-keyword">assert</span> <span class="hljs-literal">False</span><br>    <span class="hljs-comment"># 未知逻辑，异常</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">assert</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Lambda表达式和流</title>
    <link href="/2023/01/10/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E6%B5%81/"/>
    <url>/2023/01/10/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h1 id="Lambda表达式和流"><a href="#Lambda表达式和流" class="headerlink" title="Lambda表达式和流"></a>Lambda表达式和流</h1><h2 id="函数接口"><a href="#函数接口" class="headerlink" title="函数接口"></a>函数接口</h2><p>实现函数功能的接口</p><p><img src="/2023/01/10/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E6%B5%81/image-20200927233555332.png" alt="image-20200927233555332"></p><h2 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h2><p><strong>语法</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-function"><span class="hljs-params">(parameterList)</span>-&gt;</span>&#123;statements&#125;<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">(x, y)-&gt;&#123;<span class="hljs-keyword">return</span> x+y;&#125;<br><span class="hljs-comment">//or</span><br>(x, y)-&gt; x + y<br><br>value-&gt;System.out.println(value)<br>()-&gt;System.out.println(<span class="hljs-string">&quot;hello world!&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="Streams类"><a href="#Streams类" class="headerlink" title="Streams类"></a>Streams类</h2><p>在Java中，Streams类实现了Stream接口。流可以用来加工和传递数据。</p><p><strong>使用流的好处：</strong></p><ul><li><p>Java 8 中的 Stream 是对集合（Collection）对象功能的增强。</p></li><li><p>它专注于对集合对象进行各种非常便利、高效的聚合操作（aggregate operation），或者大批量数据操作 (bulk data operation)。</p></li><li><p>Stream API 借助于同样新出现的 Lambda 表达式，极大的提高编程效率和程序可读性。</p></li><li><p>它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 fork&#x2F;join 并行方式来拆分任务和加速处理过程。</p></li><li><p>通常编写并行代码很难而且容易出错, 但使用 Stream API 无需编写一行多线程的代码，就可以很方便地写出高性能的并发程序。所以说，Java 8 中首次出现的 java.util.stream 是一个函数式语言+多核时代综合影响的产物。</p></li></ul><h3 id="Stream-Pipelines"><a href="#Stream-Pipelines" class="headerlink" title="Stream Pipelines"></a>Stream Pipelines</h3><p>流在移动数据的时候加工里面的元素，称之为<strong>管线</strong>。它不像Collections可以保留数据，原始数据被加工后就无法重新使用了。</p><h3 id="Intermediate-and-Terminal-Operations"><a href="#Intermediate-and-Terminal-Operations" class="headerlink" title="Intermediate and Terminal Operations"></a>Intermediate and Terminal Operations</h3><p>Intermediate operation是懒惰的，它直到Terminal Operation被调用后才会执行，即不会改变流的状态，可以继续被其他的Operation调用。</p><p><img src="/2023/01/10/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E6%B5%81/image-20200927235107596.png" alt="image-20200927235107596"></p><p>而Terminal Operation是饥渴的，它会加工中间操作然后产生一个结果，这时流已经被破坏而不能使用了。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">IntStream</span> <span class="hljs-variable">intStream</span> <span class="hljs-operator">=</span> IntStream.of(values);  <span class="hljs-comment">//values 是一个整型数组</span><br>intStream.reduce(<span class="hljs-number">0</span>, (x, y), x + y);          <span class="hljs-comment">//因为是Terminal Operation，流已经被破坏</span><br>intStream.reduce(<span class="hljs-number">0</span>, (x, y), x + y);          <span class="hljs-comment">//这时再执行会报错</span><br></code></pre></td></tr></table></figure><p><img src="/2023/01/10/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E6%B5%81/image-20200927235525344.png" alt="image-20200927235525344"></p><h3 id="实例1：使用IntStream-Operations来简化Arrays和ArrayList"><a href="#实例1：使用IntStream-Operations来简化Arrays和ArrayList" class="headerlink" title="实例1：使用IntStream Operations来简化Arrays和ArrayList"></a>实例1：使用IntStream Operations来简化Arrays和ArrayList</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//定义数组values</span><br><span class="hljs-type">int</span>[] values = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br><span class="hljs-comment">//</span><br><span class="hljs-comment">//输出每个值</span><br>IntStream.of(values).forEach(value-&gt;System.out.printf(<span class="hljs-string">&quot;%d &quot;</span>, value));<br><span class="hljs-comment">//其他方式</span><br>Arrays.toString(values);<br>fori;<br><span class="hljs-comment">//</span><br><span class="hljs-comment">//获取长度</span><br>IntStream.of(values).count();<br><span class="hljs-comment">//获取最值</span><br>IntStream.of(values).min().getAsInt();<br>IntStream.of(values).max().getAsInt();<br><span class="hljs-comment">//reduce方法</span><br>IntStream.of(values).reduce(<span class="hljs-number">0</span>, (x, y)-&gt; x+y);  <span class="hljs-comment">//对values求和</span><br><span class="hljs-comment">//其他方式</span><br>IntStream.of(values).sum();<br>fori;<br><span class="hljs-comment">//</span><br><span class="hljs-comment">//输出偶数的10倍，这时先使用Intermediate 再使用Terminal Operation</span><br>IntStream.of(values).filter(value-&gt;value % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).map(vakye-&gt;value * <span class="hljs-number">10</span>).sorted().forEach(value-&gt;sysout(value));<br><span class="hljs-comment">//求1~9的和</span><br>IntStream.range(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>).sum();<br></code></pre></td></tr></table></figure><h3 id="实例2：使用Stream-lt-Integer-gt-Manipulations来处理Integer"><a href="#实例2：使用Stream-lt-Integer-gt-Manipulations来处理Integer" class="headerlink" title="实例2：使用Stream&lt; Integer &gt;  Manipulations来处理Integer[]"></a>实例2：使用Stream&lt; Integer &gt;  Manipulations来处理Integer[]</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer[] values = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br>Arrays.stream(values).collect(Collectors.toList());   <span class="hljs-comment">//将数组转换成一个集合类，比如列表，映射</span><br><span class="hljs-comment">//另一种转换方式</span><br>Collections.addAll(arrayList, values);<br><span class="hljs-comment">//对元素进行筛选和排序</span><br>Arrays.stream(values).filter(value-&gt;value &gt; <span class="hljs-number">4</span>).sorted().collect(Collectors.toList());<br></code></pre></td></tr></table></figure><h3 id="实例3：使用Stream-lt-String-gt-Manipulations简化Strings-Characters-和-Regular-Expressions"><a href="#实例3：使用Stream-lt-String-gt-Manipulations简化Strings-Characters-和-Regular-Expressions" class="headerlink" title="实例3：使用Stream&lt; String &gt; Manipulations简化Strings, Characters 和 Regular Expressions"></a>实例3：使用Stream&lt; String &gt; Manipulations简化Strings, Characters 和 Regular Expressions</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] strings = &#123;<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>, <span class="hljs-string">&quot;yellow&quot;</span>&#125;;<br><span class="hljs-comment">//将字符串转换成大写</span><br>Arrays.stream(strings).map(String::toUpperCase).collect(Collectors.toList());  <br><span class="hljs-comment">//等价于</span><br>System.out.println(Arrays.stream(strings).map(s-&gt;s.toUpperCase()).collect(Collectors.toList()));<br><br>Arrays.stream(strings).sorted(String.CASE_INSENSITIVE_ORDER).collect(Collectors.toList());<span class="hljs-comment">//根据字典序排序</span><br><br></code></pre></td></tr></table></figure><p>String::toUppercase 是一个方法引用，相当于把参数的表达式省略了，但实际上依然是使用具体的实例来引用方法。</p><p>其他的方式如下：</p><p><img src="/2023/01/10/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E6%B5%81/image-20200929162129817.png" alt="image-20200929162129817"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">Employee[] list;  <span class="hljs-comment">//一个对象数组</span><br>String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span>;  <span class="hljs-comment">//有一个toString方法</span><br><br><span class="hljs-comment">//输出list</span><br>list.stream().forEach(System.out::println);  <br><span class="hljs-comment">//等价于</span><br>list.stream().forEach(obj-&gt;sysout(obj));<br><br><span class="hljs-comment">//使用谓词存储判断条件，然后根据条件筛选并按照薪水高低对员工进行排序</span><br>Predicate&lt;Employee&gt; fourToSixThousand = e -&gt; (e.getSalary() &gt;= <span class="hljs-number">4000</span> &amp;&amp; e.getSalary() &lt;= <span class="hljs-number">6000</span>);<br>list.stream().filter(forToSixThousand).sorted(Comparator.comparing(Employee::getSalary))<br>.forEach(System.out::println);<br><span class="hljs-comment">//找到第一个符合条件的值</span><br>list.stream().filter(fourToSixThousand).findFirst().get());<br></code></pre></td></tr></table></figure><p><strong>函数变量和多领域比较</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//接受单个参数，然后返回String类型</span><br>Function&lt;Employee, String&gt; byFirstName = Employee::getFirstName;<br>Function&lt;Employee, String&gt; byLastName = Employee::getLastName;<br><br><span class="hljs-comment">//先根据姓排序，再根据名排序</span><br>Comparator&lt;Employee&gt; lastThenFirst = Comparator.comparing(byLastName).thenComparing(byFirstName);<br><br><span class="hljs-comment">//进行排序</span><br>list.stream().sorted(lastThenFirst).forEach(System.out::println);<br><span class="hljs-comment">//倒序排</span><br>list.stream().sorted(lastThenFirst.reversed()).forEach(System.out::println);<br></code></pre></td></tr></table></figure><p>使用map和distinct来产生唯一元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">list.stream().map(Employee::getLastName).distinct().sorted().forEach(System.out::println);<br></code></pre></td></tr></table></figure><p><strong>groupingBy方法对对象进行分类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//这里使用的是一个比较常用的实例，根据某个数值范围来将数据分成许多个小段</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>        <span class="hljs-keyword">private</span> String name;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>            <span class="hljs-built_in">this</span>.name = name;<br>            <span class="hljs-built_in">this</span>.age = age;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> name;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>            <span class="hljs-built_in">this</span>.name = name;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> age;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>            <span class="hljs-built_in">this</span>.age = age;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;&quot;</span> +<br>                    <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                    <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                    <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">byAgeRange</span><span class="hljs-params">()</span>&#123;<br>            <span class="hljs-comment">//设定最高年龄和最低年龄，然后按照&lt;=59 ... 90~99, 100的标准划分</span><br>            <span class="hljs-keyword">if</span>(getAge() &lt;= <span class="hljs-number">59</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;=59&quot;</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(getAge() == <span class="hljs-number">100</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;100&quot;</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">ten</span> <span class="hljs-operator">=</span> getAge() / <span class="hljs-number">10</span>;<br>                <span class="hljs-keyword">return</span> String.format(ten + <span class="hljs-string">&quot;0~&quot;</span> + ten + <span class="hljs-string">&quot;9&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Person[] perons = &#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;chen&quot;</span>, <span class="hljs-number">10</span>),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;wen&quot;</span>, <span class="hljs-number">78</span>),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;shu&quot;</span>, <span class="hljs-number">100</span>),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;guo&quot;</span>, <span class="hljs-number">31</span>)<br>        &#125;;<br>        List&lt;Person&gt; list = Arrays.stream(perons).collect(Collectors.toList());<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;fan&quot;</span>, <span class="hljs-number">65</span>));<br><br>        Map&lt;String, List&lt;Person&gt;&gt; groupByName = list.stream().collect(Collectors.groupingBy(Person::byAgeRange));<br>        System.out.println(groupByName);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;<span class="hljs-number">100</span>=[Person&#123;name=<span class="hljs-string">&#x27;shu&#x27;</span>, age=<span class="hljs-number">100</span>&#125;], <span class="hljs-number">60</span>~<span class="hljs-number">69</span>=[Person&#123;name=<span class="hljs-string">&#x27;fan&#x27;</span>, age=<span class="hljs-number">65</span>&#125;], <span class="hljs-number">70</span>~<span class="hljs-number">79</span>=[Person&#123;name=<span class="hljs-string">&#x27;wen&#x27;</span>, age=<span class="hljs-number">78</span>&#125;], &lt;=<span class="hljs-number">59</span>=[Person&#123;name=<span class="hljs-string">&#x27;chen&#x27;</span>, age=<span class="hljs-number">10</span>&#125;, Person&#123;name=<span class="hljs-string">&#x27;guo&#x27;</span>, age=<span class="hljs-number">31</span>&#125;]&#125;<br></code></pre></td></tr></table></figure><p><strong>将结果映射成double类型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">list.stream().mapToDouble(Employee::getSalary).reduce(<span class="hljs-number">0</span>, (value1, value2)-&gt;value1 + value2);<br>list.stream().mapToDouble(Employee::getSalary).average().getAsDouble();<br></code></pre></td></tr></table></figure><h3 id="实例4：从文件中创建字符流"><a href="#实例4：从文件中创建字符流" class="headerlink" title="实例4：从文件中创建字符流"></a>实例4：从文件中创建字符流</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//将某个文件中的单词做成一个字典。</span><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.nio.file.Files;<br><span class="hljs-keyword">import</span> java.nio.file.Paths;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.TreeMap;<br><span class="hljs-keyword">import</span> java.util.regex.Pattern;<br><span class="hljs-keyword">import</span> java.util.stream.Collectors;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StreamOfLines</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">Pattern</span> <span class="hljs-variable">pattern</span> <span class="hljs-operator">=</span> Pattern.compile(<span class="hljs-string">&quot;\\s+&quot;</span>);<br><br>        Map&lt;String, Long&gt; wordCounts =<br>                Files.lines(Paths.get(<span class="hljs-string">&quot;src/main/resources/test.txt&quot;</span>))      <span class="hljs-comment">//将文件转换成一行行字符串组成的流</span><br>                        .map(line -&gt; line.replaceAll(<span class="hljs-string">&quot;(?!&#x27;)\\p&#123;P&#125;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>))   <span class="hljs-comment">//取代所有标点符号(\\p&#123;P&#125;)</span><br>                        .filter(line -&gt; line.compareTo(<span class="hljs-string">&quot;&quot;</span>) != <span class="hljs-number">0</span>)           <span class="hljs-comment">//把空行筛选掉</span><br>                        .flatMap(line -&gt; pattern.splitAsStream(line))      <span class="hljs-comment">//将分解得到的多个流汇聚成一股流</span><br>                        .collect(Collectors.groupingBy(String::toLowerCase,<br>                                TreeMap::<span class="hljs-keyword">new</span>, Collectors.counting()));     <span class="hljs-comment">//将流转换成Map结构</span><br><br>        wordCounts.entrySet()        <span class="hljs-comment">//将map转换成key-value pair(称作entry)存储在set中</span><br>                .stream()<br>                .collect(<br>                        Collectors.groupingBy(entry -&gt; entry.getKey().charAt(<span class="hljs-number">0</span>), TreeMap::<span class="hljs-keyword">new</span>, Collectors.toList()))            <span class="hljs-comment">//将首字母相同的单词放在同一个列表中，元素类型为entry</span><br>                .forEach((letter, wordList) -&gt;    <span class="hljs-comment">//按层级进行输出</span><br>                &#123;<br>                    System.out.printf(<span class="hljs-string">&quot;%n%C%n&quot;</span>, letter);<br>                    wordList.stream().forEach(word -&gt; System.out.printf(<br>                            <span class="hljs-string">&quot;%13s: %d%n&quot;</span>, word.getKey(), word.getValue()<br>                    ));<br>                &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实例5：使用流来统计随机结果"><a href="#实例5：使用流来统计随机结果" class="headerlink" title="实例5：使用流来统计随机结果"></a>实例5：使用流来统计随机结果</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.security.SecureRandom;<br><span class="hljs-keyword">import</span> java.util.function.Function;<br><span class="hljs-keyword">import</span> java.util.stream.Collectors;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RandomIntStream</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SecureRandom</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecureRandom</span>();<br><br>        System.out.printf(<span class="hljs-string">&quot;%-6s%s%n&quot;</span>, <span class="hljs-string">&quot;Face&quot;</span>, <span class="hljs-string">&quot;Frequency&quot;</span>);<br>        random.ints(<span class="hljs-number">600_000</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>)                                           <span class="hljs-comment">//返回IntStream</span><br>                .boxed()                              <span class="hljs-comment">//将IntStream转化为Stream&lt;Integer&gt;,以使用方法collect</span><br>                .collect(Collectors.groupingBy(Function.identity(),   <span class="hljs-comment">//等价于digit -&gt; digit，即返回自身</span><br>                        Collectors.counting()))<br>                .forEach((face, frequency) -&gt;<br>                        System.out.printf(<span class="hljs-string">&quot;%-6d%d%n&quot;</span>, face, frequency));<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>注：Java不允许原始数据放入集合中，而infinite stream（比如IntStream）的元素个数是未知的，因此需要使用boxed将其转换为Stream&lt; Integer &gt;。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Lambda</tag>
      
      <tag>流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaWeb</title>
    <link href="/2023/01/10/Java_Web/"/>
    <url>/2023/01/10/Java_Web/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaWeb"><a href="#JavaWeb" class="headerlink" title="JavaWeb"></a>JavaWeb</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul><li>静态web</li><li>动态web<ul><li>技术栈：Servlet&#x2F;ISP，ASP，PHP</li></ul></li></ul><p>几乎所有网站都是动态Web,即不同的人会接收到不同的信息。</p><p>在Java中，动态web资源开发的技术统称为JavaWeb</p><h3 id="web应用程序"><a href="#web应用程序" class="headerlink" title="web应用程序"></a>web应用程序</h3><p>web应用程序：可以提供浏览器访问的程序；</p><ul><li>*.html… 多个web资源，这些web资源可以被外界访问，对外界提供服务；</li><li>能访问到的任何一个页面或者资源，都存储在某一个计算机上。</li><li>URL：网络地址</li><li>统一的web资源会被放在同一个文件夹下，web应用程序-&gt;Tomcat: 服务器</li><li>web应用由多部分组成（静态，动态web）<ul><li>html，css，js</li><li>jsp，servlet</li><li>Java程序</li><li>jar包</li><li>配置文件（Properties）</li></ul></li></ul><p>web应用程序编写完毕后，若想提供给外界访问，需要一个服务器来统一管理；</p><h3 id="静态web"><a href="#静态web" class="headerlink" title="静态web"></a>静态web</h3><ul><li>*htm, *.html, 常见网页后缀，如果服务器上一直存在这些东西，就可以直接进行读取。</li></ul><p><img src="/2023/01/10/Java_Web/Java_Web%5CJava_Web.png" alt="page1"></p><ul><li>静态web存在缺点<ul><li>Web页面无法动态更新<ul><li>轮播图，点击特效：伪动态</li><li>JavaScript</li><li>VBScript</li></ul></li><li>无法和数据库交互（数据无法持久化，用户无法交互）</li></ul></li></ul><h3 id="动态web"><a href="#动态web" class="headerlink" title="动态web"></a>动态web</h3><p>页面会动态展示：Web的页面展示的效果因人而异</p><p><img src="/2023/01/10/Java_Web/Java_Web%5CJava_Web-Page-2.png" alt="activeWeb"></p><p>缺点：</p><ul><li>假如服务器的动态Web资源出现了错误，我们需要重新编写后台程序, 重新发布；<ul><li>停机维护</li></ul></li></ul><p>优点：</p><ul><li>Web页面可以动态更新</li><li>可以与数据库交互（数据持久化：注册，商品信息… …）</li></ul><h2 id="Web服务器"><a href="#Web服务器" class="headerlink" title="Web服务器"></a>Web服务器</h2><h3 id="技术讲解"><a href="#技术讲解" class="headerlink" title="技术讲解"></a>技术讲解</h3><p>ASP：</p><ul><li>微软：国内最早流行；</li><li>在HTML中嵌入了VB的脚本，ASP + COM；</li><li>在ASP开发中，基本一个页面都有几千行业务代码，页面极其换乱</li><li>维护成本高</li><li>C#</li><li>IIS</li></ul><p>PHP：</p><ul><li>PHP开发速度很快，功能强大，跨平台，代码简单（70%，WP）</li><li>无法承载大访问量的情况（局限性）</li></ul><p>JSP&#x2F;Servlet：</p><p>B&#x2F;S：浏览器和服务器</p><p>C&#x2F;S：客户端和服务器</p><ul><li>sun公司主推的B&#x2F;S架构</li><li>基于Java语言（所有大公司或者一些开源的组件都是用java写）</li><li>可以承载三高问题带来的影响（高并发，高可用，高影响）</li><li>语法像ASP，加强市场强度</li></ul><h3 id="web服务器"><a href="#web服务器" class="headerlink" title="web服务器"></a>web服务器</h3><p>服务器是一种被动的操作，用来处理用户的一些请求和给用户一些响应信息；</p><p>IIS：</p><ul><li>微软开发；ASP…, Windows中自带</li></ul><p>Tomcat：</p><ul><li>免费</li><li>Web应用服务器，轻量级</li><li>适合初学</li></ul><p>下载Tomcat：</p><ol><li>安装or解压</li><li>了解配置文件及目录结构</li><li>作用</li></ol><h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><h3 id="安装Tomcat"><a href="#安装Tomcat" class="headerlink" title="安装Tomcat"></a>安装Tomcat</h3><p>到官网安装</p><h3 id="Tomcat启动和配置"><a href="#Tomcat启动和配置" class="headerlink" title="Tomcat启动和配置"></a>Tomcat启动和配置</h3><p>启动：startup.bat 关闭：shutdown.bat</p><p>访问测试：<a href="http://localhost:8080/">http://localhost:8080/</a></p><p>可能遇到问题：</p><ol><li>java环境变量没有配置</li><li>闪退问题：需要配置兼容性</li><li>乱码问题：配置文件设置</li></ol><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>文件：conf&#x2F;server.xml</p><p>配置启动的端口号</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;8080&quot;</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">&quot;HTTP/1.1&quot;</span></span><br><span class="hljs-tag">           <span class="hljs-attr">connectionTimeout</span>=<span class="hljs-string">&quot;20000&quot;</span></span><br><span class="hljs-tag">           <span class="hljs-attr">redirectPort</span>=<span class="hljs-string">&quot;8443&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><ul><li>Tomcat的默认端口号为：8080</li><li>mysql: 3306</li><li>https: 443</li><li>http: 80</li></ul><p>配置主机名称：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">Host</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;localhost&quot;</span>  <span class="hljs-attr">appBase</span>=<span class="hljs-string">&quot;webapps&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">unpackWARs</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">autoDeploy</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>默认主机名为：localhost-&gt; 127.0.0.1</li><li>默认网站应用存放的位置：webapps</li></ul><br><p><strong>网站如何进行访问的？</strong></p><ol><li><p>输入域名；</p></li><li><p>检查本机的C:&#x2F;Windows&#x2F;System32&#x2F;drivers&#x2F;etc&#x2F;hosts配置文件下有没有这个域名映射;</p><ol><li><p>有：直接返回对应的ip地址, 在这个地址中，有我们需要访问的web程序，可以直接访问</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> www.baidu.com<br></code></pre></td></tr></table></figure></li><li><p>没有：去DNS服务器找，如果没有，返回404</p></li></ol><p><img src="/2023/01/10/Java_Web/Java_Web%5CJava_Web-Page-3.png" alt="find_web"></p><h3 id="发布Web网站"><a href="#发布Web网站" class="headerlink" title="发布Web网站"></a>发布Web网站</h3><ul><li><p>将自己写的网站放到服务器（tomcat）中指定的web应用的文件夹（webapps）下，就可以访问了</p></li><li><p>网站应有的结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">--webapps: Tomcat服务器的目录<br>    -ROOT<br>    -study：网站的目录名<br>    - WEB-INF<br>    -classes：java程序<br>    -web.xml<br>    -lib：web应用所依赖的jar包<br>    - index.html：默认的首页<br>    - <span class="hljs-keyword">static</span><br>    -css<br>    -style.css<br>    -js<br>    -img<br>    ...<br></code></pre></td></tr></table></figure></li></ul></li></ol><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="什么是HTTP？"><a href="#什么是HTTP？" class="headerlink" title="什么是HTTP？"></a>什么是HTTP？</h3><p>HTTP（超文本传输协议）请求-响应协议，通常运行在TCP之上。</p><ul><li>文本：html, 字符串 …</li><li>超文本：图片，音乐， 视频， 定位， 地图… …</li><li>默认端口：80</li></ul><p>HTTPS：</p><ul><li>默认端口：443</li><li>安全的</li></ul><h3 id="两个时代"><a href="#两个时代" class="headerlink" title="两个时代"></a>两个时代</h3><ul><li>http1.0<ul><li>HTTP&#x2F;1.0：客户端可以与web服务器连接后，只能获得一个web资源，断开连接，重复连接很消耗流量</li></ul></li><li>http2.0<ul><li>HTTP&#x2F;1.1：连接后可以获得多个web资源</li></ul></li></ul><h3 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h3><ul><li>客户端-&gt; 发请求-&gt; 服务器</li></ul><p>百度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">General:<br>Request URL: https:<span class="hljs-comment">//www.baidu.com/   请求地址</span><br>Request Method: GET     <span class="hljs-comment">//get方法/post方法</span><br>Status Code: <span class="hljs-number">200</span> OK     <span class="hljs-comment">//状态码：200</span><br>Remote Address: <span class="hljs-number">14.215</span><span class="hljs-number">.177</span><span class="hljs-number">.39</span>:<span class="hljs-number">443</span>   <span class="hljs-comment">//远程地址</span><br>Referrer Policy: no-referrer-when-downgrade<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Request Headers:<br>Accept: text/html<br>Accept-Encoding: gzip, deflate, br<br>Accept-Language: zh-CN,zh;q=<span class="hljs-number">0.9</span>  <span class="hljs-comment">//语言</span><br>Cache-Control: max-age=<span class="hljs-number">0</span><br>Connection: keep-alive<br></code></pre></td></tr></table></figure><h4 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h4><ul><li>请求行中的请求方式：GET</li><li>请求方式：Get&#x2F;Post，HEAD，DELETE，PUT，TRACT…<ul><li>get:请求能够携带的参数比较少，大小有限制，会在浏览器的URL地址栏显示数据内容，不安全，但高效</li><li>post:请求携带参数没有限制，大小没有限制，不会在浏览器显示数据内容，安全，但效率较低</li></ul></li></ul><h4 id="消息头"><a href="#消息头" class="headerlink" title="消息头"></a>消息头</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Accept:                            <span class="hljs-comment">//告诉浏览器所支持的数据类型</span><br>Accept-Encoding: gzip, deflate, br <span class="hljs-comment">//支持哪种编码格式 GBK UTF-8 GB2312 ISO8859-1</span><br>Accept-Language: zh-CN,zh;q=<span class="hljs-number">0.9</span>    <span class="hljs-comment">//语言环境</span><br>Cache-Control: max-age=<span class="hljs-number">0</span>           <span class="hljs-comment">//控制缓存</span><br>Connection: keep-alive             <span class="hljs-comment">//告诉浏览器，请求完成是断开还是保持连接</span><br>HOST:                              <span class="hljs-comment">//主机</span><br></code></pre></td></tr></table></figure><h3 id="HTTP响应"><a href="#HTTP响应" class="headerlink" title="HTTP响应"></a>HTTP响应</h3><ul><li>服务器 -&gt; 响应 -&gt; 客户端</li></ul><p>百度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Cache-Control: <span class="hljs-keyword">private</span>                 <span class="hljs-comment">//缓存控制</span><br>Connection: keep-alive                 <span class="hljs-comment">//连接：保持</span><br>Content-Encoding: gzip<br>Content-Type: text/html;charset=utf-<span class="hljs-number">8</span>  <span class="hljs-comment">//类型</span><br></code></pre></td></tr></table></figure><h4 id="响应体"><a href="#响应体" class="headerlink" title="响应体"></a>响应体</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">Accept:                            <span class="hljs-comment">//告诉浏览器所支持的数据类型</span><br>Accept-Encoding: gzip, deflate, br <span class="hljs-comment">//支持哪种编码格式 GBK UTF-8 GB2312 ISO8859-1</span><br>Accept-Language: zh-CN,zh;q=<span class="hljs-number">0.9</span>    <span class="hljs-comment">//语言环境</span><br>Cache-Control: max-age=<span class="hljs-number">0</span>           <span class="hljs-comment">//控制缓存</span><br>Connection: keep-alive             <span class="hljs-comment">//告诉浏览器，请求完成是断开还是保持连接</span><br>HOST:                              <span class="hljs-comment">//主机</span><br>Refrush:                           <span class="hljs-comment">//告诉客户端，多久刷新一次</span><br>Location:                          <span class="hljs-comment">//让网页重新定位</span><br></code></pre></td></tr></table></figure><h4 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码"></a>响应状态码</h4><p>200：请求响应成功  200</p><p>3xx: 请求重定向</p><ul><li>重定向：重新到给定的新位置去；</li></ul><p>4xx：找不到资源  404</p><ul><li>资源不存在;</li></ul><p>5xx：服务器代码错误  500              502: 网关错误</p><br><p><strong>当你的浏览器中地址栏输入地址并回车的一瞬间到页面能够展示回来，经历了什么？</strong></p><h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ol><li>在java web开发中，需要使用大量的jar包，需要手动去导入；</li><li>自动帮助导入和配置这些jar包；</li></ol><h3 id="Maven项目架构管理工具"><a href="#Maven项目架构管理工具" class="headerlink" title="Maven项目架构管理工具"></a>Maven项目架构管理工具</h3><p>用来方便导入jar包</p><p>Maven核心思想：<strong>约定大于配置</strong></p><ul><li>有约束，不要去违反</li></ul><p>Maven会规定好你该如何去编写好java代码，必须按照这个规范来；</p><h3 id="下载安装Maven"><a href="#下载安装Maven" class="headerlink" title="下载安装Maven"></a>下载安装Maven</h3><p>官网下载</p><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>在系统环境变量中：</p><ul><li>M2_HOME Maven目录下的bin目录</li><li>MAVEN_HOME Maven的目录</li><li>在系统的path中配置%MAVEN_HOME%\bin</li></ul><h3 id="阿里云镜像"><a href="#阿里云镜像" class="headerlink" title="阿里云镜像"></a>阿里云镜像</h3><p>mirrors</p><ul><li>作用：加速下载</li></ul><p>国内建议使用阿里云镜像</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>nexus-aliyun<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>*,!jeecg,!jeecg-snapshots<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Nexus aliyun<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span><br>        http://maven.aliyun.com/nexus/content/groups/public/<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="本地仓库"><a href="#本地仓库" class="headerlink" title="本地仓库"></a>本地仓库</h3><p>建立一个本地仓库：localRepository</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">localRepository</span>&gt;</span>D:\Program Files (x86)\apache-maven-3.6.3\maven-repo<span class="hljs-tag">&lt;/<span class="hljs-name">localRepository</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="在IDEA中使用Maven"><a href="#在IDEA中使用Maven" class="headerlink" title="在IDEA中使用Maven"></a>在IDEA中使用Maven</h3><ol><li><p>启动IDEA</p></li><li><p>创建一个Maven项目</p><p>选择Maven创建项目，然后选择maven-archetype-webapp</p><p>选择之前配置好的Maven路径</p></li><li><p>观察maven-repo</p></li><li><p>IDEA中的Maven设置</p><p>IDEA项目创建成功后，看一眼Maven的配置</p></li><li><p>Maven在IDEA中的配置和使用完成</p></li></ol><h3 id="创建一个普通的Maven项目"><a href="#创建一个普通的Maven项目" class="headerlink" title="创建一个普通的Maven项目"></a>创建一个普通的Maven项目</h3><p>不勾选模板选项</p><p>main: 放置java源代码</p><p>resources:放置配置文件</p><p>test:测试使用</p><h3 id="在IDEA中标记文件夹功能"><a href="#在IDEA中标记文件夹功能" class="headerlink" title="在IDEA中标记文件夹功能"></a>在IDEA中标记文件夹功能</h3><p>右键，Mark Directory as</p><h3 id="在IDEA中配置Tomcat"><a href="#在IDEA中配置Tomcat" class="headerlink" title="在IDEA中配置Tomcat"></a>在IDEA中配置Tomcat</h3><p>在Add configuration中添加Tomcat Server</p><p>解决警告问题：</p><ul><li>原因：访问网站需要一个指定的文件夹名称</li><li>解决办法：点击fix，选择… war</li></ul><h3 id="pom文件"><a href="#pom文件" class="headerlink" title="pom文件"></a>pom文件</h3><p>pom.xml是maven的核心配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>JavaWeb-maven-01<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--项目的打包方式</span><br><span class="hljs-comment">    jar:java应用</span><br><span class="hljs-comment">    war:JavaWeb应用</span><br><span class="hljs-comment">  --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>war<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>JavaWeb-maven-01 Maven Webapp<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- FIXME change it to the project&#x27;s website --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://www.example.com<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!--配置--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--项目的默认构建编码--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.7<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.7<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!--项目依赖--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.11<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!--项目构建用的东西--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">finalName</span>&gt;</span>JavaWeb-maven-01<span class="hljs-tag">&lt;/<span class="hljs-name">finalName</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">pluginManagement</span>&gt;</span><span class="hljs-comment">&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-clean-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-resources-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.8.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.22.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-war-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-install-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-deploy-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.8.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">pluginManagement</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><p>maven由于约定大于配置，之后可能会遇到配置文件无法被导出或者生效的问题，解决方案：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--在build中配置resources，来放置资源导出失败的问题--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">excludes</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">exclude</span>&gt;</span>**/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">exclude</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">exclude</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">exclude</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">excludes</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/java<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><p>Dependencies的整体架构：</p><p><img src="/2023/01/10/Java_Web/Java_Web%5Cimage-20200911093822077.png" alt="image-20200911093822077"></p><h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><ol><li><p>Maven默认web项目的web.xml版本问题，如果不兼容，则</p><p><img src="/2023/01/10/Java_Web/Java_Web%5Cimage-20200911095414224.png" alt="image-20200911095414224"></p><p>替换为Tomcat\webapps\ROOT下的web.xml</p></li><li><p>Maven仓库的使用</p><p>访问 </p><p><a href="https://mvnrepository.com/">https://mvnrepository.com/</a></p></li></ol><h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><ul><li>Servlet是sun公司开发动态web的一门技术</li><li>Sun公司在API中提供接口：Servlet，如果需要开发Servlet程序，只需要完成两个小步骤：<ul><li>编写类，实现Servlet接口</li><li>把开发好的Java类部署到web服务器中</li></ul></li></ul><p><strong>把实现了Servlet接口的Java程序叫做Servlet</strong></p><h3 id="HelloServlet"><a href="#HelloServlet" class="headerlink" title="HelloServlet"></a>HelloServlet</h3><p>Servlet接口在Sun公司有两个默认的实现类：HTTPServlet，</p><ol><li><p>构建一个普通的Maven项目，删掉里面的src，以后在这里建立Module.这个空的工程 就是Maven主工程。</p></li><li><p>关于maven父子工程的理解：</p><p>在父项目会有</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>servlet-01<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span><br></code></pre></td></tr></table></figure><p>父项目中的java，子项目可以直接使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">son <span class="hljs-keyword">extends</span> <span class="hljs-title class_">father</span><br></code></pre></td></tr></table></figure></li><li><p>Maven 环境优化</p><ol><li>修改web.xml为最新</li><li>将maven结构搭建完成</li></ol></li><li><p>编写Servlet程序</p><ol><li><p>编写一个普通类</p></li><li><p>实现Servlet接口，这里直接继承HTTPServlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-comment">//由于get或者POST只是请求实现的不同方式，可以相互调用，因为业务逻辑都一样</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> resp.getWriter();  <span class="hljs-comment">//响应流</span><br>        writer.print(<span class="hljs-string">&quot;Hello Servlet&quot;</span>);<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        doGet(req, resp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li><li><p>编写Servlet的映射</p><p>为什么需要映射：我们写的是java程序，但是需要通过浏览器访问，而浏览器需要连接web服务器，所以我们需要web服务中注册我们写的Servlet，还需要给他一个浏览器能够访问的路径。</p></li><li><p>配置Tomcat</p><p>注意：配置项目发布的路径</p></li><li><p>启动测试</p></li></ol><h3 id="Servlet原理"><a href="#Servlet原理" class="headerlink" title="Servlet原理"></a>Servlet原理</h3><p>Servlet是由Web服务器调用，Web服务器在收到浏览器请求之后，会：</p><p><img src="/2023/01/10/Java_Web/Java_Web%5Cimage-20200911194338468.png" alt="image-20200911194338468"></p><h3 id="Mapping问题"><a href="#Mapping问题" class="headerlink" title="Mapping问题"></a>Mapping问题</h3><ol><li><p>一个Servlet可以指定一个映射路径</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/hello<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>一个Servlet能指定多个映射路径</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/hello<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/hello1<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/hello2<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>一个Servlet能指定通用映射路径</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml">  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/hello/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><span class="hljs-comment">&lt;!--默认请求路径，优先级高--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>一个Servlet能自定义后缀实现请求映射</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--可以自定义后缀实现请求映射,*前面不能加任何映射的路径--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>*.do<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>优先级问题</p><p>指定了固有的映射路径优先级最高，如果找不到就走默认的处理请求。</p></li></ol><h2 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h2><p>web容器在启动的时候，它会为每个web程序都创建一个对应的ServletContext对象，它代表了当前的web应用；</p><p><img src="/2023/01/10/Java_Web/Java_Web%5Cimage-20200911204228611.png" alt="image-20200911204228611"></p><h3 id="共享数据"><a href="#共享数据" class="headerlink" title="共享数据"></a>共享数据</h3><p>我在这个Servlet中保存的数据，可以在另一个Servlet中拿到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>    System.out.println(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    <span class="hljs-comment">//this.getInitParameter();   //得到初始化参数</span><br>    <span class="hljs-comment">//this.getServletConfig();   //Servlet配置</span><br>    <span class="hljs-comment">//this.getServletContext();  //Servlet上下文</span><br>    <span class="hljs-type">ServletContext</span> <span class="hljs-variable">servletContext</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getServletContext();<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;德丽莎&quot;</span>;  <span class="hljs-comment">//data</span><br>    servletContext.setAttribute(<span class="hljs-string">&quot;username&quot;</span>, username);  <span class="hljs-comment">//将一个数据保存在servletContext中，名字为username,值username</span><br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>    resp.setContentType(<span class="hljs-string">&quot;text/html&quot;</span>);<br>    resp.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);<br><br>    <span class="hljs-type">ServletContext</span> <span class="hljs-variable">servletContext</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getServletContext();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> (String) servletContext.getAttribute(<span class="hljs-string">&quot;username&quot;</span>);<br>    resp.getWriter().print(username);<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.kuang.servlet.HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/hello<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>getc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.kuang.servlet.GetServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>getc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/getc<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><p>测试访问结果；</p><h3 id="获取初始化参数"><a href="#获取初始化参数" class="headerlink" title="获取初始化参数"></a>获取初始化参数</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>url<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>jdbc:mysql://localhost:3306/mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>    <span class="hljs-type">ServletContext</span> <span class="hljs-variable">servletContext</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getServletContext();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> servletContext.getInitParameter(<span class="hljs-string">&quot;url&quot;</span>);<br>    resp.getWriter().print(url);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a>请求转发</h3><p><img src="/2023/01/10/Java_Web/image-20200911213004349.png" alt="image-20200911213004349"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>    <span class="hljs-type">ServletContext</span> <span class="hljs-variable">servletContext</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getServletContext();<br>    servletContext.getRequestDispatcher(<span class="hljs-string">&quot;/gp&quot;</span>).forward(req, resp);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="读取资源文件"><a href="#读取资源文件" class="headerlink" title="读取资源文件"></a>读取资源文件</h3><p>Properties</p><ul><li><p>在java目录下新建properties</p></li><li><p>在resource目录下新建properties</p></li></ul><p>发现：都被打包到了同一路径下：class， 称这个路径为classpath;</p><p>思路：需要一个文件流作为桥梁；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>    <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getServletContext().getResourceAsStream(<span class="hljs-string">&quot;/WEB-INF/classes/db.properties&quot;</span>);<br>    <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>    properties.load(is);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> properties.getProperty(<span class="hljs-string">&quot;username&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> properties.getProperty(<span class="hljs-string">&quot;password&quot;</span>);<br>    resp.getWriter().print(username + <span class="hljs-string">&quot;:&quot;</span> + password);<br>&#125;<br></code></pre></td></tr></table></figure><p>访问测试接口</p><h2 id="HttpServletRequest"><a href="#HttpServletRequest" class="headerlink" title="HttpServletRequest"></a>HttpServletRequest</h2><p>HttpServletRequest代表客户端的请求，用户通过Http访问服务器，Http请求中的所有信息会被封装到HTTPServletRequest。通过这个HttpServletRequest的方法，获取客户端的所有信息。</p><h3 id="获取前端传递的参数，请求转发"><a href="#获取前端传递的参数，请求转发" class="headerlink" title="获取前端传递的参数，请求转发"></a>获取前端传递的参数，请求转发</h3><p>前端通过form传递相应的键值对，通过提交方式被后端的request对象接收，后端可以通过获得参数（键）来获取相应的值，一般使用post请求，这样不会在URL中直接显示信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//初始化编码</span><br>req.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);<br>resp.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);<br><br><span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> req.getParameter(<span class="hljs-string">&quot;username&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> req.getParameter(<span class="hljs-string">&quot;password&quot;</span>);<br>String[] hobbies = req.getParameterValues(<span class="hljs-string">&quot;hobbies&quot;</span>);<br><br>System.out.println(username + <span class="hljs-string">&quot;:&quot;</span> + password);<br>System.out.println(Arrays.toString(hobbies));   <span class="hljs-comment">//Arrays处理数组的类，这里返回数组的字符串形式</span><br><br><span class="hljs-comment">//通过请求转发</span><br><span class="hljs-comment">//这里的/代表当前的web应用</span><br>req.getRequestDispatcher(<span class="hljs-string">&quot;/success.jsp&quot;</span>).forward(req, resp);<br><span class="hljs-comment">//resp.sendRedirect(req.getContextPath() + &quot;/success.jsp&quot;);</span><br></code></pre></td></tr></table></figure><h2 id="HttpServletResponse"><a href="#HttpServletResponse" class="headerlink" title="HttpServletResponse"></a>HttpServletResponse</h2><p>web服务器接收到客户端的http请求，会针对这个请求，分别创建一个代表请求的HTTPServletRequest对象，代表响应的一个HttpServletResponse对象；</p><ul><li>如果要获取客户端请求过来的参数：找HTTPServletRequest</li><li>如果要给客户响应一些信息：找HttpServletResponse</li></ul><h3 id="简单分类"><a href="#简单分类" class="headerlink" title="简单分类"></a>简单分类</h3><p><strong>负责向浏览器发送数据的方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">ServletOutputStream <span class="hljs-title function_">getOutputStream</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException;<br>PrintWriter <span class="hljs-title function_">getWriter</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException;               <span class="hljs-comment">//可能造成字符串损坏或者丢失</span><br></code></pre></td></tr></table></figure><p><strong>负责向浏览器发送响应头的方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">setCharacterEncoding</span><span class="hljs-params">(String var1)</span>;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">setContentLength</span><span class="hljs-params">(<span class="hljs-type">int</span> var1)</span>;<br><br>...<br></code></pre></td></tr></table></figure><p><strong>响应状态码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">SC_OK</span> <span class="hljs-operator">=</span> <span class="hljs-number">200</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">SC_NOT_FOUND</span> <span class="hljs-operator">=</span> <span class="hljs-number">404</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">SC_INTERNAL_SERVER_ERROR</span> <span class="hljs-operator">=</span> <span class="hljs-number">500</span>;<br></code></pre></td></tr></table></figure><h3 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h3><ol><li><p>向浏览器输出消息（getWriter，getOutputStream）</p></li><li><p>下载文件</p><ol><li>要获取下载文件的路径</li><li>下载的文件名</li><li>设置，让浏览器能够支持下载我们需要的东西</li><li>获取下载文件的输入流</li><li>创建缓冲区</li><li>获取OutputStream对象</li><li>将FileOutputStream写入到buffer缓冲区</li><li>使用OutputStream将缓冲区中的数据输出到客户端</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">realPath</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.<br>        getServletContext().<br>        getRealPath(<span class="hljs-string">&quot;/WEB-INF/classes/sakura.jpg&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;download file&#x27;s path:&quot;</span> + realPath);<br><br><span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> realPath.substring(realPath.lastIndexOf(<span class="hljs-string">&quot;\\&quot;</span>) + <span class="hljs-number">1</span>);<br>System.out.println(<span class="hljs-string">&quot;download file&#x27;s name:&quot;</span> + fileName);<br><br><span class="hljs-comment">//set file header, use URLEncoder to change encode</span><br>resp.setHeader(<span class="hljs-string">&quot;Content-Disposition&quot;</span>, <span class="hljs-string">&quot;attachment; filename=&quot;</span>+ URLEncoder.encode(fileName,<span class="hljs-string">&quot;UTF-8&quot;</span>));<br><br><span class="hljs-comment">//input file to buffer and to outputStream</span><br><span class="hljs-type">FileInputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(realPath);<br><span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br><span class="hljs-type">ServletOutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> resp.getOutputStream();<br><span class="hljs-keyword">while</span>((len = in.read(buffer)) &gt; <span class="hljs-number">0</span>)&#123;<br>    out.write(buffer, <span class="hljs-number">0</span>, len);<br>&#125;<br><br>in.close();<br>out.close();<br></code></pre></td></tr></table></figure><h3 id="验证码功能"><a href="#验证码功能" class="headerlink" title="验证码功能"></a>验证码功能</h3><p>验证码来源</p><ul><li>前端实现</li><li>后端实现，需要用到Java图片类，产生一个图片</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>    <span class="hljs-comment">//如何让浏览器5s自动刷新一次</span><br>    resp.setHeader(<span class="hljs-string">&quot;refresh&quot;</span>, <span class="hljs-string">&quot;5&quot;</span>);<br>    <span class="hljs-comment">//在内存中生成图片</span><br>    <span class="hljs-type">BufferedImage</span> <span class="hljs-variable">bufferedImage</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedImage</span>(<span class="hljs-number">80</span>, <span class="hljs-number">20</span>, BufferedImage.TYPE_INT_RGB);<br>    <span class="hljs-comment">//得到图片</span><br>    <span class="hljs-type">Graphics2D</span> <span class="hljs-variable">graphics</span> <span class="hljs-operator">=</span> (Graphics2D) bufferedImage.getGraphics();<br>    <span class="hljs-comment">//设置图片的背景颜色</span><br>    graphics.setColor(Color.white);<br>    graphics.fillRect(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">80</span>,<span class="hljs-number">20</span>);<br>    <span class="hljs-comment">//给图片写数据</span><br>    graphics.setColor(Color.blue);<br>    graphics.setFont(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Font</span>(<span class="hljs-literal">null</span>, Font.BOLD,<span class="hljs-number">20</span>));<br>    graphics.drawString(makeNum(), <span class="hljs-number">0</span>, <span class="hljs-number">20</span>);<br>    <span class="hljs-comment">//告诉浏览器，这个请求用图片的方式打开</span><br>    resp.setContentType(<span class="hljs-string">&quot;image/jpg&quot;</span>);<br>    <span class="hljs-comment">//网站存在缓存，不让浏览器缓存</span><br>    resp.setDateHeader(<span class="hljs-string">&quot;expires&quot;</span>, -<span class="hljs-number">1</span>);<br>    resp.setHeader(<span class="hljs-string">&quot;Cache-Control&quot;</span>, <span class="hljs-string">&quot;no-cache&quot;</span>);<br>    resp.setHeader(<span class="hljs-string">&quot;Pragma&quot;</span>, <span class="hljs-string">&quot;no-cache&quot;</span>);<br>    <span class="hljs-comment">//把图片写给浏览器</span><br>    ImageIO.write(bufferedImage, <span class="hljs-string">&quot;jpg&quot;</span>, resp.getOutputStream());<br>&#125;<br><br><span class="hljs-comment">//生成随机数</span><br><span class="hljs-keyword">private</span> String <span class="hljs-title function_">makeNum</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">randomString</span> <span class="hljs-operator">=</span> random.nextInt(<span class="hljs-number">99999999</span>) + <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>    <span class="hljs-comment">//用0填充不够的位数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">7</span> - randomString.length(); i++)&#123;<br>        buffer.append(<span class="hljs-string">&quot;0&quot;</span>);<br>    &#125;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> buffer.toString() + randomString;<br>    <span class="hljs-keyword">return</span> num;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实现重定向"><a href="#实现重定向" class="headerlink" title="实现重定向"></a>实现重定向</h3><p>一个web资源收到客户端请求后，它会通知客户端去访问另外一个web资源，这个过程叫重定向。</p><p>常见场景：</p><ul><li>用户登录</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">sendRedirect</span><span class="hljs-params">(String var1)</span> <span class="hljs-keyword">throws</span> IOException;<br></code></pre></td></tr></table></figure><p>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//原理</span><br><span class="hljs-comment">//resp.setHeader(&quot;Location&quot;, &quot;/rsp/image&quot;);</span><br><span class="hljs-comment">//resp.setStatus(HttpServletResponse.SC_MOVED_TEMPORARILY);</span><br>resp.sendRedirect(<span class="hljs-string">&quot;/rsp/image&quot;</span>);   <span class="hljs-comment">//重定向</span><br></code></pre></td></tr></table></figure><p><strong>Q: 重定向和转发的区别？</strong></p><p>相同点：</p><ul><li>页面都会实现跳转</li></ul><p>不同点：</p><ul><li>请求转发的时候URL不会产生变化，一般是从转发地那东西到自己这里来 状态码：307</li><li>重定向的时候，URL会定向到新的位置 状态码：302</li></ul><br><h2 id="Cookie、Session"><a href="#Cookie、Session" class="headerlink" title="Cookie、Session"></a>Cookie、Session</h2><h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><p><strong>会话</strong>：用户打开一个浏览器，点击了很多超链接，访问多个web资源，关闭浏览器，这个过程可以称之为会话。</p><p><strong>有状态会话</strong>：服务端记录了访问过的客户端的信息。</p><p><strong>一个网站，怎么证明你来过？</strong></p><p>客户端        服务端</p><ol><li>服务端给客户端一个信件，客户端下次访问服务端，带上信件就行；cookie</li><li>服务器登记来过，下次来的时候我来匹配你； session</li></ol><h3 id="保存会话的两种技术"><a href="#保存会话的两种技术" class="headerlink" title="保存会话的两种技术"></a>保存会话的两种技术</h3><p><strong>cookie</strong></p><ul><li>客户端技术（响应，请求）</li></ul><p><strong>session</strong></p><ul><li>服务器技术（行为），利用这个技术，可以保存用户的会话信息。我们可以把信息或者数据放在session中。</li></ul><p>常见场景：网站登录之后，下次不用再登录，第二次访问直接上去。</p><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><ol><li>从请求中拿到cookie信息</li><li>服务器响应给客户端cookie</li><li>Cookie是具有Domain（域）的</li></ol><p><img src="/2023/01/10/Java_Web/image-20200913160139940.png" alt="image-20200913160139940"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Cookie[] cookies = req.getCookies();  <span class="hljs-comment">//获得cookie</span><br>cookie.getName(); <span class="hljs-comment">//获得cookie中的key</span><br>cookie.getValue(); <span class="hljs-comment">//获得cookie中的value</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>();  <span class="hljs-comment">//新建一个cookie</span><br>cookie.setMaxAge(); <span class="hljs-comment">//设置cookie的有效期</span><br>resp.addCookie(); <span class="hljs-comment">//响应给客户端一个cookie</span><br></code></pre></td></tr></table></figure><p>cookie: 一般会保存在本地的用户目录下appdata；</p><br><p>一个网站cookie是否存在上限？</p><ul><li>一个cookie只能保存一个信息；</li><li>一个web站点可以给浏览器发送多个cookie，上限大概为300个，每个站点最多存放20个</li><li>Cookie大小有限制，最多为4kb</li></ul><p>删除Cookie：</p><ul><li>不设置有效期，关闭浏览器自动失效；</li><li>设置有效期为0；</li></ul><p>在传输中文字符时，转码: URLEncoder.encode(“中文”, “编码类型”)，解码：URLEncoder.decode(“ “,” “)</p><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>什么是session？</p><ul><li>服务器会给<strong>每一个用户（浏览器）</strong>创建一个session对象；</li><li>一个session独占一个浏览器，只要浏览器没有关闭，这个session就存在；</li><li>用户登录之后，整个网站它都可以访问-&gt;保存用户的信息，保存购物车的信息… …；</li></ul><p>Session和Cookie的区别：</p><ul><li>Cookie是把用户的数据写给用户的浏览器，是浏览器保存（可以保存多个）,且直接保存内容</li><li>Session把用户的数据写到用户独占的session中，是服务器端保存（保存重要信息，减少服务资源的浪费），客户端只保存ID</li><li>Session对象由服务器创建</li></ul><p>使用场景：</p><ul><li>保存一个登录用户的信息</li><li>保存购物车信息</li><li>在整个网站中，<strong>经常</strong>会使用的数据，我们将它保存在session中</li></ul><p>使用Session：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java">req.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);<br>resp.setCharacterEncoding(<span class="hljs-string">&quot;GBK&quot;</span>);<br>resp.setContentType(<span class="hljs-string">&quot;text/html&quot;</span>);<br><br><span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> req.getSession();<br><br>session.setAttribute(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;德丽莎&quot;</span>, <span class="hljs-number">500</span>));<br><br><span class="hljs-comment">//获取sessionID</span><br><span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> session.getId();<br><br><span class="hljs-comment">//判断是不是新的session</span><br><span class="hljs-keyword">if</span>(session.isNew())&#123;<br>    resp.getWriter().write(<span class="hljs-string">&quot;session创建成功, ID:&quot;</span> + id);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    resp.getWriter().write(<span class="hljs-string">&quot;session已经在服务器中存在，ID:&quot;</span> + id);<br>&#125;<br><br><span class="hljs-comment">//Session创建的时候，会把sessionID放到cookie中</span><br><span class="hljs-comment">//Cookie cookie = new Cookie(&quot;JSESSIONID&quot;,id);</span><br><span class="hljs-comment">//resp.addCookie(cookie);</span><br><br><span class="hljs-type">HttpSession</span> <span class="hljs-variable">reqSession</span> <span class="hljs-operator">=</span> req.getSession();<br><span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> (Person) reqSession.getAttribute(<span class="hljs-string">&quot;name&quot;</span>);<br><br>System.out.println(person);<br><br><span class="hljs-comment">//reqSession.removeAttribute(&quot;name&quot;);</span><br><span class="hljs-comment">//reqSession.invalidate();    //手动注销session</span><br></code></pre></td></tr></table></figure><p>会话自动过期：web.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--    设置session默认的失效时间--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">session-config</span>&gt;</span><br><span class="hljs-comment">&lt;!--        n分钟后session自动失效--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">session-timeout</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">session-timeout</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">session-config</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/2023/01/10/Java_Web/image-20200913101905117.png" alt="image-20200913101905117"></p><h2 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h2><h3 id="什么是JSP？"><a href="#什么是JSP？" class="headerlink" title="什么是JSP？"></a>什么是JSP？</h3><p>Java Server Pages：Java服务器端页面，也和Servlet一样用于开发动态web技术</p><p>最大的特点：</p><ul><li>写JSP就像在写HTML</li><li>与HTML区别：<ul><li>HTML只会给用户提供静态数据</li><li>JSP页面中可以嵌入Java代码，为用户提供动态数据</li></ul></li></ul><h3 id="JSP原理"><a href="#JSP原理" class="headerlink" title="JSP原理"></a>JSP原理</h3><p>思路：JSP到底怎么执行</p><ul><li><p>代码层面没有变化</p></li><li><p>服务器内部工作</p><p>Tomcat中有一个work目录，</p><p>在IDEA中使用Tomcat，会在IDEA的Tomcat中产生一个work目录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">C:\Users\树文\AppData\Local\JetBrains\IntelliJIdea2020<span class="hljs-number">.2</span>\tomcat\Unnamed_javaweb-session-cookie\work\Catalina\localhost\ROOT\org\apache\jsp\index_jsp.java<br></code></pre></td></tr></table></figure><p>发现页面转变成Java程序！</p></li></ul><p><strong>浏览器向服务器发送请求，不管访问什么资源，其实都是在访问Servlet</strong></p><p>JSP最终也会被转换成Java类，并且是继承自Servlet的</p><p><img src="/2023/01/10/Java_Web/image-20200913104152022.png" alt="image-20200913104152022"></p><p><strong>JSP本质上就是Servlet！</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//初始化  </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">_jspInit</span><span class="hljs-params">()</span> &#123;<br>  &#125;<br><span class="hljs-comment">//销毁</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">_jspDestroy</span><span class="hljs-params">()</span> &#123;<br>  &#125;<br><span class="hljs-comment">//JSP Service</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">_jspService</span><span class="hljs-params">(<span class="hljs-keyword">final</span> javax.servlet.http.HttpServletRequest request, <span class="hljs-keyword">final</span> javax.servlet.http.HttpServletResponse response)</span><br>      <span class="hljs-keyword">throws</span> java.io.IOException, javax.servlet.ServletException &#123;<br></code></pre></td></tr></table></figure><ol><li><p>判断请求</p></li><li><p>内置了一些对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-keyword">final</span> javax.servlet.jsp.PageContext pageContext;   <span class="hljs-comment">//页面上下文</span><br>   javax.servlet.http.<span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;     <span class="hljs-comment">//session</span><br>   <span class="hljs-keyword">final</span> javax.servlet.ServletContext application;    <span class="hljs-comment">//applicationContext</span><br>   <span class="hljs-keyword">final</span> javax.servlet.ServletConfig config;          <span class="hljs-comment">//配置</span><br>   javax.servlet.jsp.<span class="hljs-type">JspWriter</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;            <span class="hljs-comment">//输出流</span><br>   <span class="hljs-keyword">final</span> java.lang.<span class="hljs-type">Object</span> <span class="hljs-variable">page</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;                <span class="hljs-comment">//当且页面</span><br>   javax.servlet.jsp.<span class="hljs-type">JspWriter</span> <span class="hljs-variable">_jspx_out</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>   javax.servlet.jsp.<span class="hljs-type">PageContext</span> <span class="hljs-variable">_jspx_page_context</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>   <br>HttpServletRequest request                         <span class="hljs-comment">//请求</span><br>   HttpServletResponse response                       <span class="hljs-comment">//响应</span><br></code></pre></td></tr></table></figure></li><li><p>输出页面前增加的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">response.setContentType(<span class="hljs-string">&quot;text/html&quot;</span>);                               <span class="hljs-comment">//设置响应类型（转换成HTML）</span><br>pageContext = _jspxFactory.getPageContext(<span class="hljs-built_in">this</span>, request, response,<br><span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>, <span class="hljs-number">8192</span>, <span class="hljs-literal">true</span>);<br>_jspx_page_context = pageContext;<br>application = pageContext.getServletContext();<br>config = pageContext.getServletConfig();<br>session = pageContext.getSession();<br>out = pageContext.getOut();<br>_jspx_out = out;<br></code></pre></td></tr></table></figure></li><li><p>以上这些对象可以在JSP页面中直接使用！</p><p><img src="/2023/01/10/Java_Web/image-20200913105855211.png" alt="image-20200913105855211"></p></li></ol><p>在JSP页面中，只要是java代码，就会原封不动地输出；</p><p>如果是HTML代码，就会被转换为out.write(“”) 输出到前端；</p><h3 id="JSP基础语法"><a href="#JSP基础语法" class="headerlink" title="JSP基础语法"></a>JSP基础语法</h3><p>JSP有一些自己扩充的语法，Java所有语法都支持！</p><p><strong>JSP表达式：</strong></p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%--JSP表达式<br>作用：用来将程序的输出到客户端<br>&lt;%= 变量或者表达式%&gt;<br>--%&gt;<br>&lt;%=<span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.util.Date()%&gt;<br></code></pre></td></tr></table></figure><p><strong>jsp脚本片段：</strong></p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%--JSP脚本片段--%&gt;<br>&lt;%<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i++)&#123;<br>        sum += i;<br>    &#125;<br>    out.println(<span class="hljs-string">&quot;&lt;h1&gt;Sum=&quot;</span> + sum + <span class="hljs-string">&quot;&lt;/h1&gt;&quot;</span>);<br>%&gt;<br></code></pre></td></tr></table></figure><p><strong>脚本片段的再实现：</strong></p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%--在代码中嵌入HTML元素--%&gt;<br>&lt;%<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>;i++)&#123;<br>%&gt;<br>&lt;h1&gt;Hello World &lt;%=i%&gt; &lt;/h1&gt;<br>&lt;%<br>    &#125;<br>%&gt;<br></code></pre></td></tr></table></figure><p><strong>JSP声明：</strong></p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%!<br><span class="hljs-comment">//static静态块</span><br><span class="hljs-comment">//（1） static关键字还有一个比较关键的作用，用来形成静态代码块（static&#123;&#125;(即static块)）以优化程序性能。</span><br><span class="hljs-comment">//（2） static块可以置于类中的任何地方，类中可以有多个static块。</span><br><span class="hljs-comment">//（3） 在类初次被加载的时候执行且仅会被执行一次（这是优化性能的原因！！！），会按照static块的顺序来执行每个static块，一般用来初始化静态变量和调用静态方法。</span><br>    <span class="hljs-keyword">static</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Loading Servlet!&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">globalVar</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">function</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;enter function!&quot;</span>);<br>    &#125;<br>%&gt;<br></code></pre></td></tr></table></figure><p>区别：</p><p>jsp声明会被编译到JSP生成的java_jsp的类中，其他的就会被生成到_Service方法中。</p><p>在JSP中，嵌入java代码即可！</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%%&gt;   <span class="hljs-comment">//片段</span><br>&lt;%=%&gt;  <span class="hljs-comment">//表达式输出</span><br>&lt;%!%&gt;  <span class="hljs-comment">//全局元素</span><br>&lt;%--注释--%&gt; <br></code></pre></td></tr></table></figure><p>JSP的注释不会被渲染到客户端，但HTML会</p><h3 id="JSP指令"><a href="#JSP指令" class="headerlink" title="JSP指令"></a>JSP指令</h3><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br><br>&lt;%--定制错误页面--%&gt;<br>&lt;%@ page errorPage=<span class="hljs-string">&quot;error/500.jsp&quot;</span> %&gt;<br>&lt;%--显式声明这是一个错误页面--%&gt;<br>&lt;%@ page isErrorPage=<span class="hljs-string">&quot;true&quot;</span> %&gt;<br><br>&lt;%--导入jar包--%&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;java.util.*&quot;</span> %&gt;<br><br><br></code></pre></td></tr></table></figure><p>错误页面的两种方式：</p><ol><li><p>直接在jsp中定制错误页面</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%--定制错误页面--%&gt;<br>&lt;%--&lt;%@ page errorPage=<span class="hljs-string">&quot;error/500.jsp&quot;</span> %&gt;--%&gt;<br></code></pre></td></tr></table></figure></li><li><p>在web.xml中配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">error-page</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">error-code</span>&gt;</span>404<span class="hljs-tag">&lt;/<span class="hljs-name">error-code</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">location</span>&gt;</span>/error/404.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">location</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">error-page</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">error-page</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">error-code</span>&gt;</span>500<span class="hljs-tag">&lt;/<span class="hljs-name">error-code</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">location</span>&gt;</span>/error/500.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">location</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><p>页面内嵌的方式（比如设置网页有相同的头部，尾部）：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%--会将两个页面合二为一，有点像宏扩展--%&gt;<br>&lt;%<span class="hljs-meta">@include</span> file=<span class="hljs-string">&quot;common/header.jsp&quot;</span>%&gt;<br>&lt;h1&gt;网页主体&lt;/h1&gt;<br>&lt;%<span class="hljs-meta">@include</span> file=<span class="hljs-string">&quot;common/footer.jsp&quot;</span>%&gt;<br><br>&lt;hr&gt;<br>&lt;%--JSP标签（更常用）--%&gt;<br>&lt;%--拼接页面，本质还是<span class="hljs-number">3</span>个--%&gt;<br>&lt;jsp:include page=<span class="hljs-string">&quot;/common/header.jsp&quot;</span>&gt;&lt;/jsp:include&gt;<br>&lt;h1&gt;网页主体&lt;/h1&gt;<br>&lt;jsp:include page=<span class="hljs-string">&quot;/common/footer.jsp&quot;</span>&gt;&lt;/jsp:include&gt;<br></code></pre></td></tr></table></figure><h3 id="9大内置对象"><a href="#9大内置对象" class="headerlink" title="9大内置对象"></a>9大内置对象</h3><ul><li>PageContext  保存</li><li>Request  保存</li><li>Response</li><li>Session  用来保存</li><li>Application（ServletContext） 用来保存</li><li>config（ServletConfig）</li><li>out</li><li>page 几乎不用</li><li>exception</li></ul><p><img src="/2023/01/10/Java_Web/image-20200913154655427.png" alt="image-20200913154655427"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//从底层到高层（作用域）: page-&gt;request-&gt;session-&gt;application</span><br><span class="hljs-comment">//类似JVM:双亲委派机制：类加载器会优先加载上层的包，如果能够找到就直接使用，这样可以防止一些危险重名代码被加载</span><br>pageContext.setAttribute(<span class="hljs-string">&quot;name1&quot;</span>,<span class="hljs-string">&quot;Alice1&quot;</span>);   <span class="hljs-comment">//保存的数据只在一个页面中有效</span><br>request.setAttribute(<span class="hljs-string">&quot;name2&quot;</span>,<span class="hljs-string">&quot;Alice2&quot;</span>);       <span class="hljs-comment">//只在一次请求中有效，请求转发会携带这个数据</span><br>session.setAttribute(<span class="hljs-string">&quot;name3&quot;</span>,<span class="hljs-string">&quot;Alice3&quot;</span>);       <span class="hljs-comment">//在一次会话中有效，从打开到关闭浏览器</span><br>application.setAttribute(<span class="hljs-string">&quot;name4&quot;</span>,<span class="hljs-string">&quot;Alice4&quot;</span>);   <span class="hljs-comment">//在服务器中有效，从打开到关闭服务器</span><br></code></pre></td></tr></table></figure><p>在获取各值时，根据存储方式和生命周期的不同，会产生不同的结果</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%--脚本片段中的代码会被原封不动地生成到*_jsp.java中--%&gt;<br>&lt;%--要求：这里面的代码必须保证Java语法的正确性--%&gt;<br>&lt;%<br>    <span class="hljs-comment">//从pageContext取出, 我们通过寻找的方式来</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">name1</span> <span class="hljs-operator">=</span> (String)pageContext.findAttribute(<span class="hljs-string">&quot;name1&quot;</span>);  <span class="hljs-comment">//pageContext</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">name2</span> <span class="hljs-operator">=</span> (String)pageContext.findAttribute(<span class="hljs-string">&quot;name2&quot;</span>);  <span class="hljs-comment">//request</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">name3</span> <span class="hljs-operator">=</span> (String)pageContext.findAttribute(<span class="hljs-string">&quot;name3&quot;</span>);  <span class="hljs-comment">//session</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">name4</span> <span class="hljs-operator">=</span> (String)pageContext.findAttribute(<span class="hljs-string">&quot;name4&quot;</span>);  <span class="hljs-comment">//application</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">name5</span> <span class="hljs-operator">=</span> (String)pageContext.findAttribute(<span class="hljs-string">&quot;name5&quot;</span>);<br>%&gt;<br>&lt;%--使用EL表达式输出 $&#123;&#125;--%&gt;<br>&lt;h1&gt;取出的值为：&lt;/h1&gt;<br>&lt;h3&gt;$&#123;name1&#125; 取不出&lt;/h3&gt;<br>&lt;h3&gt;$&#123;name2&#125; 取不出&lt;/h3&gt;<br>&lt;h3&gt;$&#123;name3&#125; 可以取出&lt;/h3&gt;<br>&lt;h3&gt;$&#123;name4&#125; 可以取出&lt;/h3&gt;<br>&lt;%--EL表达式好处：即使值为<span class="hljs-literal">null</span>，也能自动识别而不会输出--%&gt;<br>&lt;h3&gt;$&#123;name5&#125; 空&lt;/h3&gt;<br></code></pre></td></tr></table></figure><p>应用场景：</p><ul><li>request：客户端向服务器发送请求产生的数据用户看完就没用了，比如：新闻（不用存起来）；</li><li>session：产生数据用户用完一会儿还有用，比如：购物车；</li><li>application：产生的数据一个用户用完了，其他用户还可能使用，比如：聊天数据，统计访问人数；</li></ul><h3 id="JSP标签、JSTL标签、EL表达式"><a href="#JSP标签、JSTL标签、EL表达式" class="headerlink" title="JSP标签、JSTL标签、EL表达式"></a>JSP标签、JSTL标签、EL表达式</h3><p>导入到web.xml中的包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--    JSP依赖--&gt;</span><br>    <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/javax.servlet.jsp/javax.servlet.jsp-api --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet.jsp-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--    JSTL表达式依赖--&gt;</span><br>    <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/javax.servlet.jsp.jstl/jstl-api --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet.jsp.jstl<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jstl-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--    standard标签库--&gt;</span><br>    <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/taglibs/standard --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>taglibs<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>standard<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>EL表达式：</p><ul><li>获取数据</li><li>执行运算</li><li>获取web开发的常用对象</li><li><del>调用java方法</del>(不常用)</li></ul><p>JSP标签</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;jsp:include page=<span class="hljs-string">&quot;jsptag2.jsp&quot;</span>&gt;&lt;/jsp:include&gt;<br><br>&lt;jsp:forward page=<span class="hljs-string">&quot;/jsptag2.jsp&quot;</span>&gt;<br>    &lt;jsp:param name=<span class="hljs-string">&quot;value1&quot;</span> value=<span class="hljs-string">&quot;value1&quot;</span>/&gt;<br>    &lt;jsp:param name=<span class="hljs-string">&quot;value2&quot;</span> value=<span class="hljs-string">&quot;value2&quot;</span>/&gt;<br>&lt;/jsp:forward&gt;<br></code></pre></td></tr></table></figure><p>JSTL表达式</p><p><strong>JSTL标签库的使用就是为了弥补HTML标签的不足；</strong>它自定义了许多标签，可以供我们使用，标签和功能和java代码一样。</p><p>格式化标签</p><p>SQL标签</p><p>XML标签</p><p><strong>核心标签</strong>（掌握部分）</p><p><img src="/2023/01/10/Java_Web/image-20200913170908703.png" alt="image-20200913170908703"></p><p>JSTL标签使用：</p><ul><li><p>引入对应的taglib</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%--引入JSTL核心标签库，才能使用JSTL标签 core--%&gt;<br>&lt;%@ taglib prefix=<span class="hljs-string">&quot;c&quot;</span> uri=<span class="hljs-string">&quot;http://java.sun.com/jsp/jstl/core&quot;</span> %&gt;<br></code></pre></td></tr></table></figure></li><li><p>使用其中的方法</p></li><li><p>在Tomcat也需要引入jstl包，否则会报错：JSTL解析错误</p></li></ul><p><strong>c:if 标签：</strong></p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;h4&gt;<span class="hljs-keyword">if</span>测试&lt;/h4&gt;<br>&lt;form action=<span class="hljs-string">&quot;coreif.jsp&quot;</span> method=<span class="hljs-string">&quot;get&quot;</span>&gt;<br>&lt;%--    EL表达式获取表单中的数据 $&#123;param.参数名&#125;--%&gt;<br>    &lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;username&quot;</span> value=<span class="hljs-string">&quot;$&#123;param.username&#125;&quot;</span>&gt;<br>    &lt;input type=<span class="hljs-string">&quot;submit&quot;</span> value=<span class="hljs-string">&quot;登录&quot;</span>&gt;<br>&lt;/form&gt;<br><br>&lt;c:<span class="hljs-keyword">if</span> test=<span class="hljs-string">&quot;$&#123;param.username==&#x27;admin&#x27;&#125;&quot;</span> <span class="hljs-keyword">var</span>=<span class="hljs-string">&quot;isAdmin&quot;</span>&gt;<br>    &lt;c:out value=<span class="hljs-string">&quot;管理员欢迎您&quot;</span>/&gt;<br>&lt;/c:<span class="hljs-keyword">if</span>&gt;<br>&lt;c:out value=<span class="hljs-string">&quot;$&#123;isAdmin&#125;&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>其他标签见 <a href="https://www.runoob.com/">https://www.runoob.com/</a></p><p>总结：还是写java更舒服</p><h2 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h2><p>实体类</p><p>JavaBean有特定的写法：</p><ul><li>必须要有一个无参构造</li><li>属性必须私有化</li><li>必须有对应的get&#x2F;set方法</li></ul><p>一般用于和数据库的字段做映射  ORM；</p><p>ORM：对象关系映射</p><ul><li>表-&gt;类</li><li>字段-&gt; 类的属性</li><li>行记录-&gt; 对象</li></ul><p><strong>people表</strong></p><table><thead><tr><th>id</th><th>name</th><th>age</th><th>address</th></tr></thead><tbody><tr><td>1</td><td>张三</td><td>10</td><td>北京</td></tr><tr><td>2</td><td>李四</td><td>12</td><td>湖北</td></tr><tr><td>3</td><td>王五</td><td>14</td><td>山东</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;    <br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">private</span> String address;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">People</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-number">10</span>,<span class="hljs-string">&quot;北京&quot;</span>);<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">People</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;李四&quot;</span>,<span class="hljs-number">12</span>,<span class="hljs-string">&quot;湖北&quot;</span>);<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">People</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;王五&quot;</span>,<span class="hljs-number">13</span>,<span class="hljs-string">&quot;山东&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>使用方法：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;jsp:useBean id=<span class="hljs-string">&quot;people&quot;</span> class=<span class="hljs-string">&quot;com.shuwen.entity.People&quot;</span> scope=<span class="hljs-string">&quot;page&quot;</span>/&gt;<br><br>&lt;jsp:setProperty name=<span class="hljs-string">&quot;people&quot;</span> property=<span class="hljs-string">&quot;address&quot;</span> value=<span class="hljs-string">&quot;西安&quot;</span>/&gt;<br>&lt;jsp:setProperty name=<span class="hljs-string">&quot;people&quot;</span> property=<span class="hljs-string">&quot;id&quot;</span> value=<span class="hljs-string">&quot;1&quot;</span>/&gt;<br>&lt;jsp:setProperty name=<span class="hljs-string">&quot;people&quot;</span> property=<span class="hljs-string">&quot;age&quot;</span> value=<span class="hljs-string">&quot;3&quot;</span>/&gt;<br>&lt;jsp:setProperty name=<span class="hljs-string">&quot;people&quot;</span> property=<span class="hljs-string">&quot;name&quot;</span> value=<span class="hljs-string">&quot;张三&quot;</span>/&gt;<br><br>&lt;jsp:getProperty name=<span class="hljs-string">&quot;people&quot;</span> property=<span class="hljs-string">&quot;name&quot;</span>/&gt;<br>&lt;jsp:getProperty name=<span class="hljs-string">&quot;people&quot;</span> property=<span class="hljs-string">&quot;id&quot;</span>/&gt;<br>&lt;jsp:getProperty name=<span class="hljs-string">&quot;people&quot;</span> property=<span class="hljs-string">&quot;age&quot;</span>/&gt;<br>&lt;jsp:getProperty name=<span class="hljs-string">&quot;people&quot;</span> property=<span class="hljs-string">&quot;address&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><h2 id="MVC三层架构"><a href="#MVC三层架构" class="headerlink" title="MVC三层架构"></a>MVC三层架构</h2><p>概念：</p><p>Model view Controller 模型 视图 控制器</p><h3 id="早期架构"><a href="#早期架构" class="headerlink" title="早期架构"></a>早期架构</h3><p><img src="/2023/01/10/Java_Web/image-20201004100236448.png" alt="image-20201004100236448"></p><p>用户直接访问控制层，控制层就可以直接操作数据库</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">servlet--CRUD--&gt;数据库<br>    弊端：<br>    程序十分臃肿，不利于维护<br>    servlet的代码中：处理请求，响应，视图跳转，处理JDBC，处理业务代码，处理逻辑代码<br>架构：没有什么是加一层解决不了的;<br>程序员调用<br>|<br>JDBC;<br>|<br>Mysql Oracle sqlServer... ...<br></code></pre></td></tr></table></figure><h3 id="MVC三层架构-1"><a href="#MVC三层架构-1" class="headerlink" title="MVC三层架构"></a>MVC三层架构</h3><p><img src="/2023/01/10/Java_Web/image-20201004101527916.png" alt="image-20201004101527916"></p><p>Model</p><ul><li>业务处理：业务逻辑（Service）</li><li>数据持久层：CRUD（Dao）</li></ul><p>View</p><ul><li>展示数据</li><li>提供链接发起Servlet请求（a, form, img…）</li></ul><p>Controller</p><ul><li><p>接收用户的请求：（request:请求参数，Session信息… …）</p></li><li><p>交给业务层处理对应的代码</p></li><li><p>控制视图跳转</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">登录--&gt; 接收用户的登录请求--&gt; 处理用户的请求(获取用户登录的参数) --&gt; 交给业务层处理登录业务(判断用户名密码是否正确:事务)<br>--&gt; Dao层查询用户名和密码是否正确--&gt; 数据库<br></code></pre></td></tr></table></figure></li></ul><h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h2><p>Filter：过滤器，用来过滤网站的数据；</p><ul><li>处理中文乱码</li><li>登录验证</li></ul><p><img src="/2023/01/10/Java_Web/image-20201004102615729.png" alt="image-20201004102615729"></p><p>Filter开发步骤：</p><ol><li><p>导包</p></li><li><p>编写过滤器</p><ol><li><p>导包不要错，要导入java.servlet下面的Filter</p></li><li><p>实现filter接口，重写对应的方法</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CharacterEncodingFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Filter</span> &#123;<br><br>    <span class="hljs-comment">//web 服务器启动时就已经初始化了，随时等待过滤对象出现</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(FilterConfig filterConfig)</span> <span class="hljs-keyword">throws</span> ServletException &#123;<br>        System.out.println(<span class="hljs-string">&quot;CharacterEncodingFilter 初始化&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//1. 过滤器中的所有代码在过滤特定请求的时候都会执行</span><br>    <span class="hljs-comment">//2. 必须要让过滤器继续通行 chain.doFilter</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>        servletRequest.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);<br>        servletResponse.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);<br>        servletResponse.setContentType(<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span>);<br><br>        System.out.println(<span class="hljs-string">&quot;CharacterEncodingFilter 执行前...&quot;</span>);<br>        filterChain.doFilter(servletRequest, servletResponse);   <span class="hljs-comment">//让请求继续走，如果不写，程序到这里就会拦截停止</span><br>        System.out.println(<span class="hljs-string">&quot;CharacterEncodingFilter 执行后...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//Web 服务器关闭的时候，过滤器会销毁</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;CharacterEncodingFilter 销毁&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在Web.xml中配置Filter过滤器</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml">    <span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>com.shuwen.filter.CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br><span class="hljs-comment">&lt;!--        只要是/servlet下的任何请求，都会经过这个过滤器--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/servlet/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol></li></ol><h2 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h2><p>实现一个监听器的接口；</p><ol><li><p>编写一个监听器</p><p> 实现监听器的接口</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//统计网站在线人数: 统计session</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OnlineCountListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HttpSessionListener</span> &#123;<br>    <span class="hljs-comment">//创建session监听：看你的一举一动</span><br>    <span class="hljs-comment">//一旦创建一个session，就会触发一次这个事件</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sessionCreated</span><span class="hljs-params">(HttpSessionEvent httpSessionEvent)</span> &#123;<br>        <span class="hljs-type">ServletContext</span> <span class="hljs-variable">servletContext</span> <span class="hljs-operator">=</span> httpSessionEvent.getSession().getServletContext();<br><br>        System.out.println(httpSessionEvent.getSession().getId());<br><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">onlineCount</span> <span class="hljs-operator">=</span> (Integer) servletContext.getAttribute(<span class="hljs-string">&quot;OnlineCount&quot;</span>);<br>        <span class="hljs-keyword">if</span>(onlineCount == <span class="hljs-literal">null</span>)&#123;<br>            onlineCount = <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            onlineCount += <span class="hljs-number">1</span>;<br>        &#125;<br><br>        servletContext.setAttribute(<span class="hljs-string">&quot;OnlineCount&quot;</span>, onlineCount);<br>    &#125;<br><br>    <span class="hljs-comment">//销毁session监听</span><br>    <span class="hljs-comment">//一旦销毁Session，就会触发一次这个事件</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sessionDestroyed</span><span class="hljs-params">(HttpSessionEvent httpSessionEvent)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;会话销毁后...&quot;</span>);<br>        <span class="hljs-type">ServletContext</span> <span class="hljs-variable">servletContext</span> <span class="hljs-operator">=</span> httpSessionEvent.getSession().getServletContext();<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">onlineCount</span> <span class="hljs-operator">=</span> (Integer) servletContext.getAttribute(<span class="hljs-string">&quot;OnlineCount&quot;</span>);<br>        <span class="hljs-keyword">if</span>(onlineCount == <span class="hljs-literal">null</span>)&#123;<br>            onlineCount = <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            onlineCount -= <span class="hljs-number">1</span>;<br>        &#125;<br><br>        servletContext.setAttribute(<span class="hljs-string">&quot;OnlineCount&quot;</span>, onlineCount);<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * Session销毁</span><br><span class="hljs-comment">    * 1. 手动销毁 httpSessionEvent.getSession().invalidate();</span><br><span class="hljs-comment">    * 2. 自动销毁     &lt;session-config&gt;</span><br><span class="hljs-comment">                        &lt;session-timeout&gt;1&lt;/session-timeout&gt;   -- 一分钟后自动销毁</span><br><span class="hljs-comment">                    &lt;/session-config&gt;</span><br><span class="hljs-comment">    * */</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>配置监听器</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>com.shuwen.listener.OnlineCountListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>看情况是否使用</p></li></ol><h2 id="过滤器、监听器常见应用"><a href="#过滤器、监听器常见应用" class="headerlink" title="过滤器、监听器常见应用"></a>过滤器、监听器常见应用</h2><p>监听器：GUI编程中经常使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestPanel</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Frame</span> <span class="hljs-variable">frame</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Frame</span>(<span class="hljs-string">&quot;中秋&quot;</span>);    <span class="hljs-comment">//新建一个窗体</span><br>        <span class="hljs-type">Panel</span> <span class="hljs-variable">panel</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Panel</span>(<span class="hljs-literal">null</span>);   <span class="hljs-comment">//面板</span><br>        frame.setLayout(<span class="hljs-literal">null</span>);                  <span class="hljs-comment">//设置窗体布局</span><br><br>        frame.setBounds(<span class="hljs-number">300</span>, <span class="hljs-number">300</span>, <span class="hljs-number">500</span>, <span class="hljs-number">500</span>);<br>        frame.setBackground(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Color</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>, <span class="hljs-number">255</span>));      <span class="hljs-comment">//设置背景颜色</span><br><br>        panel.setBounds(<span class="hljs-number">50</span>, <span class="hljs-number">50</span>, <span class="hljs-number">300</span>, <span class="hljs-number">300</span>);<br>        panel.setBackground(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Color</span>(<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>));<br><br>        frame.add(panel);<br><br>        frame.setVisible(<span class="hljs-literal">true</span>);<br><br>        <span class="hljs-comment">//监听事件，监听关闭事件</span><br>        frame.addWindowListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">WindowAdapter</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">windowClosing</span><span class="hljs-params">(WindowEvent e)</span> &#123;<br>                System.exit(<span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>用户登录之后才能进入首页，用户注销后就不能进入主页。</p><ol><li><p>用户登录之后向Session中放入用户的数据</p></li><li><p>进入主页的时候，要判断用户是否已经登录</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>    <span class="hljs-comment">// ServletRequest</span><br>    <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">httpServletRequest</span> <span class="hljs-operator">=</span> (HttpServletRequest) servletRequest;<br>    <span class="hljs-type">HttpServletResponse</span> <span class="hljs-variable">httpServletResponse</span> <span class="hljs-operator">=</span> (HttpServletResponse) servletResponse;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">userSession</span> <span class="hljs-operator">=</span> httpServletRequest.getSession().getAttribute(Constant.USER_SESSION);<br>    <span class="hljs-keyword">if</span>(userSession == <span class="hljs-literal">null</span>)&#123;<br>        httpServletResponse.sendRedirect(<span class="hljs-string">&quot;/error.jsp&quot;</span>);<br>    &#125;<br>    filterChain.doFilter(servletRequest, servletResponse);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><p>详细内容见我的博客MySQL。</p><p>Junit单元测试</p><p>依赖：junit包</p><p>简单实用</p><p>@Test注解只有在方法上生效，只要加了这个方法，就可以直接运行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;Hello&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="项目实例：SMBMS"><a href="#项目实例：SMBMS" class="headerlink" title="项目实例：SMBMS"></a>项目实例：SMBMS</h2><h3 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h3><p><img src="/2023/01/10/Java_Web/image-20201004224144180.png" alt="image-20201004224144180"></p><h3 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h3><ol><li><p>搭建一个Maven Web项目</p></li><li><p>配置Tomcat</p></li><li><p>测试项目是否能够跑起来</p></li><li><p>导入项目中会遇到的jar包</p><p> jsp,servlet, mysql驱动, jstl, standard…</p></li><li><p>创建项目包结构</p><p> <img src="/2023/01/10/Java_Web/image-20201005223120901.png" alt="image-20201005223120901"></p></li><li><p>编写实体类</p><p> ORM映射：表-类映射</p></li><li><p>编写基础公共类</p><ol><li><p>数据库配置文件</p></li><li><p>编写公共类</p></li><li><p>编写字符编码过滤器</p></li></ol></li><li><p>导入静态资源（前端的内容）</p></li></ol><h3 id="登录功能"><a href="#登录功能" class="headerlink" title="登录功能"></a>登录功能</h3><p><img src="/2023/01/10/Java_Web/image-20201006163150542.png" alt="image-20201006163150542"></p><ol><li>编写前端</li><li>在web.xml中设置欢迎页</li><li>编写Dao层，得到用户登录的接口</li><li>编写Dao接口的实现类</li><li>业务层接口</li><li>业务层实现类</li><li>编写Servlet</li><li>注册Servlet</li><li>测试访问，确保以上功能成功</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Arrays and ArrayLists</title>
    <link href="/2023/01/10/Java_Arrays/"/>
    <url>/2023/01/10/Java_Arrays/</url>
    
    <content type="html"><![CDATA[<h1 id="Arrays-and-ArrayLists"><a href="#Arrays-and-ArrayLists" class="headerlink" title="Arrays and ArrayLists"></a>Arrays and ArrayLists</h1><h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><ul><li><p>直接创建</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">12</span>];<br></code></pre></td></tr></table></figure></li><li><p>先声明后创建</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] c;<br>c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">12</span>];<br></code></pre></td></tr></table></figure></li><li><p>使用数组的初始化表达式(array initializer list)</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] n = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br><br><span class="hljs-comment">//多维数组的初始化</span><br><span class="hljs-type">int</span>[][] b = &#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;&#125;;<br><span class="hljs-comment">//可以创建同行不同列</span><br><span class="hljs-type">int</span>[][] b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>][];  <span class="hljs-comment">//create 2 rows</span><br>b[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">5</span>];  <span class="hljs-comment">//create 5 columns for row 0</span><br>b[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];  <span class="hljs-comment">//create 3 columns for row 1</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="动态参数列表"><a href="#动态参数列表" class="headerlink" title="动态参数列表"></a>动态参数列表</h2><p>基本格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">type <span class="hljs-title function_">function_name</span><span class="hljs-params">(value_type... val)</span><br>    <br><span class="hljs-comment">//eg:</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">average</span><span class="hljs-params">(<span class="hljs-type">double</span>... numbers)</span>&#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">aver</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">double</span> d : numbers)&#123;<br>            aver += d;<br>        &#125;<br>        aver /= numbers.length;<br>        <span class="hljs-keyword">return</span> aver;<br>    &#125;    <br></code></pre></td></tr></table></figure><h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java InitArray 5 0 4<br></code></pre></td></tr></table></figure><p>其中initArray为文件名称，后面依次为args[0], args[1]…</p><h2 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类*"></a>Arrays类*</h2><p>用于处理数组的类，里面包含有许多操作数组的方法。</p><p>常用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Arrays.sort(arr);<br>Arrays.fill(arr, val);  <span class="hljs-comment">//给arr填充值val</span><br>System.arraycopy(arr1, <span class="hljs-number">0</span>, arrCopy, <span class="hljs-number">0</span>, arr1.length); <span class="hljs-comment">//深度拷贝数组，需要另开辟空间，因此使用System类</span><br>Arrays.equals(arr1, arr2);  <span class="hljs-comment">//依次比较两个数组中的值</span><br>Arrays.binarySearch(arr, val);  <span class="hljs-comment">//在已排序的数组中寻找val</span><br></code></pre></td></tr></table></figure><h2 id="ArrayList类"><a href="#ArrayList类" class="headerlink" title="ArrayList类*"></a>ArrayList类*</h2><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;T&gt; listName;<br></code></pre></td></tr></table></figure><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul><li>add</li><li>clear</li><li>contains &#x2F;&#x2F;如果包含某个值，则返回true, 否则返回false</li><li>get          &#x2F;&#x2F;返回特定下标的值</li><li>indexOf  &#x2F;&#x2F;返回第一次遇到的指定值的下标</li><li>remove  &#x2F;&#x2F;重载方法。删除首个遇到的指定值或者指定下标的值</li><li>size        &#x2F;&#x2F;返回ArrayList的大小</li><li>trimToSize  &#x2F;&#x2F;修剪当前的容量到ArrayList的实际大小</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Arrays</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DES</title>
    <link href="/2023/01/10/DES/"/>
    <url>/2023/01/10/DES/</url>
    
    <content type="html"><![CDATA[<h1 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>1975年IBM公司颁布的算法，在当时被美国选为国家标准并沿用至今天</p><p>DES多用于加密商业部门的非机密的敏感数据</p><p>特点：</p><p>分组密码：明文、密文、密钥的分组长度都是64位</p><p>能够加密任何形式的计算机数据</p><p>对合运算，加密和解密共用一套算法</p><p>基本结构输入Feistel结构</p><h2 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h2><p>DES算法可分为密钥生成和加&#x2F;解密过程两个阶段，整体工作流程如下图：</p><p><img src="/2023/01/10/DES/image-20211205170307869.png" alt="image-20211205170307869"></p><h3 id="密钥生成"><a href="#密钥生成" class="headerlink" title="密钥生成"></a>密钥生成</h3><p>DES算法共有16轮加&#x2F;解密迭代，每一轮都需要单独的子密钥，因此需要生成16个子密钥：</p><p><img src="/2023/01/10/DES/image-20211205170456114.png" alt="image-20211205170456114"></p><h4 id="置换选择1"><a href="#置换选择1" class="headerlink" title="置换选择1"></a>置换选择1</h4><p>输入：64bit密钥</p><p>输出：28位C0, 28位D0</p><p>过程：从64位密钥中去掉每个字节的第8位，奇偶校验位，把剩下的56位按照规则打乱重排，将前28位作为C0，后28位作为D0</p><h4 id="循环左移"><a href="#循环左移" class="headerlink" title="循环左移"></a>循环左移</h4><p>每一轮根据表格循环不同的位数，注意，如果数据摆放的方式不同，这里的循环左移可能变成循环右移，需要参考具体示例来决定</p><h4 id="置换选择2"><a href="#置换选择2" class="headerlink" title="置换选择2"></a>置换选择2</h4><p>输入：28位Ci, 28位Di</p><p>输出：48位子密钥</p><p>过程：将Ci和Di合并成56位中间数据，从中选择48位的子密钥Ki</p><h3 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h3><h4 id="初始置换IP"><a href="#初始置换IP" class="headerlink" title="初始置换IP"></a>初始置换IP</h4><p>输入：64位明文</p><p>输出：32位L0，32位R0</p><p>过程：按照规则将明文转化为L0，R0</p><h4 id="加密函数F"><a href="#加密函数F" class="headerlink" title="加密函数F"></a>加密函数F</h4><p>输入：32为R和48位子密钥</p><p>输出：32位f</p><p>具体过程如下图：</p><p><img src="/2023/01/10/DES/image-20211205174408085.png" alt="image-20211205174408085"></p><h5 id="选择运算"><a href="#选择运算" class="headerlink" title="选择运算"></a>选择运算</h5><p>输入：32位A</p><p>输出：48位中间结果</p><p>过程：根据规则扩展</p><h5 id="模2相加"><a href="#模2相加" class="headerlink" title="模2相加"></a>模2相加</h5><p>输入：48位中间结果，48位子密钥</p><p>输出：48位</p><p>过程：异或</p><h5 id="S盒变换"><a href="#S盒变换" class="headerlink" title="S盒变换"></a>S盒变换</h5><p>输入：48位</p><p>输出：32位</p><p>过程：将48位输入分成8份，每份6bit，设为b1b2b3b4b5b6，其中b1b6组成行号，b2b3b4b5组成列号，使用行列到Si盒中查找相应的值作为4bit输出。注意，输出的结果很可能是逆序存放的，即4bit的高位放到最终输出的低位</p><h5 id="置换运算P"><a href="#置换运算P" class="headerlink" title="置换运算P"></a>置换运算P</h5><p>输入：32位</p><p>输出：32位</p><p>过程：按照规则取数</p><h3 id="解密算法"><a href="#解密算法" class="headerlink" title="解密算法"></a>解密算法</h3><p>整体流程和加密相同，但是子密钥是反过来使用的，即最先使用K16，最后使用K1</p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// main.c</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;des.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">char</span>* key_str = <span class="hljs-string">&quot;0011000100110010001100110011010000110101001101100011011100111000&quot;</span>;<br>    <span class="hljs-type">char</span>* M_str   = <span class="hljs-string">&quot;0011000000110001001100100011001100110100001101010011011000110111&quot;</span>;<br><br>    <span class="hljs-type">uint64_t</span> key = get_key(key_str);<br>    <span class="hljs-type">uint64_t</span> M = get_M(M_str);<br><br>    <span class="hljs-type">uint64_t</span> C = des_encode(M, key);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;C:\n&quot;</span>);<br>    output_bin(C, <span class="hljs-number">64</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>    <span class="hljs-type">uint64_t</span> plain = des_decode(C, key);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;M:\n&quot;</span>);<br>    output_bin(plain, <span class="hljs-number">64</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;M == M ? %d\n&quot;</span>, M == plain);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// des.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> DES_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DES_H</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">uint64_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>       <span class="hljs-type">uint32_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>      <span class="hljs-type">uint8_t</span>;<br><br><span class="hljs-comment">// des加密</span><br><span class="hljs-type">uint64_t</span> <span class="hljs-title function_">des_encode</span><span class="hljs-params">(<span class="hljs-type">uint64_t</span> M, <span class="hljs-type">uint64_t</span> key)</span>;<br><br><span class="hljs-comment">// des解密</span><br><span class="hljs-type">uint64_t</span> <span class="hljs-title function_">des_decode</span><span class="hljs-params">(<span class="hljs-type">uint64_t</span> C, <span class="hljs-type">uint64_t</span> key)</span>;<br><br><span class="hljs-comment">// 获取密钥</span><br><span class="hljs-type">uint64_t</span> <span class="hljs-title function_">get_key</span><span class="hljs-params">(<span class="hljs-type">char</span>* str)</span>;<br><br><span class="hljs-comment">// 获取明文</span><br><span class="hljs-type">uint64_t</span> <span class="hljs-title function_">get_M</span><span class="hljs-params">(<span class="hljs-type">char</span>* str)</span>;<br><br><span class="hljs-comment">// 输出10进制数的二进制表示</span><br><span class="hljs-comment">// k: 二进制的位数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">output_bin</span><span class="hljs-params">(<span class="hljs-type">uint64_t</span> dec, <span class="hljs-type">uint8_t</span> k)</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// des.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;des.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;table.h&quot;</span></span><br><br><span class="hljs-comment">// 获得byte8第p位的bit</span><br><span class="hljs-comment">// eg: byte=0100 0010, p=1, bit=1; p=2, bit=0</span><br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">get_bit</span><span class="hljs-params">(<span class="hljs-type">uint64_t</span> byte8, <span class="hljs-type">uint8_t</span> p)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> (byte8 &gt;&gt; p) &amp; <span class="hljs-number">0x1</span>;<br>&#125;<br><br><span class="hljs-comment">// 设置byte8第p位为 bit</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">set_bit</span><span class="hljs-params">(<span class="hljs-type">uint64_t</span>* byte8, <span class="hljs-type">uint8_t</span> p, <span class="hljs-type">uint8_t</span> bit)</span><br>&#123;<br>    <span class="hljs-type">uint64_t</span> bit_p = get_bit(*byte8, p);<br>    *byte8 ^= bit_p &lt;&lt; p;<br>    *byte8 |= (<span class="hljs-type">uint64_t</span>)bit &lt;&lt; p;<br>&#125;<br><br><span class="hljs-comment">// 输出k位64bit十进制数的二进制表示</span><br><span class="hljs-comment">// output: 0bit-&gt;(k-1)bit</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">output_bin</span><span class="hljs-params">(<span class="hljs-type">uint64_t</span> dec, <span class="hljs-type">uint8_t</span> k)</span><br>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, (<span class="hljs-type">int</span>)get_bit(dec, i));<br>        <span class="hljs-keyword">if</span>((i + <span class="hljs-number">1</span>) % <span class="hljs-number">8</span> == <span class="hljs-number">0</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// len(str) == 64</span><br><span class="hljs-comment">// str: 0bit-&gt;63bit</span><br><span class="hljs-type">uint64_t</span> <span class="hljs-title function_">get_key</span><span class="hljs-params">(<span class="hljs-type">char</span>* str)</span><br>&#123;<br>    <span class="hljs-type">uint64_t</span> key = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">64</span>; ++i)<br>    &#123;<br>        <span class="hljs-type">uint8_t</span> ch = str[i];<br>        set_bit(&amp;key, i, ch);<br>    &#125;<br>    <span class="hljs-keyword">return</span> key;<br>&#125;<br><br><span class="hljs-comment">// 获取明文</span><br><span class="hljs-type">uint64_t</span> <span class="hljs-title function_">get_M</span><span class="hljs-params">(<span class="hljs-type">char</span>* str)</span><br>&#123;<br>    <span class="hljs-type">uint64_t</span> M = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">64</span>; ++i)<br>    &#123;<br>        <span class="hljs-type">uint8_t</span> ch = str[i];<br>        set_bit(&amp;M, i, ch);<br>    &#125;<br>    <span class="hljs-keyword">return</span> M;<br>&#125;<br><br><span class="hljs-comment">// 置换选择1</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">swap_sel1</span><span class="hljs-params">(<span class="hljs-type">uint64_t</span> key, <span class="hljs-type">uint64_t</span>* C0, <span class="hljs-type">uint64_t</span>* D0)</span><br>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">28</span>; ++i)<br>    &#123;<br>        set_bit(C0, i, get_bit(key, MatC0[i] - <span class="hljs-number">1</span>));<br>        set_bit(D0, i, get_bit(key, MatD0[i] - <span class="hljs-number">1</span>));<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 循环左移 011(1) -&gt; 110, 在算法中体现为右移</span><br><span class="hljs-comment">// d: 要移动的数字</span><br><span class="hljs-comment">// k: 该数字的长度</span><br><span class="hljs-comment">// l: 移动的长度</span><br><span class="hljs-type">uint64_t</span> <span class="hljs-title function_">rol_shift_l</span><span class="hljs-params">(<span class="hljs-type">uint64_t</span> d, <span class="hljs-type">uint8_t</span> k, <span class="hljs-type">uint8_t</span> l)</span><br>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; l; ++i)<br>    &#123;<br>        <span class="hljs-type">uint8_t</span> bit = get_bit(d, <span class="hljs-number">0</span>);<br>        d &gt;&gt;= <span class="hljs-number">1</span>;<br>        set_bit(&amp;d, k - <span class="hljs-number">1</span>, bit);<br>    &#125;<br>    <span class="hljs-keyword">return</span> d;<br>&#125;<br><br><span class="hljs-comment">// 生成下一轮子密钥</span><br><span class="hljs-type">uint64_t</span> <span class="hljs-title function_">cal_K</span><span class="hljs-params">(<span class="hljs-type">uint64_t</span>* Ci, <span class="hljs-type">uint64_t</span>* Di, <span class="hljs-type">uint32_t</span> it)</span><br>&#123;<br>    <span class="hljs-type">uint64_t</span> K = <span class="hljs-number">0</span>;<br><br>    *Ci = rol_shift_l(*Ci, <span class="hljs-number">28</span>, Rol[it]);  <span class="hljs-comment">// 0~23</span><br>    *Di = rol_shift_l(*Di, <span class="hljs-number">28</span>, Rol[it]);  <span class="hljs-comment">//24~47</span><br><br>    <span class="hljs-comment">// 置换选择2</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">48</span>; ++i)<br>    &#123;<br>        <span class="hljs-type">uint32_t</span> idx = MatPC2[i] - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">uint8_t</span> bit;<br>        <span class="hljs-keyword">if</span>(idx &lt; <span class="hljs-number">28</span>)<br>        &#123;<br>            bit = get_bit(*Ci, idx);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            idx -= <span class="hljs-number">28</span>;<br>            bit = get_bit(*Di, idx);<br>        &#125;<br><br>        set_bit(&amp;K, i, bit);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> K;<br>&#125;<br><br><span class="hljs-comment">// 初始置换IP</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">IP_swap</span><span class="hljs-params">(<span class="hljs-type">uint64_t</span> M, <span class="hljs-type">uint32_t</span>* L, <span class="hljs-type">uint32_t</span>* R)</span><br>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">64</span>; ++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">32</span>)<br>        &#123;<br>            set_bit((<span class="hljs-type">uint64_t</span>*)L, i, get_bit(M, IP[i] - <span class="hljs-number">1</span>));<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            set_bit((<span class="hljs-type">uint64_t</span>*)R, i - <span class="hljs-number">32</span>, get_bit(M, IP[i] - <span class="hljs-number">1</span>));<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// IP逆置换</span><br><span class="hljs-type">uint64_t</span> <span class="hljs-title function_">IPinv_swap</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> R, <span class="hljs-type">uint32_t</span> L)</span><br>&#123;<br>    <span class="hljs-type">uint64_t</span> C = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">64</span>; ++i)<br>    &#123;<br>        <span class="hljs-type">int</span> idx = IP_inv[i] - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(idx &lt; <span class="hljs-number">32</span>)<br>        &#123;<br>            set_bit(&amp;C, i, get_bit(R, idx));<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            idx -= <span class="hljs-number">32</span>;<br>            set_bit(&amp;C, i, get_bit(L, idx));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><br><span class="hljs-comment">// 选择运算E</span><br><span class="hljs-type">uint64_t</span> <span class="hljs-title function_">E</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> R)</span><br>&#123;<br>    <span class="hljs-type">uint64_t</span> mid;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">48</span>; ++i)<br>    &#123;<br>        set_bit(&amp;mid, i, get_bit(R, ET[i] - <span class="hljs-number">1</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> mid;<br>&#125;<br><br><span class="hljs-comment">// S盒变换</span><br><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">S</span><span class="hljs-params">(<span class="hljs-type">uint64_t</span> in48)</span><br>&#123;<br>    <span class="hljs-type">uint32_t</span> out32 = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">uint64_t</span> row = <span class="hljs-number">0</span>, col = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; ++i)<br>    &#123;<br>        <span class="hljs-comment">// 取出6*i-&gt; 6*i+5位</span><br>        <span class="hljs-comment">// row: b1b6</span><br>        set_bit(&amp;row, <span class="hljs-number">1</span>, get_bit(in48, <span class="hljs-number">6</span>*i  ));<br>        set_bit(&amp;row, <span class="hljs-number">0</span>, get_bit(in48, <span class="hljs-number">6</span>*i+<span class="hljs-number">5</span>));<br><br>        <span class="hljs-comment">// col: b2b3b4b5</span><br>        set_bit(&amp;col, <span class="hljs-number">3</span>, get_bit(in48, <span class="hljs-number">6</span>*i+<span class="hljs-number">1</span>));<br>        set_bit(&amp;col, <span class="hljs-number">2</span>, get_bit(in48, <span class="hljs-number">6</span>*i+<span class="hljs-number">2</span>));<br>        set_bit(&amp;col, <span class="hljs-number">1</span>, get_bit(in48, <span class="hljs-number">6</span>*i+<span class="hljs-number">3</span>));<br>        set_bit(&amp;col, <span class="hljs-number">0</span>, get_bit(in48, <span class="hljs-number">6</span>*i+<span class="hljs-number">4</span>));<br><br>        <span class="hljs-type">uint32_t</span> si = S_Box[i][row][col];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span>; ++j)<br>        &#123;<br>            set_bit((<span class="hljs-type">uint64_t</span>*)&amp;out32, <span class="hljs-number">4</span>*i+j, get_bit((<span class="hljs-type">uint64_t</span>)si, <span class="hljs-number">3</span> - j));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> out32;<br>&#125;<br><br><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">P</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> s)</span><br>&#123;<br>    <span class="hljs-type">uint32_t</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; ++i)<br>    &#123;<br>        set_bit((<span class="hljs-type">uint64_t</span>*)&amp;p, i, get_bit((<span class="hljs-type">uint64_t</span>)s, PT[i] - <span class="hljs-number">1</span>));<br>    &#125;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-comment">// F函数</span><br><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">F</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> R, <span class="hljs-type">uint64_t</span> key48)</span><br>&#123;<br>    <span class="hljs-comment">// 选择运算</span><br>    <span class="hljs-type">uint64_t</span> mid = E(R);<br>    <span class="hljs-comment">// 模2相加</span><br>    <span class="hljs-type">uint64_t</span> xor = mid ^ key48;<br>    <span class="hljs-comment">// S盒</span><br>    <span class="hljs-type">uint32_t</span> s = S(xor);<br>    <span class="hljs-comment">// 置换运算P</span><br>    <span class="hljs-type">uint32_t</span> p = P(s);<br><br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><br><br><span class="hljs-type">uint64_t</span> <span class="hljs-title function_">des_encode</span><span class="hljs-params">(<span class="hljs-type">uint64_t</span> M, <span class="hljs-type">uint64_t</span> key)</span><br>&#123;<br>    <span class="hljs-comment">// IP置换</span><br>    <span class="hljs-type">uint32_t</span> L = <span class="hljs-number">0</span>, R = <span class="hljs-number">0</span>;<br>    IP_swap(M, &amp;L, &amp;R);<br><br>    <span class="hljs-comment">// 置换选择1</span><br>    <span class="hljs-type">uint64_t</span> C = <span class="hljs-number">0</span>, D = <span class="hljs-number">0</span>;<br>    swap_sel1(key, &amp;C, &amp;D);<br>    <span class="hljs-comment">// 轮函数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> it = <span class="hljs-number">0</span>; it &lt; <span class="hljs-number">16</span>; ++it)<br>    &#123;<br>        <span class="hljs-type">uint64_t</span> key48 = cal_K(&amp;C, &amp;D, it);<br>        <span class="hljs-type">uint32_t</span> f = F(R, key48);<br><br>        <span class="hljs-type">uint32_t</span> lastL = L;<br>        L = R;<br>        R = lastL ^ f;<br>    &#125;<br><br>    <span class="hljs-comment">// IP逆置换</span><br>    <span class="hljs-type">uint64_t</span> cipher = IPinv_swap(R, L);<br>    <span class="hljs-keyword">return</span> cipher;<br>&#125;<br><br><span class="hljs-comment">// des解密</span><br><span class="hljs-type">uint64_t</span> <span class="hljs-title function_">des_decode</span><span class="hljs-params">(<span class="hljs-type">uint64_t</span> cipher, <span class="hljs-type">uint64_t</span> key)</span><br>&#123;<br>    <span class="hljs-comment">// IP置换</span><br>    <span class="hljs-type">uint32_t</span> L = <span class="hljs-number">0</span>, R = <span class="hljs-number">0</span>;<br>    IP_swap(cipher, &amp;L, &amp;R);<br><br>    <span class="hljs-comment">// 置换选择1</span><br>    <span class="hljs-type">uint64_t</span> C = <span class="hljs-number">0</span>, D = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">uint64_t</span> keys[<span class="hljs-number">16</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    swap_sel1(key, &amp;C, &amp;D);<br>    <span class="hljs-comment">// 轮密钥</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> it = <span class="hljs-number">0</span>; it &lt; <span class="hljs-number">16</span>; ++it)<br>    &#123;<br>        keys[it] = cal_K(&amp;C, &amp;D, it);<br>    &#125;<br><br>    <span class="hljs-comment">// 轮函数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> it = <span class="hljs-number">15</span>; it &gt;= <span class="hljs-number">0</span>; --it)<br>    &#123;<br>        <span class="hljs-type">uint32_t</span> f = F(R, keys[it]);<br><br>        <span class="hljs-type">uint32_t</span> lastL = L;<br>        L = R;<br>        R = lastL ^ f;<br>    &#125;<br><br>    <span class="hljs-comment">// IP逆置换</span><br>    <span class="hljs-type">uint64_t</span> M = IPinv_swap(R, L);<br>    <span class="hljs-keyword">return</span> M;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// table.h</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> TABLE_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TABLE_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;des.h&quot;</span></span><br><br><span class="hljs-type">uint32_t</span> MatC0[<span class="hljs-number">7</span> * <span class="hljs-number">4</span>] = <br>&#123;<br><span class="hljs-number">57</span>, <span class="hljs-number">49</span>, <span class="hljs-number">31</span>, <span class="hljs-number">33</span>, <span class="hljs-number">25</span>, <span class="hljs-number">17</span>,  <span class="hljs-number">9</span>,<br> <span class="hljs-number">1</span>, <span class="hljs-number">58</span>, <span class="hljs-number">50</span>, <span class="hljs-number">42</span>, <span class="hljs-number">34</span>, <span class="hljs-number">26</span>, <span class="hljs-number">18</span>,<br><span class="hljs-number">10</span>,  <span class="hljs-number">2</span>, <span class="hljs-number">59</span>, <span class="hljs-number">51</span>, <span class="hljs-number">43</span>, <span class="hljs-number">35</span>, <span class="hljs-number">27</span>,<br><span class="hljs-number">19</span>, <span class="hljs-number">11</span>,  <span class="hljs-number">3</span>, <span class="hljs-number">60</span>, <span class="hljs-number">52</span>, <span class="hljs-number">44</span>, <span class="hljs-number">36</span>,<br>&#125;;<br><br><span class="hljs-type">uint32_t</span> MatD0[<span class="hljs-number">7</span> * <span class="hljs-number">4</span>] = <br>&#123;<br><span class="hljs-number">63</span>, <span class="hljs-number">55</span>, <span class="hljs-number">47</span>, <span class="hljs-number">39</span>, <span class="hljs-number">31</span>, <span class="hljs-number">23</span>, <span class="hljs-number">15</span>,<br> <span class="hljs-number">7</span>, <span class="hljs-number">62</span>, <span class="hljs-number">54</span>, <span class="hljs-number">46</span>, <span class="hljs-number">38</span>, <span class="hljs-number">30</span>, <span class="hljs-number">22</span>,<br><span class="hljs-number">14</span>,  <span class="hljs-number">6</span>, <span class="hljs-number">61</span>, <span class="hljs-number">53</span>, <span class="hljs-number">45</span>, <span class="hljs-number">37</span>, <span class="hljs-number">29</span>,<br><span class="hljs-number">21</span>, <span class="hljs-number">13</span>,  <span class="hljs-number">5</span>, <span class="hljs-number">28</span>, <span class="hljs-number">20</span>, <span class="hljs-number">12</span>,  <span class="hljs-number">4</span>,<br>&#125;;<br><br><span class="hljs-comment">// 置换选择2表格</span><br><span class="hljs-type">uint32_t</span> MatPC2[<span class="hljs-number">6</span> * <span class="hljs-number">8</span>] =<br>&#123;<br><span class="hljs-number">14</span>,<span class="hljs-number">17</span>,<span class="hljs-number">11</span>,<span class="hljs-number">24</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>,<br> <span class="hljs-number">3</span>,<span class="hljs-number">28</span>,<span class="hljs-number">15</span>, <span class="hljs-number">6</span>,<span class="hljs-number">21</span>,<span class="hljs-number">10</span>,<br><span class="hljs-number">23</span>,<span class="hljs-number">19</span>,<span class="hljs-number">12</span>, <span class="hljs-number">4</span>,<span class="hljs-number">26</span>, <span class="hljs-number">8</span>,<br><span class="hljs-number">16</span>, <span class="hljs-number">7</span>,<span class="hljs-number">27</span>,<span class="hljs-number">20</span>,<span class="hljs-number">13</span>, <span class="hljs-number">2</span>,<br><span class="hljs-number">41</span>,<span class="hljs-number">52</span>,<span class="hljs-number">31</span>,<span class="hljs-number">37</span>,<span class="hljs-number">47</span>,<span class="hljs-number">55</span>,<br><span class="hljs-number">30</span>,<span class="hljs-number">40</span>,<span class="hljs-number">51</span>,<span class="hljs-number">45</span>,<span class="hljs-number">33</span>,<span class="hljs-number">48</span>,<br><span class="hljs-number">44</span>,<span class="hljs-number">49</span>,<span class="hljs-number">39</span>,<span class="hljs-number">56</span>,<span class="hljs-number">34</span>,<span class="hljs-number">53</span>,<br><span class="hljs-number">46</span>,<span class="hljs-number">42</span>,<span class="hljs-number">50</span>,<span class="hljs-number">36</span>,<span class="hljs-number">29</span>,<span class="hljs-number">32</span> <br>&#125;;<br><br><span class="hljs-comment">//  移位表</span><br><span class="hljs-type">uint32_t</span> Rol[<span class="hljs-number">16</span>] =<br>&#123;<br><span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span><br>&#125;;<br><br><span class="hljs-comment">// IP置换表</span><br><span class="hljs-type">uint32_t</span> IP[<span class="hljs-number">64</span>] =<br>&#123;             <br><span class="hljs-number">58</span>,<span class="hljs-number">50</span>,<span class="hljs-number">42</span>,<span class="hljs-number">34</span>,<span class="hljs-number">26</span>,<span class="hljs-number">18</span>,<span class="hljs-number">10</span>, <span class="hljs-number">2</span>,<span class="hljs-number">60</span>,<span class="hljs-number">52</span>,<span class="hljs-number">44</span>,<span class="hljs-number">36</span>,<span class="hljs-number">28</span>,<span class="hljs-number">20</span>,<span class="hljs-number">12</span>, <span class="hljs-number">4</span>,<br><span class="hljs-number">62</span>,<span class="hljs-number">54</span>,<span class="hljs-number">46</span>,<span class="hljs-number">38</span>,<span class="hljs-number">30</span>,<span class="hljs-number">22</span>,<span class="hljs-number">14</span>, <span class="hljs-number">6</span>,<span class="hljs-number">64</span>,<span class="hljs-number">56</span>,<span class="hljs-number">48</span>,<span class="hljs-number">40</span>,<span class="hljs-number">32</span>,<span class="hljs-number">24</span>,<span class="hljs-number">16</span>, <span class="hljs-number">8</span>,<br><span class="hljs-number">57</span>,<span class="hljs-number">49</span>,<span class="hljs-number">41</span>,<span class="hljs-number">33</span>,<span class="hljs-number">25</span>,<span class="hljs-number">17</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1</span>,<span class="hljs-number">59</span>,<span class="hljs-number">51</span>,<span class="hljs-number">43</span>,<span class="hljs-number">35</span>,<span class="hljs-number">27</span>,<span class="hljs-number">19</span>,<span class="hljs-number">11</span>, <span class="hljs-number">3</span>,<br><span class="hljs-number">61</span>,<span class="hljs-number">53</span>,<span class="hljs-number">45</span>,<span class="hljs-number">37</span>,<span class="hljs-number">29</span>,<span class="hljs-number">21</span>,<span class="hljs-number">13</span>, <span class="hljs-number">5</span>,<span class="hljs-number">63</span>,<span class="hljs-number">55</span>,<span class="hljs-number">47</span>,<span class="hljs-number">39</span>,<span class="hljs-number">31</span>,<span class="hljs-number">23</span>,<span class="hljs-number">15</span>, <span class="hljs-number">7</span> <br>&#125;;<br><span class="hljs-comment">// IP-1置换表</span><br><span class="hljs-type">uint32_t</span> IP_inv[<span class="hljs-number">64</span>] =<br>&#123;              <br><span class="hljs-number">40</span>, <span class="hljs-number">8</span>,<span class="hljs-number">48</span>,<span class="hljs-number">16</span>,<span class="hljs-number">56</span>,<span class="hljs-number">24</span>,<span class="hljs-number">64</span>,<span class="hljs-number">32</span>,<br><span class="hljs-number">39</span>, <span class="hljs-number">7</span>,<span class="hljs-number">47</span>,<span class="hljs-number">15</span>,<span class="hljs-number">55</span>,<span class="hljs-number">23</span>,<span class="hljs-number">63</span>,<span class="hljs-number">31</span>,<br><span class="hljs-number">38</span>, <span class="hljs-number">6</span>,<span class="hljs-number">46</span>,<span class="hljs-number">14</span>,<span class="hljs-number">54</span>,<span class="hljs-number">22</span>,<span class="hljs-number">62</span>,<span class="hljs-number">30</span>,<br><span class="hljs-number">37</span>, <span class="hljs-number">5</span>,<span class="hljs-number">45</span>,<span class="hljs-number">13</span>,<span class="hljs-number">53</span>,<span class="hljs-number">21</span>,<span class="hljs-number">61</span>,<span class="hljs-number">29</span>,<br><span class="hljs-number">36</span>, <span class="hljs-number">4</span>,<span class="hljs-number">44</span>,<span class="hljs-number">12</span>,<span class="hljs-number">52</span>,<span class="hljs-number">20</span>,<span class="hljs-number">60</span>,<span class="hljs-number">28</span>,<br><span class="hljs-number">35</span>, <span class="hljs-number">3</span>,<span class="hljs-number">43</span>,<span class="hljs-number">11</span>,<span class="hljs-number">51</span>,<span class="hljs-number">19</span>,<span class="hljs-number">59</span>,<span class="hljs-number">27</span>,<br><span class="hljs-number">34</span>, <span class="hljs-number">2</span>,<span class="hljs-number">42</span>,<span class="hljs-number">10</span>,<span class="hljs-number">50</span>,<span class="hljs-number">18</span>,<span class="hljs-number">58</span>,<span class="hljs-number">26</span>,<br><span class="hljs-number">33</span>, <span class="hljs-number">1</span>,<span class="hljs-number">41</span>, <span class="hljs-number">9</span>,<span class="hljs-number">49</span>,<span class="hljs-number">17</span>,<span class="hljs-number">57</span>,<span class="hljs-number">25</span> <br>&#125;;<br><br><span class="hljs-comment">// E扩展表</span><br><span class="hljs-type">uint32_t</span> ET[<span class="hljs-number">48</span>] = <br>&#123;<br><span class="hljs-number">32</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>,<br> <span class="hljs-number">8</span>, <span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">13</span>,<span class="hljs-number">12</span>,<span class="hljs-number">13</span>,<span class="hljs-number">14</span>,<span class="hljs-number">15</span>,<span class="hljs-number">16</span>,<span class="hljs-number">17</span>,<br><span class="hljs-number">16</span>,<span class="hljs-number">17</span>,<span class="hljs-number">18</span>,<span class="hljs-number">19</span>,<span class="hljs-number">20</span>,<span class="hljs-number">21</span>,<span class="hljs-number">20</span>,<span class="hljs-number">21</span>,<span class="hljs-number">22</span>,<span class="hljs-number">23</span>,<span class="hljs-number">24</span>,<span class="hljs-number">25</span>,<br><span class="hljs-number">24</span>,<span class="hljs-number">25</span>,<span class="hljs-number">26</span>,<span class="hljs-number">27</span>,<span class="hljs-number">28</span>,<span class="hljs-number">29</span>,<span class="hljs-number">28</span>,<span class="hljs-number">29</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">32</span>, <span class="hljs-number">1</span><br>&#125;;<br><br> <span class="hljs-comment">// S盒</span><br><span class="hljs-type">uint32_t</span> S_Box[<span class="hljs-number">8</span>][<span class="hljs-number">4</span>][<span class="hljs-number">16</span>] = <br>&#123;<br> <span class="hljs-comment">//S1</span><br> <span class="hljs-number">14</span>, <span class="hljs-number">4</span>,<span class="hljs-number">13</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>,<span class="hljs-number">15</span>,<span class="hljs-number">11</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>,<span class="hljs-number">10</span>, <span class="hljs-number">6</span>,<span class="hljs-number">12</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>, <span class="hljs-number">7</span>,<br>  <span class="hljs-number">0</span>,<span class="hljs-number">15</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>,<span class="hljs-number">14</span>, <span class="hljs-number">2</span>,<span class="hljs-number">13</span>, <span class="hljs-number">1</span>,<span class="hljs-number">10</span>, <span class="hljs-number">6</span>,<span class="hljs-number">12</span>,<span class="hljs-number">11</span>, <span class="hljs-number">9</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>,<br>  <span class="hljs-number">4</span>, <span class="hljs-number">1</span>,<span class="hljs-number">14</span>, <span class="hljs-number">8</span>,<span class="hljs-number">13</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>,<span class="hljs-number">11</span>,<span class="hljs-number">15</span>,<span class="hljs-number">12</span>, <span class="hljs-number">9</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>,<span class="hljs-number">10</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>,<br> <span class="hljs-number">15</span>,<span class="hljs-number">12</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">5</span>,<span class="hljs-number">11</span>, <span class="hljs-number">3</span>,<span class="hljs-number">14</span>,<span class="hljs-number">10</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>,<span class="hljs-number">13</span>,<br> <span class="hljs-comment">//S2</span><br> <span class="hljs-number">15</span>, <span class="hljs-number">1</span>, <span class="hljs-number">8</span>,<span class="hljs-number">14</span>, <span class="hljs-number">6</span>,<span class="hljs-number">11</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>,<span class="hljs-number">13</span>,<span class="hljs-number">12</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>,<span class="hljs-number">10</span>,<br>  <span class="hljs-number">3</span>,<span class="hljs-number">13</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>,<span class="hljs-number">15</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>,<span class="hljs-number">14</span>,<span class="hljs-number">12</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>,<span class="hljs-number">10</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>,<span class="hljs-number">11</span>, <span class="hljs-number">5</span>,<br>  <span class="hljs-number">0</span>,<span class="hljs-number">14</span>, <span class="hljs-number">7</span>,<span class="hljs-number">11</span>,<span class="hljs-number">10</span>, <span class="hljs-number">4</span>,<span class="hljs-number">13</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>,<span class="hljs-number">12</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>,<span class="hljs-number">15</span>,<br> <span class="hljs-number">13</span>, <span class="hljs-number">8</span>,<span class="hljs-number">10</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>,<span class="hljs-number">15</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>,<span class="hljs-number">11</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>,<span class="hljs-number">12</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>,<span class="hljs-number">14</span>, <span class="hljs-number">9</span>,<br> <span class="hljs-comment">//S3</span><br> <span class="hljs-number">10</span>, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>,<span class="hljs-number">14</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>,<span class="hljs-number">15</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>,<span class="hljs-number">13</span>,<span class="hljs-number">12</span>, <span class="hljs-number">7</span>,<span class="hljs-number">11</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>,<br> <span class="hljs-number">13</span>, <span class="hljs-number">7</span>, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>,<span class="hljs-number">10</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">5</span>,<span class="hljs-number">14</span>,<span class="hljs-number">12</span>,<span class="hljs-number">11</span>,<span class="hljs-number">15</span>, <span class="hljs-number">1</span>,<br> <span class="hljs-number">13</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">8</span>,<span class="hljs-number">15</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>,<span class="hljs-number">11</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>,<span class="hljs-number">12</span>, <span class="hljs-number">5</span>,<span class="hljs-number">10</span>,<span class="hljs-number">14</span>, <span class="hljs-number">7</span>,<br>  <span class="hljs-number">1</span>,<span class="hljs-number">10</span>,<span class="hljs-number">13</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>,<span class="hljs-number">15</span>,<span class="hljs-number">14</span>, <span class="hljs-number">3</span>,<span class="hljs-number">11</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>,<span class="hljs-number">12</span>,<br> <span class="hljs-comment">//S4</span><br>  <span class="hljs-number">7</span>,<span class="hljs-number">13</span>,<span class="hljs-number">14</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>,<span class="hljs-number">10</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">5</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>, <span class="hljs-number">4</span>,<span class="hljs-number">15</span>,<br> <span class="hljs-number">13</span>, <span class="hljs-number">8</span>,<span class="hljs-number">11</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>,<span class="hljs-number">15</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>,<span class="hljs-number">12</span>, <span class="hljs-number">1</span>,<span class="hljs-number">10</span>,<span class="hljs-number">14</span>, <span class="hljs-number">9</span>,<br> <span class="hljs-number">10</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>,<span class="hljs-number">12</span>,<span class="hljs-number">11</span>, <span class="hljs-number">7</span>,<span class="hljs-number">13</span>,<span class="hljs-number">15</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>,<span class="hljs-number">14</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>,<br>  <span class="hljs-number">3</span>,<span class="hljs-number">15</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>,<span class="hljs-number">10</span>, <span class="hljs-number">1</span>,<span class="hljs-number">13</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>,<span class="hljs-number">14</span>,<br> <span class="hljs-comment">//S5</span><br>  <span class="hljs-number">2</span>,<span class="hljs-number">12</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>,<span class="hljs-number">15</span>,<span class="hljs-number">13</span>, <span class="hljs-number">0</span>,<span class="hljs-number">14</span>, <span class="hljs-number">9</span>,<br> <span class="hljs-number">14</span>,<span class="hljs-number">11</span>, <span class="hljs-number">2</span>,<span class="hljs-number">12</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>,<span class="hljs-number">13</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>,<span class="hljs-number">15</span>,<span class="hljs-number">10</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">8</span>, <span class="hljs-number">6</span>,<br>  <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>,<span class="hljs-number">11</span>,<span class="hljs-number">10</span>,<span class="hljs-number">13</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>,<span class="hljs-number">15</span>, <span class="hljs-number">9</span>,<span class="hljs-number">12</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>,<span class="hljs-number">14</span>,<br> <span class="hljs-number">11</span>, <span class="hljs-number">8</span>,<span class="hljs-number">12</span>, <span class="hljs-number">7</span>, <span class="hljs-number">1</span>,<span class="hljs-number">14</span>, <span class="hljs-number">2</span>,<span class="hljs-number">13</span>, <span class="hljs-number">6</span>,<span class="hljs-number">15</span>, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>,<span class="hljs-number">10</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>,<br> <span class="hljs-comment">//S6</span><br> <span class="hljs-number">12</span>, <span class="hljs-number">1</span>,<span class="hljs-number">10</span>,<span class="hljs-number">15</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0</span>,<span class="hljs-number">13</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>,<span class="hljs-number">14</span>, <span class="hljs-number">7</span>, <span class="hljs-number">5</span>,<span class="hljs-number">11</span>,<br> <span class="hljs-number">10</span>,<span class="hljs-number">15</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">7</span>,<span class="hljs-number">12</span>, <span class="hljs-number">9</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>,<span class="hljs-number">13</span>,<span class="hljs-number">14</span>, <span class="hljs-number">0</span>,<span class="hljs-number">11</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>,<br>  <span class="hljs-number">9</span>,<span class="hljs-number">14</span>,<span class="hljs-number">15</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>,<span class="hljs-number">12</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>,<span class="hljs-number">10</span>, <span class="hljs-number">1</span>,<span class="hljs-number">13</span>,<span class="hljs-number">11</span>, <span class="hljs-number">6</span>,<br>  <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>,<span class="hljs-number">12</span>, <span class="hljs-number">9</span>, <span class="hljs-number">5</span>,<span class="hljs-number">15</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">14</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>,<span class="hljs-number">13</span>,<br> <span class="hljs-comment">//S7</span><br>  <span class="hljs-number">4</span>,<span class="hljs-number">11</span>, <span class="hljs-number">2</span>,<span class="hljs-number">14</span>,<span class="hljs-number">15</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>,<span class="hljs-number">13</span>, <span class="hljs-number">3</span>,<span class="hljs-number">12</span>, <span class="hljs-number">9</span>, <span class="hljs-number">7</span>, <span class="hljs-number">5</span>,<span class="hljs-number">10</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>,<br> <span class="hljs-number">13</span>, <span class="hljs-number">0</span>,<span class="hljs-number">11</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1</span>,<span class="hljs-number">10</span>,<span class="hljs-number">14</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>,<span class="hljs-number">12</span>, <span class="hljs-number">2</span>,<span class="hljs-number">15</span>, <span class="hljs-number">8</span>, <span class="hljs-number">6</span>,<br>  <span class="hljs-number">1</span>, <span class="hljs-number">4</span>,<span class="hljs-number">11</span>,<span class="hljs-number">13</span>,<span class="hljs-number">12</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>,<span class="hljs-number">14</span>,<span class="hljs-number">10</span>,<span class="hljs-number">15</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>,<br>  <span class="hljs-number">6</span>,<span class="hljs-number">11</span>,<span class="hljs-number">13</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>,<span class="hljs-number">10</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>,<span class="hljs-number">15</span>,<span class="hljs-number">14</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>,<span class="hljs-number">12</span>,<br> <span class="hljs-comment">//S8</span><br> <span class="hljs-number">13</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>,<span class="hljs-number">15</span>,<span class="hljs-number">11</span>, <span class="hljs-number">1</span>,<span class="hljs-number">10</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>,<span class="hljs-number">14</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>,<span class="hljs-number">12</span>, <span class="hljs-number">7</span>,<br>  <span class="hljs-number">1</span>,<span class="hljs-number">15</span>,<span class="hljs-number">13</span>, <span class="hljs-number">8</span>,<span class="hljs-number">10</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>,<span class="hljs-number">12</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>,<span class="hljs-number">11</span>, <span class="hljs-number">0</span>,<span class="hljs-number">14</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>,<br>  <span class="hljs-number">7</span>,<span class="hljs-number">11</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">9</span>,<span class="hljs-number">12</span>,<span class="hljs-number">14</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>,<span class="hljs-number">10</span>,<span class="hljs-number">13</span>,<span class="hljs-number">15</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>,<br>  <span class="hljs-number">2</span>, <span class="hljs-number">1</span>,<span class="hljs-number">14</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>,<span class="hljs-number">10</span>, <span class="hljs-number">8</span>,<span class="hljs-number">13</span>,<span class="hljs-number">15</span>,<span class="hljs-number">12</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>,<span class="hljs-number">11</span><br>&#125;;<br><br> <span class="hljs-comment">//P置换表</span><br><span class="hljs-type">uint32_t</span> PT[<span class="hljs-number">32</span>] = <br>&#123;<br><span class="hljs-number">16</span>, <span class="hljs-number">7</span>,<span class="hljs-number">20</span>,<span class="hljs-number">21</span>,<br><span class="hljs-number">29</span>,<span class="hljs-number">12</span>,<span class="hljs-number">28</span>,<span class="hljs-number">17</span>,<br> <span class="hljs-number">1</span>,<span class="hljs-number">15</span>,<span class="hljs-number">23</span>,<span class="hljs-number">26</span>,<br> <span class="hljs-number">5</span>,<span class="hljs-number">18</span>,<span class="hljs-number">31</span>,<span class="hljs-number">10</span>,<br> <span class="hljs-number">2</span>, <span class="hljs-number">8</span>,<span class="hljs-number">24</span>,<span class="hljs-number">14</span>,<br><span class="hljs-number">32</span>,<span class="hljs-number">27</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>,<br><span class="hljs-number">19</span>,<span class="hljs-number">13</span>,<span class="hljs-number">30</span>, <span class="hljs-number">6</span>,<br><span class="hljs-number">22</span>,<span class="hljs-number">11</span>, <span class="hljs-number">4</span>,<span class="hljs-number">25</span><br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>密码学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DES</tag>
      
      <tag>分组密码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPU与程序执行</title>
    <link href="/2023/01/10/CPU%E4%B8%8E%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/"/>
    <url>/2023/01/10/CPU%E4%B8%8E%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="CPU与程序执行"><a href="#CPU与程序执行" class="headerlink" title="CPU与程序执行"></a>CPU与程序执行</h1><h2 id="程序执行过程"><a href="#程序执行过程" class="headerlink" title="程序执行过程"></a>程序执行过程</h2><ol><li>取指令。将要执行的指令存放在PC中，取出的指令存放到IR中</li><li>译码。不同指令被翻译成不同的控制信号</li><li>计算源操作数地址并取操作数。</li><li>执行数据操作。在操作元件中对取出的操作数进行计算</li><li>目的操作数地址计算并存结果。</li><li>指令地址计算并将其送PC。如果是定长指令字，如MIPS指令集，则在第一步取指令的同时计算出下一条指令地址并送PC。此时跳过该步</li></ol><h2 id="CPU基本功能和组成"><a href="#CPU基本功能和组成" class="headerlink" title="CPU基本功能和组成"></a>CPU基本功能和组成</h2><p><img src="/2023/01/10/CPU%E4%B8%8E%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/image-20211215190616698.png" alt="image-20211215190616698"></p><ol><li>程序计数器（PC）</li><li>指令寄存器（IR）</li><li>指令译码器（ID）</li><li>启停控制逻辑。脉冲源产生时钟脉冲控制时序信号的发生和停止，实现对机器的启动与停机</li><li>时序信号产生部件。以时钟脉冲为基础，产生不同指令对应的周期、节拍、工作脉冲等时序信号，实现机器指令执行过程中的时序控制</li><li>操作控制信号形成部件。综合以上信号标志形成不同的控制信号，如读数据或者写数据</li><li>总线控制逻辑。实现对总线传输的控制，包括对数据和地址信息的缓冲和控制</li></ol><h2 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h2><p>内部异常：由CPU内部的异常引起的意外事件。如除0，断点，堆栈溢出，缺页</p><p>外部中断：外设完成任务或者发生某些特殊事件。每条指令执行完成后，CPU会主动查询有没有中断请求，如果有，则将下一条地址作为断点保存，然后转到用来处理相应中断事件的“中断服务程序“执行。</p><p>中断和异常都会破坏流水线的执行，造成流水线堵塞</p><h2 id="数据通路基本结构和工作原理"><a href="#数据通路基本结构和工作原理" class="headerlink" title="数据通路基本结构和工作原理"></a>数据通路基本结构和工作原理</h2><p>数据通路：指令执行过程中数据所经过的路径</p><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>组合逻辑元件（操作元件）：</p><p>如MUX（多路选择器），Adder（加法器），ALU（算数逻辑部件），Decoder（译码器）</p><p>时序逻辑元件（存储元件）：</p><p>具有存储功能，如D触发器，输入状态在时钟控制下被写入到电路中，并保持电路的输出值不变，直到下一个时钟到达。输入端状态由时钟决定何时被写入</p><p><img src="/2023/01/10/CPU%E4%B8%8E%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/image-20211215191928041.png" alt="image-20211215191928041"></p><p>输入状态改变发生在时钟下降沿，需要经过建立时间和保持时间</p><p>输出端状态改变需要经过Clock-to-Q，即锁存延迟。该时间远小于保存时间</p><p>寄存器是状态存储元件，由n个D触发器组成一个n位寄存器</p><h3 id="数据通路的时序控制"><a href="#数据通路的时序控制" class="headerlink" title="数据通路的时序控制"></a>数据通路的时序控制</h3><p>现代计算机中，定时信号就是时钟信号，一个时钟周期就是一个节拍。</p><p>只有状态元件能够存储信息，所有操作元件都必须从状态元件接收输入，并将输出写入状态元件中。而所有状态元件在同一个时钟信号控制下写入信息。</p><p>数据通路的时钟周期：Cycle Time &#x3D; Clk-to-Q + Longest Delay + 建立时间 + 时钟偏移（可参考上图理解）</p><h2 id="流水线指令执行"><a href="#流水线指令执行" class="headerlink" title="流水线指令执行"></a>流水线指令执行</h2><p>理想情况下，每个时钟周期都有一条指令进入流水线</p><p><img src="/2023/01/10/CPU%E4%B8%8E%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/image-20211215193611503.png" alt="image-20211215193611503"></p><p>流水线数据通路设计准则：指令流水段个数以最复杂指令所用的功能段个数为准；流水段的长度以最复杂功能段的操作所用时间为准</p><p>适合流水线的指令集特征：</p><ol><li>指令长度应该尽量一致。有利于取指和译码</li><li>指令格式尽量规整，保证源操作数寄存器的位置相同，如都在指令的第25<del>21位和20</del>16位</li><li>采用load&#x2F;store风格，即只有这两个指令和存储器交互</li><li>数据和指令要对齐存放。有利于减少访存次数，因为CPU每次取数据是按照对齐位来取的</li></ol><h2 id="CISC指令集"><a href="#CISC指令集" class="headerlink" title="CISC指令集"></a>CISC指令集</h2><p>复杂指令集，主要被Intel使用，缺点是不适用指令流水线，需要翻译成多个RISC的微操作</p><h2 id="RISC指令集"><a href="#RISC指令集" class="headerlink" title="RISC指令集"></a>RISC指令集</h2><p>精简指令集，多用在嵌入式设备和移动端设备，采用流水线的方式执行指令</p><h2 id="指令流水线的实现"><a href="#指令流水线的实现" class="headerlink" title="指令流水线的实现"></a>指令流水线的实现</h2><p><img src="/2023/01/10/CPU%E4%B8%8E%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/image-20211215194427866.png" alt="image-20211215194427866"></p><p>流水线冒险：一些情况可能使得流水线无法正确、按时执行后续指令，从而引起流水线阻塞或者停顿</p><ol><li>结构冒险。硬件资源冲突，同一个部件被多个指令使用，可以通过引入告诉缓冲存储器（cache）避免访存冲突</li><li>数据冒险。后面指令用到前面指令的运算结果时，前面指令的结果还没有产生。可以添加nop延迟指令执行</li><li>控制冒险。指令执行顺序被改变，最常见的分支跳转</li></ol><p>高级流水线技术：</p><p>超流水线：增加流水线级数</p><p>多发射流水线：同时启动多条指令</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Cpp-类型转换</title>
    <link href="/2023/01/10/Cpp-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <url>/2023/01/10/Cpp-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="Cpp-类型转换"><a href="#Cpp-类型转换" class="headerlink" title="Cpp-类型转换"></a>Cpp-类型转换</h1><p>static_cast: 安全转换，可用于子类向基类的显示转换，是编译期转换，没有运行时类型检查</p><p>dynamic_cast: 基类向派生类的安全转换，只能对指针或引用进行转换，是运行时转换</p><p>reinterpret_cast: 一些危险转换，只是将二进制的值拷贝过去，没有考虑类型之间的关系</p><p>const_cast: 去掉const</p><p>举例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// ptrTableA(8byte) | a(4byte) | NONE(4byte)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">PrintA</span><span class="hljs-params">()</span></span>&#123;cout &lt;&lt; <span class="hljs-string">&quot;A\n&quot;</span>;&#125;<br>&#125;;<br><br><span class="hljs-comment">// ptrTableB(8bype) | b(4byte) | NONE(4byte)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> b;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">PrintB</span><span class="hljs-params">()</span></span>&#123;cout &lt;&lt; <span class="hljs-string">&quot;B\n&quot;</span>;&#125;<br>&#125;;<br><br><span class="hljs-comment">// ptrTableAC(8byte) | a(4byte) | NONE(4byte) | ptrTableBC(8bype) | b(4byte) | NONE(4byte)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>:<span class="hljs-keyword">public</span> A, <span class="hljs-keyword">public</span> B<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">PrintA</span><span class="hljs-params">()</span></span>&#123;cout &lt;&lt; <span class="hljs-string">&quot;AC\n&quot;</span>;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">PrintB</span><span class="hljs-params">()</span></span>&#123;cout &lt;&lt; <span class="hljs-string">&quot;BC\n&quot;</span>;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    C c;<br>    <span class="hljs-comment">// 前两个值相同，后一个会偏移16</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p %p %p\n&quot;</span>, &amp;c, <span class="hljs-built_in">reinterpret_cast</span>&lt;B*&gt;(&amp;c), <span class="hljs-built_in">static_cast</span>&lt;B*&gt;(&amp;c));<br>    <br>    C* pc = <span class="hljs-keyword">new</span> C;<br>    pc-&gt;a = <span class="hljs-number">1</span>;<br>    pc-&gt;b = <span class="hljs-number">2</span>;<br>    cout &lt;&lt; <span class="hljs-built_in">reinterpret_cast</span>&lt;A*&gt;(pc)-&gt;a &lt;&lt; endl;    <span class="hljs-comment">// 1, offset=4</span><br>    cout &lt;&lt; <span class="hljs-built_in">reinterpret_cast</span>&lt;B*&gt;(pc)-&gt;b &lt;&lt; endl;    <span class="hljs-comment">// 1, offset=4</span><br>    <span class="hljs-built_in">reinterpret_cast</span>&lt;A*&gt;(pc)-&gt;<span class="hljs-built_in">PrintA</span>();             <span class="hljs-comment">// AC, use ptrTableAC</span><br>    <span class="hljs-built_in">reinterpret_cast</span>&lt;B*&gt;(pc)-&gt;<span class="hljs-built_in">PrintB</span>();             <span class="hljs-comment">// AC, use ptrTableAC</span><br>    <br>    cout &lt;&lt; <span class="hljs-built_in">dynamic_cast</span>&lt;A*&gt;(pc)-&gt;a &lt;&lt; endl;        <span class="hljs-comment">// 1, offset=4</span><br>    cout &lt;&lt; <span class="hljs-built_in">dynamic_cast</span>&lt;B*&gt;(pc)-&gt;b &lt;&lt; endl;        <span class="hljs-comment">// 2, offset=16</span><br>    <span class="hljs-built_in">dynamic_cast</span>&lt;A*&gt;(pc)-&gt;<span class="hljs-built_in">PrintA</span>();                 <span class="hljs-comment">// AC, use ptrTableAC</span><br>    <span class="hljs-built_in">dynamic_cast</span>&lt;B*&gt;(pc)-&gt;<span class="hljs-built_in">PrintB</span>();                 <span class="hljs-comment">// BC, use ptrTableBC</span><br>    <br>    cout &lt;&lt; <span class="hljs-built_in">static_cast</span>&lt;A*&gt;(pc)-&gt;a &lt;&lt; endl;         <span class="hljs-comment">// 1, offset=4</span><br>    cout &lt;&lt; <span class="hljs-built_in">static_cast</span>&lt;B*&gt;(pc)-&gt;b &lt;&lt; endl;         <span class="hljs-comment">// 2, offset=16</span><br>    <span class="hljs-built_in">static_cast</span>&lt;A*&gt;(pc)-&gt;<span class="hljs-built_in">PrintA</span>();                  <span class="hljs-comment">// AC, use ptrTableAC</span><br>    <span class="hljs-built_in">static_cast</span>&lt;B*&gt;(pc)-&gt;<span class="hljs-built_in">PrintB</span>();                  <span class="hljs-comment">// BC, use ptrTableBC</span><br><br>    A* pa = <span class="hljs-keyword">new</span> A;<br>    pa-&gt;a = <span class="hljs-number">3</span>;<br>    cout &lt;&lt; <span class="hljs-built_in">reinterpret_cast</span>&lt;C*&gt;(pa)-&gt;a &lt;&lt; endl;    <span class="hljs-comment">// 3, offset=4</span><br>    cout &lt;&lt; <span class="hljs-built_in">reinterpret_cast</span>&lt;C*&gt;(pa)-&gt;b &lt;&lt; endl;    <span class="hljs-comment">// ?, offset=16</span><br>    <span class="hljs-built_in">reinterpret_cast</span>&lt;C*&gt;(pa)-&gt;<span class="hljs-built_in">PrintA</span>();             <span class="hljs-comment">// A, use ptrTableA</span><br>    <span class="hljs-built_in">reinterpret_cast</span>&lt;C*&gt;(pa)-&gt;<span class="hljs-built_in">PrintB</span>();             <span class="hljs-comment">// invalid access</span><br>    <br>    cout &lt;&lt; <span class="hljs-built_in">dynamic_cast</span>&lt;C*&gt;(pa)-&gt;a &lt;&lt; endl;        <span class="hljs-comment">// error</span><br>    cout &lt;&lt; <span class="hljs-built_in">dynamic_cast</span>&lt;C*&gt;(pa)-&gt;b &lt;&lt; endl;        <span class="hljs-comment">// error</span><br>    <span class="hljs-built_in">dynamic_cast</span>&lt;C*&gt;(pa)-&gt;<span class="hljs-built_in">PrintA</span>();                 <span class="hljs-comment">// error</span><br>    <span class="hljs-built_in">dynamic_cast</span>&lt;C*&gt;(pa)-&gt;<span class="hljs-built_in">PrintB</span>();                 <span class="hljs-comment">// error</span><br>    <br>    cout &lt;&lt; <span class="hljs-built_in">static_cast</span>&lt;C*&gt;(pa)-&gt;a &lt;&lt; endl;         <span class="hljs-comment">// 3, offset=4</span><br>    cout &lt;&lt; <span class="hljs-built_in">static_cast</span>&lt;C*&gt;(pa)-&gt;b &lt;&lt; endl;         <span class="hljs-comment">// ?, offset=16</span><br>    <span class="hljs-built_in">static_cast</span>&lt;C*&gt;(pa)-&gt;<span class="hljs-built_in">PrintA</span>();                  <span class="hljs-comment">// A, use ptrTableA</span><br>    <span class="hljs-built_in">static_cast</span>&lt;C*&gt;(pa)-&gt;<span class="hljs-built_in">PrintB</span>();                  <span class="hljs-comment">// invalid access</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Cpp-并发编程</title>
    <link href="/2023/01/10/Cpp-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <url>/2023/01/10/Cpp-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Cpp-并发编程"><a href="#Cpp-并发编程" class="headerlink" title="Cpp-并发编程"></a>Cpp-并发编程</h1><p>相关代码和测试：<a href="https://github.com/olleh-dlrow/ConcurrencyLearning">olleh-dlrow&#x2F;ConcurrencyLearning: source and test for concurrency learning. (github.com)</a></p><h2 id="并发概念"><a href="#并发概念" class="headerlink" title="并发概念"></a>并发概念</h2><p>在单个系统里同时执行多个独立的任务，而非顺序执行一些活动。这里需要强调的是任务的独立性，即任务之间两两不存在前后依赖关系，对于单线程程序而言，并发实际是轮流调度任务的过程，对于多线程程序而言，并发能够做到真正的并行</p><p><img src="/2023/01/10/Cpp-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221130104736057.png" alt="image-20221130104736057"></p><h3 id="选择并发的理由"><a href="#选择并发的理由" class="headerlink" title="选择并发的理由"></a>选择并发的理由</h3><h4 id="分离关注点"><a href="#分离关注点" class="headerlink" title="分离关注点"></a>分离关注点</h4><p>将相关的代码与无关的代码分离，可以使得程序更容易理解和调试</p><p>例如，播放器的播放模块和用户操作模块之间可以分离，后者可以使用一个单独的线程来监听用户的输入，进而控制播放模块的播放状态</p><h4 id="提升性能"><a href="#提升性能" class="headerlink" title="提升性能"></a>提升性能</h4><ul><li>任务并行：将单个任务分成几个部分，且各自并行运行，从而降低总运行时间，这要求任务之间没有依赖</li><li>数据并行：每个线程在不同的数据部分执行相同的操作</li></ul><p>并不是具有这样的场景就要使用并发，如果多线程创建、切换、调度、终止的代价大于单线程的执行代价，则不适宜强行使用并发</p><h2 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h2><p><a href="https://en.cppreference.com/w/cpp/thread/thread">std::thread - cppreference.com</a></p><h2 id="共享数据"><a href="#共享数据" class="headerlink" title="共享数据"></a>共享数据</h2><h3 id="条件竞争"><a href="#条件竞争" class="headerlink" title="条件竞争"></a>条件竞争</h3><p>不变量(invariants)可以理解为数据结构中的一些关键变量，这些变量在操作前后是稳定不变的；比如，“变量包含列表中的项数”。不变量通常会在一次更新中被破坏，特别是比较复杂的数据结构，或者一次更新就要改动很大的数据结构</p><p>以双链表为例，双链表中每个节点都有一个指针指向列表中下一个节点，还有一个指针指向前一个节点。其中不变量就是节点A中指向“下一个”节点B的指针，还有前向指针。为了从列表中删除一个节点，其两边节点的指针都需要更新。当其中一边更新完成时，不变量就被破坏了，直到另一边也完成更新；在两边都完成更新后，不变量就又稳定了。</p><p>并发中竞争条件的形成，取决于一个以上线程的相对执行顺序，每个线程都抢着完成自己的任务。恶性条件竞争通常发生于完成对多于一个的数据块的修改时。例如对两个连接指针的修改，因为操作要访问两个独立的数据块，独立的指令将会对数据块将进行修改，并且其中一个线程可能正在进行时，另一个线程就对数据块进行了访问。</p><p>条件竞争往往很难复现，因为他通常是时间敏感的。程序以调试模式运行时，它们常会完全消失，因为调试模式会影响程序的执行时间</p><p>避免方法：</p><ul><li>对数据结构采用某种保护机制，确保只有进行修改的线程才能看到不变量被破坏时的中间状态，如使用<strong>互斥锁</strong></li><li>对数据结构和不变量的设计进行修改，修改完的结构必须能完成一系列不可分割的变化，也就是保证每个不变量保持稳定的状态，这就是所谓的<strong>无锁编程</strong></li><li>使用事务的方式去处理数据结构的更新</li></ul><h3 id="使用互斥量保护数据"><a href="#使用互斥量保护数据" class="headerlink" title="使用互斥量保护数据"></a>使用互斥量保护数据</h3><p><a href="https://en.cppreference.com/w/cpp/thread/mutex">std::mutex - cppreference.com</a></p><p><a href="https://en.cppreference.com/w/cpp/thread/lock_guard">std::lock_guard - cppreference.com</a></p><p><a href="https://en.cppreference.com/w/cpp/thread/unique_lock">std::unique_lock - cppreference.com</a></p><p>注意：切勿将受保护数据的指针或引用传递到互斥锁作用域之外，无论是函数返回值，还是存储在外部可见内存，亦或是以参数的形式传递到用户提供的函数中去</p><h3 id="定位接口之间的条件竞争"><a href="#定位接口之间的条件竞争" class="headerlink" title="定位接口之间的条件竞争"></a>定位接口之间的条件竞争</h3><p>如果某些接口之间存在条件竞争，则它们可以使用同一个互斥量来进行管理，例如<code>stack</code>的接口：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">push</span>();<br><span class="hljs-built_in">pop</span>();<br><span class="hljs-built_in">empty</span>();<br><span class="hljs-built_in">top</span>();<br><span class="hljs-built_in">size</span>();<br></code></pre></td></tr></table></figure><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>对于多线程程序而言，线程之间需要对锁产生竞争：一对线程需要对他们所有的互斥量做一些操作，其中每个线程都有一个互斥量，且等待另一个解锁。这样没有线程能工作，因为他们都在等待对方释放互斥量</p><p>避免死锁：</p><ul><li>让两个互斥量总是以相同的顺序上锁</li><li>使用锁的层次结构，锁的层次的意义在于提供对运行时约定是否被坚持的检查，当代码试图对一个互斥量上锁，在该层锁已被低层持有时，上锁是不允许的</li><li>使用递归锁</li><li>避免嵌套锁</li><li>避免在持有锁时调用用户提供的代码。该代码中可能也进行了上锁的操作</li></ul><h3 id="锁的粒度"><a href="#锁的粒度" class="headerlink" title="锁的粒度"></a>锁的粒度</h3><p>锁的粒度是一个摆手术语(hand-waving term)，用来描述通过一个锁保护着的数据量大小。一个细粒度锁(a fine-grained lock)能够保护较小的数据量，一个粗粒度锁(a coarse grained lock)能够保护较多的数据量。</p><h3 id="保护共享数据的初始化过程"><a href="#保护共享数据的初始化过程" class="headerlink" title="保护共享数据的初始化过程"></a>保护共享数据的初始化过程</h3><p>双重检查锁出现的问题：</p><p>假设有一段代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::shared_ptr&lt;some_resource&gt; resource_ptr;<br>std::mutex resource_mutex;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">undefined_behaviour_with_double_checked_locking</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!resource_ptr) &#123; <span class="hljs-comment">// 1</span><br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(resource_mutex)</span></span>; <span class="hljs-comment">// 2</span><br>        <span class="hljs-keyword">if</span>(!resource_ptr) &#123; <span class="hljs-comment">// 3</span><br>            resource_ptr.<span class="hljs-built_in">reset</span>( <span class="hljs-comment">// 4: initialize ptr, but not finish new resource</span><br>                <span class="hljs-keyword">new</span> some_resource<span class="hljs-comment">// 5</span><br>            ); <span class="hljs-comment">// 6</span><br>        &#125;<br>    &#125;<br>    resource_ptr-&gt;<span class="hljs-built_in">do_something</span>(); <span class="hljs-comment">// 7</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里存在潜在的条件竞争，假设有两个线程t1, t2，他们的执行顺序如下：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">t1<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>)</span> -&gt;</span> t1<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">2</span>)</span> -&gt;</span> t2<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>)</span> -&gt;</span> t2<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">2</span>)</span> -&gt;</span> t2<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">3</span>)</span> -&gt;</span> t2(<span class="hljs-number">4</span>)此时resource_ptr已经被赋值 -&gt; t1(<span class="hljs-number">3</span>) <span class="hljs-literal">false</span> -&gt; t1(<span class="hljs-number">7</span>) ERROR!!!<br></code></pre></td></tr></table></figure><p>可以看到，这种执行顺序下的代码会出问题，解决办法是，使用<code>std::call_once</code>或者使用静态局部变量</p><h2 id="同步并发操作"><a href="#同步并发操作" class="headerlink" title="同步并发操作"></a>同步并发操作</h2><p><a href="https://en.cppreference.com/w/cpp/thread/condition_variable">std::condition_variable - cppreference.com</a></p><p><a href="https://en.cppreference.com/w/cpp/thread/future">std::future - cppreference.com</a></p><p><a href="https://en.cppreference.com/w/cpp/thread/promise">std::promise - cppreference.com</a></p><p><a href="https://en.cppreference.com/w/cpp/thread/async">std::async - cppreference.com</a></p><p><a href="https://en.cppreference.com/w/cpp/thread/packaged_task">std::packaged_task - cppreference.com</a></p><p>待补充</p><h2 id="C-内存模型和原子操作"><a href="#C-内存模型和原子操作" class="headerlink" title="C++内存模型和原子操作"></a>C++内存模型和原子操作</h2><p><a href="https://en.cppreference.com/w/cpp/atomic/atomic">std::atomic - cppreference.com</a></p><p>内存模型参考：</p><p><a href="https://www.codedump.info/post/20191214-cxx11-memory-model-1/">C++11中的内存模型上篇 - 内存模型基础 - codedump的网络日志</a></p><p><a href="https://www.codedump.info/post/20191214-cxx11-memory-model-2/">C++11中的内存模型下篇 - C++11支持的几种内存模型 - codedump的网络日志</a></p><p>待补充</p><h2 id="基于锁的并发数据结构设计"><a href="#基于锁的并发数据结构设计" class="headerlink" title="基于锁的并发数据结构设计"></a>基于锁的并发数据结构设计</h2><p>设计指导与建议：</p><ul><li>确保无线程能够看到修改数据结构的“不变量”时的状态</li><li>小心会引起条件竞争的接口，提供完整操作的函数，而非操作步骤</li><li>注意数据结构的行为是否会产生异常，从而确保“不变量”的状态</li><li>将死锁的概率降到最低。使用数据结构时，需要限制锁的范围，避免嵌套锁的存在</li></ul><p>最终目的：如何让序列化访问最小化，让真实并发最大化？</p><h3 id="线程安全栈"><a href="#线程安全栈" class="headerlink" title="线程安全栈"></a>线程安全栈</h3><p>栈的操作之间几乎都会涉及到数据竞争或条件竞争，因此可以使用一个互斥量来管理临界区的使用，即栈顶元素，栈的大小</p><h3 id="线程安全队列"><a href="#线程安全队列" class="headerlink" title="线程安全队列"></a>线程安全队列</h3><p>可以分为粗粒度锁和细粒度锁</p><p>如果使用粗粒度锁，则入队和出队都会锁住队列本身，在出队时，有两种设计的策略：</p><ul><li>判断队列是否为空，然后决定是否弹出，并返回状态</li><li>如果队列为空，使用条件变量等待，而在入队时再唤醒一个等待的线程</li></ul><p>如果使用细粒度锁，则可以为入队和出队分别设置互斥量，只有在判断队首和队尾的位置时需要短时间的互斥，其它情况下，入队和出队操作能够独立进行</p><h3 id="线程安全查询表"><a href="#线程安全查询表" class="headerlink" title="线程安全查询表"></a>线程安全查询表</h3><p>使用桶作为数组，桶内使用链表存储键值对，每个桶带有一个共享锁，控制链表的互斥写访问</p><p>对于查询操作，使用<code>shared_lock</code>进行多线程并行查询</p><p>对于增删操作，使用<code>unique_lock</code>保证访问的互斥性</p><h3 id="线程安全链表"><a href="#线程安全链表" class="headerlink" title="线程安全链表"></a>线程安全链表</h3><p>对于每个结点，都持有一个互斥锁，在操作时，对持有的节点群进行上锁，并且在移动到下一个节点的时，对当前节点进行释放，类似于接力棒行为</p><p>具体的实现逻辑见项目源代码</p><h2 id="无锁并发数据结构设计"><a href="#无锁并发数据结构设计" class="headerlink" title="无锁并发数据结构设计"></a>无锁并发数据结构设计</h2><p>待补充</p><h2 id="并发代码设计"><a href="#并发代码设计" class="headerlink" title="并发代码设计"></a>并发代码设计</h2><h3 id="线程间划分工作"><a href="#线程间划分工作" class="headerlink" title="线程间划分工作"></a>线程间划分工作</h3><h4 id="线程处理前对数据进行划分"><a href="#线程处理前对数据进行划分" class="headerlink" title="线程处理前对数据进行划分"></a>线程处理前对数据进行划分</h4><p>根据每个线程处理的最小数目、最大线程数目来决定每个线程处理多少数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> min_per_thread=<span class="hljs-number">25</span>;<span class="hljs-comment">// 每个线程处理的最小数目</span><br><span class="hljs-type">int</span> max_threads=<br>    (length+min_per_thread<span class="hljs-number">-1</span>)/min_per_thread; <span class="hljs-comment">// 最多需要多少线程</span><br><br><span class="hljs-type">int</span> hardware_threads=<br>    std::thread::<span class="hljs-built_in">hardware_concurrency</span>(); <span class="hljs-comment">// 当前硬件线程数</span><br><br><span class="hljs-type">int</span> num_threads=<br>    std::<span class="hljs-built_in">min</span>(hardware_threads, max_threads); <span class="hljs-comment">// 实际需要的线程数</span><br><br><span class="hljs-type">int</span> block_size=length/num_threads; <span class="hljs-comment">// 前num_threads-1个线程处理的数据量</span><br><br>Iterator block_start=first;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;(num_threads<span class="hljs-number">-1</span>);++i)<span class="hljs-comment">// 计算数据范围，分配任务给每个线程</span><br>&#123;<br>    Iterator block_end=block_start;<br>    std::<span class="hljs-built_in">advance</span>(block_end,block_size);<br>    threads[i]=std::<span class="hljs-built_in">thread</span>(<br>        run_task,<br>        block_start,block_end, ...);<br>    block_start=block_end;<br>&#125;<br><span class="hljs-built_in">run_task</span>(block_start, last, ...);<span class="hljs-comment">// 处理剩下的数据</span><br></code></pre></td></tr></table></figure><p>实际测试下来，该方法具有最好的性能表现，大概是因为合理的划分减少了许多线程调度的执行时间，并且每个线程需要处理的数据量也是比较均匀的</p><h4 id="递归划分"><a href="#递归划分" class="headerlink" title="递归划分"></a>递归划分</h4><p>将任务划分成2部分，前一部分使用新的线程递归调用，后一部分使用当前线程运算。快速排序就可以使用这个方法</p><p>缺点：当前线程依赖新线程的计算结果，因此可能造成死锁</p><p>可以使用<code>std::async</code>创建新任务，由系统内部来负责线程之间的调度。但是，经过测试，如果递归太深，那么需要大量的线程调度和让权等待，此时<code>std::async</code>性能较差，也可能出现死锁的情况（这个点不太确定，但确实有些数据在有限时间内是没有跑出来的）</p><h4 id="通过任务类型划分工作"><a href="#通过任务类型划分工作" class="headerlink" title="通过任务类型划分工作"></a>通过任务类型划分工作</h4><p>将任务划分成操作序列，每个子任务交给专门的线程执行，尽管子任务之间可能依然具有依赖关系，但是在处理多个任务时，可以形成流水线进行工作，避免核心空置</p><h3 id="影响并发代码性能的因素"><a href="#影响并发代码性能的因素" class="headerlink" title="影响并发代码性能的因素"></a>影响并发代码性能的因素</h3><h4 id="处理器数量"><a href="#处理器数量" class="headerlink" title="处理器数量"></a>处理器数量</h4><p>显然，并发工作需要在处理器数量和每个处理器的任务量之间寻找最佳平衡点</p><h4 id="数据争用和乒乓缓存"><a href="#数据争用和乒乓缓存" class="headerlink" title="数据争用和乒乓缓存"></a>数据争用和乒乓缓存</h4><p>当两个线程并发的在不同处理器上执行，并且对同一数据进行读取，通常不会出现问题；因为数据将会拷贝到每个线程的缓存中，并且让两个处理器同时进行处理。不过，当有线程对数据进行修改的时候，这个修改需要更新到其他核芯的缓存中去，就要耗费一定的时间。根据线程的操作性质，以及使用到的内存序，这样的修改可能会让第二个处理器停下来，等待硬件内存更新缓存中的数据。根据等待时间可以简单地将情况分为<strong>高竞争</strong>和<strong>低竞争</strong></p><p>如果某个数据在每个缓存中传递若干次，那么这种情况叫做<strong>乒乓缓存</strong>。当一个处理器因为等待缓存转移而停止运行时，这个处理器就不能做任何事情</p><h4 id="伪共享"><a href="#伪共享" class="headerlink" title="伪共享"></a>伪共享</h4><p>同一个缓存行中可以存储多个数据项。因此，即使每个线程都能对数据中的成员进行访问，硬件缓存还是会产生乒乓缓存。缓存行是共享的(即使没有数据存在)，因此使用伪共享来称呼这种方式</p><p>或者说，单个线程修改的内存单位小于缓存切换的单位（一个缓存行），导致多个线程共享同一块缓存行</p><h4 id="超额认购和频繁的任务切换"><a href="#超额认购和频繁的任务切换" class="headerlink" title="超额认购和频繁的任务切换"></a>超额认购和频繁的任务切换</h4><p>任务分配不均导致某个线程任务繁重或者大量线程频繁切换会严重影响性能</p><h3 id="数据结构中的数据访问模式"><a href="#数据结构中的数据访问模式" class="headerlink" title="数据结构中的数据访问模式"></a>数据结构中的数据访问模式</h3><ul><li>尝试调整数据在线程间的分布，就能让同一线程中的数据紧密联系在一起</li><li>尝试减少线程上所需的数据量</li><li>尝试让不同线程访问不同的存储位置，以避免伪共享</li></ul><h3 id="设计并发代码的注意事项"><a href="#设计并发代码的注意事项" class="headerlink" title="设计并发代码的注意事项"></a>设计并发代码的注意事项</h3><h4 id="并行算法中的异常安全"><a href="#并行算法中的异常安全" class="headerlink" title="并行算法中的异常安全"></a>并行算法中的异常安全</h4><p>在并行算法中很多操作要运行在独立的线程上。这种情况下，异常就不再允许被传播，因为这将会使调用堆栈出现问题。如果一个函数在创建一个新线程后带着异常退出，那么这个应用将会终止</p><p>解决办法：</p><ul><li>使用<code>std::future</code>存储新线程的异常，然后在主线程中处理</li><li>当生成第一个新线程和当所有线程都汇入主线程时抛出异常；这会让线程产生泄露。最简单的方法就是捕获所有抛出的线程，汇入的线程依旧是joinable()的，并且会再次抛出异常</li></ul><h3 id="使用并发提高响应能力"><a href="#使用并发提高响应能力" class="headerlink" title="使用并发提高响应能力"></a>使用并发提高响应能力</h3><p>假设有如下事件驱动型代码框架：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>    event_data event = <span class="hljs-built_in">get_event</span>();<br>    <span class="hljs-keyword">if</span>(event.type == QUIT) &#123;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-built_in">process</span>(event);<br>&#125;<br></code></pre></td></tr></table></figure><p>为了确保用户输入被及时的处理，无论应时在做些什么，get_event()和process()必须以合理的频率调用。这就意味着任务要被周期性的悬挂，并且返回到事件循环中，get_event()&#x2F;process()必须在一个合适地方进行调用。每个选项的复杂程度取决于任务的实现方式。</p><p>通过使用并发分离关注，可以将一个很长的任务交给一个全新的线程，并且留下一个专用的GUI线程来处理这些事件。线程可以通过简单的机制进行通讯，而不是将事件处理代码和任务代码混在一起。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::thread task_thread;<br><span class="hljs-function">std::atomic&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">task_cancelled</span><span class="hljs-params">(<span class="hljs-literal">false</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">gui_thread</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>    &#123;<br>        event_data event=<span class="hljs-built_in">get_event</span>();<br>        <span class="hljs-keyword">if</span>(event.type==quit)<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-built_in">process</span>(event);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">task</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">task_complete</span>() &amp;&amp; !task_cancelled)<br>    &#123;<br>        <span class="hljs-built_in">do_next_operation</span>();<br>    &#125;<br>    <span class="hljs-keyword">if</span>(task_cancelled)<br>    &#123;<br>        <span class="hljs-built_in">perform_cleanup</span>();<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">post_gui_event</span>(task_complete);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(event_data <span class="hljs-type">const</span>&amp; event)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">switch</span>(event.type)<br>    &#123;<br>    <span class="hljs-keyword">case</span> start_task:<br>        task_cancelled=<span class="hljs-literal">false</span>;<br>        task_thread=std::<span class="hljs-built_in">thread</span>(task);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> stop_task:<br>        task_cancelled=<span class="hljs-literal">true</span>;<br>        task_thread.<span class="hljs-built_in">join</span>();<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> task_complete:<br>        task_thread.<span class="hljs-built_in">join</span>();<br>        <span class="hljs-built_in">display_results</span>();<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>通过这种方式对关注进行分离，用户线程将总能及时的对事件进行响应，及时完成任务需要花费很长时间。使用应用的时候，响应事件通常也是影响用户体验的重要一点，无论是特定操作被不恰当的执行(无论是什么操作)，应用都会被完全锁住。通过使用专门的事件处理线程，GUI就能处理GUI指定的信息了(比如对于调整窗口的大小或颜色)，而不需要中断处理器，进行耗时的处理；同时，还能向长期任务传递相关的信息</p><h3 id="在实践中设计并发代码"><a href="#在实践中设计并发代码" class="headerlink" title="在实践中设计并发代码"></a>在实践中设计并发代码</h3><h4 id="并行实现std-for-each"><a href="#并行实现std-for-each" class="headerlink" title="并行实现std::for_each"></a>并行实现<code>std::for_each</code></h4><p>使用数据划分或者递归划分即可</p><h4 id="并行实现std-find"><a href="#并行实现std-find" class="headerlink" title="并行实现std::find"></a>并行实现<code>std::find</code></h4><p>划分方式同上，在某个线程找到结果后，需要通知其它线程不再查找，因此可以设置一个原子变量<code>std::atomic&lt;bool&gt; done</code>来进行同步。除此之外，还需要返回找到的迭代器，此时可以通过<code>std::promise</code>的<code>set_value</code>进行设置，需要注意的是，可能出现多个线程同时找到该值，然后同时设置的情况，所以需要<code>try catch</code>一下，详见源代码<code>ParallelAlgorithm.h</code></p><h4 id="并行实现std-partial-sum"><a href="#并行实现std-partial-sum" class="headerlink" title="并行实现std::partial_sum"></a>并行实现<code>std::partial_sum</code></h4><p>待补充</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>控制线程使用数量在合理范围内，在任务量不均匀时也能够合理调度，但是会增加调度时间</p><p>主要有以下几个注意点：</p><h3 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h3><p>主线程在初始化时创建足够的线程放到线程池中，使用时将任务提交到线程安全队列中，对于每个线程，其在循环中检查队列是否有任务，如果有则出队执行，否则让出下一个时间片。在主线程退出时，线程池需要通知所有线程退出循环，并将这些线程汇入主线程中</p><h3 id="等待-提交到线程池中的任务"><a href="#等待-提交到线程池中的任务" class="headerlink" title="等待 提交到线程池中的任务"></a>等待 提交到线程池中的任务</h3><p>上述线程池没有考虑不同参数的任务以及任务的返回时机和返回值，即不知道任务什么时候完成，使用如下策略处理这两个问题：</p><p>对于不同参数的任务，可以对任务进行一层封装，实现<code>FunctionWrapper&lt;FunctionType&gt;</code>，然后它们继承于同一个基类，这样就可以统一存储到任务队列中</p><p>对于返回值，可以使用<code>packaged_task + future</code>的方式获取返回值</p><h3 id="等待依赖任务"><a href="#等待依赖任务" class="headerlink" title="等待依赖任务"></a>等待依赖任务</h3><p>上述线程池的实现无法处理大量任务依赖，当线程池中的所有线程都在依赖其它任务完成时，这些剩下的任务无法再从线程池中获得线程，这种情况下就会出现死锁，例如大量数据的快速排序就可能出现这种情况</p><p>为了解决这个问题，可以让当前线程定期检查依赖线程是否完成任务，如果没有，则当前线程先到队列中取出任务执行，直到依赖线程完成任务，即不要让线程永久依赖等待</p><h3 id="避免队列中的任务竞争和窃取任务"><a href="#避免队列中的任务竞争和窃取任务" class="headerlink" title="避免队列中的任务竞争和窃取任务"></a>避免队列中的任务竞争和窃取任务</h3><p>所有线程都从一个队列中取任务，如果想要减轻该队列的压力，可以让每个线程都持有自己的队列，其它线程也可以窃取对方的任务，因此，每个线程都需要制定一个提取任务的规则，更多细节和实现见book</p><h2 id="并行算法"><a href="#并行算法" class="headerlink" title="并行算法"></a>并行算法</h2><p><a href="https://en.cppreference.com/w/cpp/algorithm/execution_policy_tag">std::execution::seq, std::execution::par, std::execution::par_unseq, std::execution::unseq - cppreference.com</a></p><h2 id="测试和调试多线程"><a href="#测试和调试多线程" class="headerlink" title="测试和调试多线程"></a>测试和调试多线程</h2><p>测试用例的设计：</p><ul><li>编写所有单线程测试用例，排除单线程下的各种错误</li><li>对各种因素进行排列组合后测试，有点类似于自变量求笛卡尔积，例如线程数（0，少于任务，多于任务，满载），任务数，容器的容量大小等</li></ul><p>需要考虑的因素：</p><ul><li>系统中是否有足够的处理器，能让每个线程运行在属于自己的处理器上</li><li>“多线程”是有多少个线程(3个，4个，还是1024个？)</li><li>测试需要运行在哪种处理器架构上</li><li>测试中如何对“同时”进行合理的安排</li></ul><p>构建多线程测试代码：</p><p>有些执行顺序的结果是我们比较关心的，并且在多线程环境下，我们能够推测出哪些结果是可以出现的，哪些不能</p><p>例如，对一个空队列同时push和pop，则可能出现2种情况：1. 队列不空，pop返回空 2. 队列空，pop返回不空，如果出现其它情况，则一定出现了条件竞争</p><p>如何保证push和pop同时执行？可以使用<code>std::promise + std::shared_future</code>来进行同步，在push和pop之前同时<code>wait</code>，然后在主线程中使用<code>set_value</code>同时唤醒两个线程，简单表示为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++">push_done=std::<span class="hljs-built_in">async</span>(std::launch::async,<br>                     [&amp;q,ready,&amp;push_ready]()<br>                     &#123;<br>                         push_ready.<span class="hljs-built_in">set_value</span>();<br>                         ready.<span class="hljs-built_in">wait</span>();<br>                         q.<span class="hljs-built_in">push</span>(<span class="hljs-number">42</span>);<br>                     &#125;<br>    );<br>pop_done=std::<span class="hljs-built_in">async</span>(std::launch::async,<br>                    [&amp;q,ready,&amp;pop_ready]()<br>                    &#123;<br>                        pop_ready.<span class="hljs-built_in">set_value</span>();<br>                        ready.<span class="hljs-built_in">wait</span>();<br>                        <span class="hljs-keyword">return</span> q.<span class="hljs-built_in">pop</span>();<br>                    &#125;<br>    );<br>push_ready.<span class="hljs-built_in">get_future</span>().<span class="hljs-built_in">wait</span>();<br>pop_ready.<span class="hljs-built_in">get_future</span>().<span class="hljs-built_in">wait</span>();<br>go.<span class="hljs-built_in">set_value</span>();<br><br>push_done.<span class="hljs-built_in">get</span>();<br><span class="hljs-built_in">assert</span>(pop_done.<span class="hljs-built_in">get</span>()==<span class="hljs-number">42</span>);<br><span class="hljs-built_in">assert</span>(q.<span class="hljs-built_in">empty</span>());<br></code></pre></td></tr></table></figure><h2 id="附加：输入系统的探讨"><a href="#附加：输入系统的探讨" class="headerlink" title="附加：输入系统的探讨"></a>附加：输入系统的探讨</h2><p>对于Windows，其 实现是基于消息循环机制，类似于生产者消费者</p><p><a href="http://download.51testing.com/ddimg/uploadsoft/20121105/Windows.pdf">Windows.pdf (51testing.com)</a></p><p>生产者：操作系统，其捕获各个输入消息放到应用程序的队列中<br>消费者：应用程序，在每一次循环中，它将从队列中取出一个消息，然后将其分发给各个窗口，每个窗口再调用各自的回调函数来对消息进行处理<br>这就存在一个问题，即每一次循环只能够处理一个消息，如果要设计成1帧能够接受多个输入，则需要有2个循环，外循环是帧循环，内循环是消息循环，但是，如果消息源源不断地进入，比如按住某个键，则会发生阻塞，如果限制循环次数，该次数有难以决定其值</p><p>对于这个问题，GLFW的解决办法是，记录每个按键的状态，比如DOWN和UP，每一帧依然只接收一个消息，如果该按键一直是DOWN，则记录其状态为按下，这样，即使一帧存在多个不同的输入，也只需要保证在之后的几帧中能够完成其状态的设置，每次查询的时候也只需要参考按键的状态即可<br>通过这种方法，程序能够在一帧内捕获多个按键的输入，Unity也具有同样的效果</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CG-三次样条函数</title>
    <link href="/2023/01/10/CG-%E4%B8%89%E6%AC%A1%E6%A0%B7%E6%9D%A1%E5%87%BD%E6%95%B0/"/>
    <url>/2023/01/10/CG-%E4%B8%89%E6%AC%A1%E6%A0%B7%E6%9D%A1%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="CG-三次样条函数"><a href="#CG-三次样条函数" class="headerlink" title="CG-三次样条函数"></a>CG-三次样条函数</h1><h2 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h2><h3 id="参数连续性"><a href="#参数连续性" class="headerlink" title="参数连续性"></a>参数连续性</h3><p>给定2条曲线：<br>$$<br>\boldsymbol{F_1}(t), t \in [t_0, t_1]<br>$$</p><p>$$<br>\boldsymbol{F_2}(t), t \in [t_1, t_2]<br>$$</p><p>曲线$\boldsymbol{F_1}(t)$和$\boldsymbol{F_2}(t)$是$C^r$连续的，如果它们从$0$阶导数至$r$阶导数在$t_1$处完全相同</p><p>根据定义有：</p><p>$C^0$连续：曲线上的点连续，不存在尖点</p><p>$C^1$连续：曲线上点的一阶导数存在且连续</p><p>$C^2$连续：曲线上点的二阶导数存在且连续</p><h3 id="几何连续性"><a href="#几何连续性" class="headerlink" title="几何连续性"></a>几何连续性</h3><p>由于参数连续性过于严格，在集合设计中不太直观，连续性依赖于参数的选择，同一条曲线，参数不同，连续阶也不同。但是，可以通过引入参数变换使其满足参数连续。</p><p>设$\varphi (t) (a \leq t \leq b)$ 是给定的曲线。若存在一个参数变换$ t &#x3D; \rho (s)(a_1 \leq s \leq b_1)$, 使得$\varphi(\rho(s)) \in C^n[a_1, b_1]$, 且$\frac{d\varphi(\rho(s))}{ds} \neq 0$，则称曲线$\varphi (t) (a \leq t \leq b)$是$n$阶几何连续的曲线，记为：<br>$$<br>\varphi(t) \in GC^n[a, b] \ or \ \varphi(t) \in G^n[a,b]<br>$$<br>性质：</p><ul><li>条件$\frac{d\varphi(\rho(s))}{ds} \neq 0$保证了曲线上没有奇点</li><li>几何连续性与参数选择无关，是曲线本身固有的性质</li><li>$G^n$的条件比$C^n$要宽，曲线类型更多</li></ul><p>根据定义有：</p><p>$G^0$连续：两条曲线有公共的端点</p><p>$G^1$连续：两条曲线在连接点处有公共的切线，即切线方向连续</p><p>$G^2$连续：两条曲线在连接点处有公共的曲率圆，即曲率连续</p><h3 id="C-2-连续"><a href="#C-2-连续" class="headerlink" title="$C^2$连续"></a>$C^2$连续</h3><p>对于 $ R^{2} $ 内的一组点集$$ {P_i | i \in [1, n]} $$, 取参数集合为$${ t_i | t \in [1, n] }$$，假设经过点$$P_i &#x3D; (x_i, y_i)$$ 和$$P_{i+1} &#x3D; (x_{i+1}, y_{i+1})$$ 的曲线方程为$$\boldsymbol{F_i}(t) &#x3D; (X_i(t), Y_i(t))$$, 则：<br>$$<br>\boldsymbol{F_i}(t) &#x3D; \boldsymbol{a_i} + \boldsymbol{b_i}(t - t_i) + \boldsymbol{c_i}(t - t_i)^2 + \boldsymbol{d_i} (t - t_i)^3 \tag1<br>$$</p><p>$$<br>\boldsymbol{F^{‘}_i}(t) &#x3D; \boldsymbol b_i + 2\boldsymbol{c_i}(t - t_i) + 3\boldsymbol{d_i}(t-t_i)^2 \tag2<br>$$</p><p>$$<br>\boldsymbol{F^{\‘\‘}_i}(t) &#x3D; 2\boldsymbol{c_i} + 6\boldsymbol{d_i}(t-t_i) \tag3<br>$$</p><p>曲线经过点$P_i$, 则:<br>$$<br>\boldsymbol{a_i} &#x3D; (x_i, y_i) &#x3D; \boldsymbol{P_i} \tag4<br>$$<br>曲线经过点$$P_{i+1}$$且$C^0$连续，令$$h_{i} &#x3D; t_{i+1}-t_{i}$$, 则：<br>$$<br>\boldsymbol{a_{i+1}} &#x3D; \boldsymbol{a_i} + \boldsymbol{b_i}hi + \boldsymbol{c_i}h_i^2 + \boldsymbol{d_i}h_i^3 \tag5<br>$$<br>由于$C^1$连续，则：<br>$$<br>\boldsymbol{F^{‘}<em>i}(t</em>{i+1}) &#x3D; \boldsymbol b_i + 2\boldsymbol{c_i}(t_{i+1} - t_i) + 3\boldsymbol{d_i}(t_{i+1}-t_i)^2 &#x3D; \boldsymbol b_i + 2\boldsymbol{c_i}h_i + 3\boldsymbol{d_i}h_i^2 \tag6<br>$$</p><p>$$<br>\boldsymbol{F^{‘}<em>{i+1}}(t</em>{i+1}) &#x3D; \boldsymbol b_{i+1} + 2\boldsymbol{c_{i+1}}(t_{i+1} - t_{i+1}) + 3\boldsymbol{d_{i+1}}(t_{i+1}-t_{i+1})^2 &#x3D; \boldsymbol b_{i+1} \tag7<br>$$</p><p>联立(6)(7)式可得：<br>$$<br>\boldsymbol {b_{i+1}} &#x3D; \boldsymbol b_i + 2\boldsymbol{c_i}h_i + 3\boldsymbol{d_i}h_i^2 \tag8<br>$$<br>由于$C^2$连续，则：<br>$$<br>2\boldsymbol{c_i} + 6\boldsymbol{d_i} h_i &#x3D; 2\boldsymbol{c_{i+1}} \tag9<br>$$<br>设$\boldsymbol{m_i}$ 为插值点$ P_i $的二阶导数，则<br>$$<br>\boldsymbol{m_i} &#x3D; 2\boldsymbol{c_i}\tag{10}<br>$$<br>根据(9)式得：<br>$$<br>\boldsymbol{m_i} + 6\boldsymbol{d_i} h_i &#x3D; \boldsymbol{m_{i+1}} \tag{11}<br>$$<br>得到：<br>$$<br>\boldsymbol{d_i} &#x3D; \frac{\boldsymbol {m_{i+1}} - \boldsymbol{m_i}}{6h_i} \tag{12}<br>$$<br>联立(5)(12)式可得：<br>$$<br>\boldsymbol {b_i} &#x3D; \frac{\boldsymbol {P_{i+1}} - \boldsymbol {P_{i}} }{h_i} - \frac{\boldsymbol{m_i}h_i}{2} - \frac{(\boldsymbol{m_{i+1}} - \boldsymbol {m_{i}} ) h_i}{6} \tag{13}<br>$$<br>联立(4)(8)(10)(12)(13)可得：<br>$$<br>\boldsymbol{m_i} h_i + 2\boldsymbol {m_{i+1}}(h_i + h_{i+1}) + \boldsymbol {m_{i + 2}}h_{i + 1} &#x3D; 6(\frac{\boldsymbol {P_{i+2}} - \boldsymbol{P_{i+1}} }{h_{i+1}} - \frac{\boldsymbol {P_{i+1}} - \boldsymbol{P_{i}}}{h_i} ), i \in [1, n-2] \tag{14}<br>$$<br>此时还缺少两个方程才能解出曲线的未知参数，有如下约束可以选择：</p><ul><li><p>自由端：指定曲线在两个端点的二阶导数，即<br>  $$<br>  \boldsymbol {m_1} &#x3D; \boldsymbol {m_n} &#x3D; \boldsymbol {0} \tag{15}<br>  $$<br>  该样条为自然三次样条</p></li><li><p>夹持端：指定曲线在两个端点的一阶导数</p></li><li><p>其他：</p><ul><li>曲线两端为抛物线</li><li>周期端</li><li>混合边界条件</li></ul></li></ul><p>这里以自然边界条件为例，则线性方程组为：<br>$$<br>\begin{bmatrix}<br>1 &amp; 0  &amp; 0 &amp; 0 &amp; \cdots   &amp; 0   \<br>h_1 &amp; 2(h_1 + h_2)  &amp; h_2 &amp; 0 &amp; \cdots   &amp; 0  \<br>0 &amp; h_2  &amp; 2(h_2 + h_3) &amp; h_3 &amp; \cdots   &amp; 0  \<br>\vdots &amp; \vdots  &amp; \vdots &amp; \vdots &amp; \ddots   &amp; \vdots  \<br>0 &amp; \cdots &amp; 0 &amp; h_{n-2}  &amp; 2(h_{n-2} + h_{n-1})  &amp; h_{n-1}  \<br>0 &amp; \cdots &amp; 0 &amp; 0 &amp; 0 &amp; 1\<br>\end{bmatrix}</p><h1 id="begin-bmatrix-m-1-m-2-m-3-vdots-m-n-1-m-n-end-bmatrix"><a href="#begin-bmatrix-m-1-m-2-m-3-vdots-m-n-1-m-n-end-bmatrix" class="headerlink" title="\begin{bmatrix}m_1 \m_2 \m_3 \\vdots \m_{n-1} \m_n \\end{bmatrix}"></a>\begin{bmatrix}<br>m_1 \<br>m_2 \<br>m_3 \<br>\vdots \<br>m_{n-1} \<br>m_n \<br>\end{bmatrix}</h1><p>6<br>\begin{bmatrix}<br>0 \<br>\frac{\boldsymbol {P_3} - \boldsymbol{P_2} }{h_2} - \frac{\boldsymbol {P_2} - \boldsymbol{P_1} }{h_1} \<br>\frac{\boldsymbol {P_4} - \boldsymbol{P_3} }{h_3} - \frac{\boldsymbol {P_3} - \boldsymbol{P_2} }{h_2} \<br>\vdots \<br>\frac{\boldsymbol {P_n} - \boldsymbol{P_{n-1}} }{h_{n-1}} - \frac{\boldsymbol {P_{n-1}} - \boldsymbol{P_{n-2}} }{h_{n-2}} \<br>0 \<br>\end{bmatrix}<br>$$<br>将该方程组的第1行第1列，最后1行最后1列去掉，满足三对角矩阵和对角线占优，可以使用追赶法求解方程组，具体方法见：</p><p><a href="https://en.wikipedia.org/wiki/Tridiagonal_matrix_algorithm">Tridiagonal matrix algorithm</a></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>github代码：</p><p><a href="https://github.com/olleh-dlrow/Vortex/blob/master/Sandbox/src/CubicSplinesTest.h">https://github.com/olleh-dlrow/Vortex/blob/master/Sandbox/src/CubicSplinesTest.h</a></p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>型值点具有如下信息：</p><ul><li>位置</li><li>一阶左导数</li><li>一阶右导数</li><li>参数t</li><li>几何连续性类型</li></ul><h3 id="绘制自然三次样条"><a href="#绘制自然三次样条" class="headerlink" title="绘制自然三次样条"></a>绘制自然三次样条</h3><p>输入：型值点</p><p>输出：拟合后的三次样条曲线，型值点的参数值、导数值</p><p>根据公式计算每段曲线的未知参数，并初始化型值点的参数值和导数值，最后根据曲线计算若干离散点进行绘制</p><h3 id="编辑型值点"><a href="#编辑型值点" class="headerlink" title="编辑型值点"></a>编辑型值点</h3><p>选中型值点后，进入编辑模式，可以通过调整切线的控制点改变该点的切线值，根据点的几何连续性类型有如下情况：</p><p>$G^0$连续：切线无约束</p><p>$G^1$连续：左右切线向量的方向相同</p><p>$G^2 $连续：左右切线向量相同</p><h3 id="移动型值点"><a href="#移动型值点" class="headerlink" title="移动型值点"></a>移动型值点</h3><p>在编辑模式下，拖动型值点即可移动该点，此时需要更新型值点两端的曲线，根据曲线两端点的函数值和一阶导数得到4个方程，可以解得曲线$$\boldsymbol{F_i} (t)$$的参数如下，其中$$h_{i} &#x3D; t_{i+1} - t_{i}$$：<br>$$<br>\boldsymbol{a_i} &#x3D; (x_i, y_i) &#x3D; \boldsymbol{F_i}(t_i)<br>$$</p><p>$$<br>\boldsymbol{b_i} &#x3D; \boldsymbol{F^{\‘}_{i+}}(t_i)<br>$$</p><p>$$<br>\boldsymbol{d_i} &#x3D; \frac{2\boldsymbol{F_i}(t_i) + \boldsymbol{F^{\‘}<em>{i+}}(t_i) h_i + \boldsymbol{F^{\‘}</em>{i-}}(t_{i+1})h_i - 2\boldsymbol{F_i}(t_{i+1})}{h_i^3}<br>$$</p><p>$$<br>\boldsymbol{c_i} &#x3D; \frac{\boldsymbol{F^{\‘}<em>{i-}}(t</em>{i+1}) - \boldsymbol{F^{\‘}<em>{i+}}(t</em>{i}) - 3\boldsymbol{d_i}h_i^2 }{2h_i}<br>$$</p><h3 id="添加型值点"><a href="#添加型值点" class="headerlink" title="添加型值点"></a>添加型值点</h3><p>在完成初始化后，添加新的型值点不再需要保证$C^2$连续， 此时根据末端点$$P_{i}$$和新点$$P_{i+1}$$生成曲线$$\boldsymbol{F_i}(t)$$，需要4个约束方程来计算未知参数，一种方法是，使用两个点的函数值和$$P_i$$在$$\boldsymbol{F_{i-1}}(t)$$的一阶、二阶导数建立4个方程，该方法经过实现效果并不好，生成的新曲线容易出现极大值。这里介绍第二种方法，使用自然端约束，即$$P_{i+1}$$的二阶导数为$$0$$</p><p>根据条件建立4个方程，可以解得4个未知参数如下，其中$$h_i &#x3D; t_{i+1} - t_i$$：<br>$$<br>\boldsymbol{a_i} &#x3D; (x_i, y_i) &#x3D; \boldsymbol{F_i}(t_i)<br>$$</p><p>$$<br>\boldsymbol{b_i} &#x3D; \boldsymbol{F^{‘}<em>{i+}}(t_i) &#x3D; \boldsymbol{F^{‘}</em>{i-}}(t_i)<br>$$</p><p>$$<br>\boldsymbol{d_i} &#x3D; \frac{\boldsymbol{a_i} + \boldsymbol{b_i}h_i - \boldsymbol{F_i}(t_{i+1})}{2h_i^3}<br>$$</p><p>$$<br>\boldsymbol{c_i} &#x3D; -3\boldsymbol{d_i}h_i<br>$$</p><p>该方法生成的切线向量长度适中，比较适合进一步编辑</p><h3 id="删除型值点"><a href="#删除型值点" class="headerlink" title="删除型值点"></a>删除型值点</h3><p>鼠标悬停在某个型值点上后，按下E键即可删除该点，此时需要更新所有点的参数$t$，并重新计算曲线，方法同移动型值点处的计算方法</p>]]></content>
    
    
    <categories>
      
      <category>CG</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CG</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AStar</title>
    <link href="/2023/01/10/AStar/"/>
    <url>/2023/01/10/AStar/</url>
    
    <content type="html"><![CDATA[<h1 id="AStar——既脚踏实地，又仰望星空"><a href="#AStar——既脚踏实地，又仰望星空" class="headerlink" title="AStar——既脚踏实地，又仰望星空"></a>AStar——既脚踏实地，又仰望星空</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>AStar算法，又称为A*算法，它作为一个启发式的寻路算法，在大部分情况下的性能要优于非启发式算法（如Dijkstra算法和Prim算法），特别是时间复杂度方面，只要选取的估值函数足够好。</p><p>AStar算法可以用来搜寻所有非负图中的最短路径，并且能够找到最优解，是一种在人工智能和游戏引擎中被广泛使用的寻路算法。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>“既脚踏实地，又仰望星空”。A*算法的设计很巧妙地贯彻了这句鸡汤。假设一个旅行者需要找到起点和目的地之间的最短路径，那么他不仅会根据自己走过的中转站计算出到达这个中转站的最短路径，也会根据手中的地图来估计一下距离目的地还有多远的距离，在把两者权衡一下之后，选择接下来的旅行策略。这样既能够充分地利用已经走过的中转站，又不会出现南辕北辙的情况（明明这个中转站的方向是相反的还要去尝试）。或者说，借助非启发式算法的前提下，又一直在朝着目的地的方向迈进。</p><p>A*算法的核心函数如下：<br>$$<br>f(n)&#x3D; g(n) + h(n)<br>$$</p><ul><li>f(n): 从起点到终点并且经过点n的一个路径长度估计值。在实际处理新的中间点的过程中，当这个点对应的f(n)越小，证明这个点具有更好地成为最短路径的潜质，因此会优先去考虑这个点的相邻点作为下一个可能的路径点。</li><li>g(n): 从起点到点n并且经过其父节点的最短距离。</li><li>h(n): 从点n到终点的估值距离。这个距离越大则算法性能越好，但是不能超过两点之间实际距离的最小值，否则不能保证得到最优解。可以使用极限法考虑，如果h(n) 趋向于无穷大，则永远不可能找到最短路径。实际上，当f(n)小于实际的最优解时，那么在后续的遍历中，最优解下的路径一定会将之前的那个路径给覆盖掉，当f(n)始终等于最优解时，该算法就一直在遍历最短路径了。</li></ul><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><h3 id="图的基本结构"><a href="#图的基本结构" class="headerlink" title="图的基本结构"></a>图的基本结构</h3><p>因为AStar算法是基于非负图的，因此数据结构的选取非常重要。如果把一张2D网格映射成一张图的话，其基本类和变量如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//图的结点</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br>    String nodeId;  <span class="hljs-comment">//为每个结点生成一个字符串Id，主要便于查找到这个结点和作为Key</span><br>    Point position; <span class="hljs-comment">//用来存放该结点存储的坐标</span><br>    List&lt;Node&gt; neghbors; <span class="hljs-comment">//存储相邻结点</span><br>    Map&lt;String, Integer&gt; distances; <span class="hljs-comment">//通过Id来获得该点与相邻点之间的距离</span><br>&#125;<br><br><span class="hljs-comment">//图类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Graph</span>&#123;<br>    Map&lt;String, Node&gt; graph;  <span class="hljs-comment">//存储图中的所有结点</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="A-算法"><a href="#A-算法" class="headerlink" title="A*算法"></a>A*算法</h3><p>为了便于理解，可以直接根据算法需要实现的功能来设计对应的数据结构。</p><ul><li>g(n): 该函数需要得到当前结点在经过父节点的情况下到达起点的最短路径，可以直接利用Dijkstra算法的思想来实现，假设点n-1是点n的父节点并且g(n-1)已知，那么g(n) &#x3D; min(g(n), g(n-1) + d(n-1, n)), 其中d是两点之间的距离。为了记录当前结点的父节点，可以设计数据结构<code>Map&lt;String, Node&gt; cameFrom</code>，这样，可以通过当前结点的Id找到其父节点。g(n)也可以通过Map来实现。</li><li>h(n): 估算点n到终点的距离，保证h(n)小于实际最短距离的前提下让估算值越接近真实值越好，因此对于不同的实际问题可以采取不同的计算方式。一般来说，对于一个2D平面，采取两点之间的线段距离，而对于一个2D的网格，因为不能斜着走，所以两点直接长宽差的和就是最短的情况了。</li><li>f(n): 用来指导算法的行进方向，也可以通过Map来存储每个结点对应的函数值，同时，为了使得每次取出f(n)值最小的结点，可以采用堆结构或者优先队列的结构来存储结点，即<code>PriorityQueue&lt;Node&gt; openSet</code>。</li></ul><p>这样，已知的变量如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String, Node&gt; cameFrom;<br>Map&lt;String, Integer&gt; gScore;<br>Map&lt;String, Integer&gt; fScore;<br>PriorityQueue&lt;Node&gt; openSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Node&gt;()&#123;<br>   <span class="hljs-comment">//f(n)越小则对应结点放置地越靠前</span><br>   <span class="hljs-meta">@override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Node o1, Node o2)</span>&#123;<br>       <span class="hljs-keyword">return</span> fScore.get(o1.getNodeId()).compareTo(fScore.get(o2.getNodeId));<br>   &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>h(n)需要根据场景不同进行不同的设计：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * heuristic function that caculate approximately the distance between </span><br><span class="hljs-comment">    * current point and the end point.</span><br><span class="hljs-comment">    * &lt;p&gt;&lt;strong&gt;About distance : &lt;/strong&gt;in AStar algorithm, the bigger is distance,</span><br><span class="hljs-comment">    * the better its performance can be. However, this appro. distance shouldn&#x27;t beyond the </span><br><span class="hljs-comment">    * actual distance between the two points. Otherwise, it may can&#x27;t get the best</span><br><span class="hljs-comment">    * solution.</span><br><span class="hljs-comment">    * &lt;p&gt;in 2D grid, the distance can set as width add length</span><br><span class="hljs-comment">    * &lt;p&gt;in 2D map, the distance should set as the segment&#x27;s length between the</span><br><span class="hljs-comment">    * two points</span><br><span class="hljs-comment">    * </span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> cur the current point</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> end the end point</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> the approximately distance between two points</span><br><span class="hljs-comment">    */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">heuristic</span><span class="hljs-params">(Point cur, Point end, <span class="hljs-type">int</span> mode)</span>&#123;<br>       <span class="hljs-keyword">switch</span> (mode) &#123;<br>           <span class="hljs-comment">//不进行估值，NONE是定义的常变量</span><br>           <span class="hljs-keyword">case</span> AStar.NONE:<br>               <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>           <span class="hljs-comment">//网格图    </span><br>           <span class="hljs-keyword">case</span> AStar.GRID:<br>               <span class="hljs-keyword">return</span> Math.abs(end.getRow() - cur.getRow()) + Math.abs(end.getCol() - cur.getCol());<br>           <span class="hljs-comment">//一般的2D平面</span><br>           <span class="hljs-keyword">case</span> AStar.EUCLID:<br>               <span class="hljs-type">double</span> <span class="hljs-variable">dx</span> <span class="hljs-operator">=</span> cur.getRow() - end.getRow();<br>               <span class="hljs-type">double</span> <span class="hljs-variable">dy</span> <span class="hljs-operator">=</span> cur.getCol() - end.getCol();<br>               <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)Math.sqrt(dx * dx + dy * dy);<br>           <span class="hljs-keyword">default</span>:<br>               <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>       &#125;      <br>   &#125;<br></code></pre></td></tr></table></figure><p>先为所有变量设置初值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">      <span class="hljs-comment">//@param startNode, endNode</span><br>openSet.add(startNode);                        <span class="hljs-comment">//最初只访问了起点</span><br>      cameFrom.put(startNode.getNodeId(), <span class="hljs-literal">null</span>);     <span class="hljs-comment">//起点没有父节点</span><br><span class="hljs-comment">//为结点的g和f设置INF，但除了起点</span><br>      <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>          <span class="hljs-type">Node</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> iterator.next().getValue();<br>          gScore.put(current.getNodeId(), Integer.MAX_VALUE);<br>          fScore.put(current.getNodeId(), Integer.MAX_VALUE);<br>      &#125;<br>      gScore.replace(startNode.getNodeId(), <span class="hljs-number">0</span>);<br>      fScore.replace(startNode.getNodeId(), heuristic(start, end, mode));<br></code></pre></td></tr></table></figure><p>寻路过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java">      <span class="hljs-comment">//优先队列不为空或者没有找到终点时循环</span><br><span class="hljs-keyword">while</span>(!openSet.isEmpty())&#123;<br>          <span class="hljs-comment">//从队列中取出f(n)值最小的点，在保证得到最优解的情况下，这个点的期望也是当前最大的，因此把它的邻接点作为下一个考虑点</span><br>          <span class="hljs-type">Node</span> <span class="hljs-variable">currentNode</span> <span class="hljs-operator">=</span> openSet.poll();<br>          <span class="hljs-comment">//找到终点，根据父节点输出路径</span><br>          <span class="hljs-keyword">if</span>(currentNode.getNodeId().compareTo(endNode.getNodeId()) == <span class="hljs-number">0</span>)&#123;<br>              <span class="hljs-keyword">return</span> reconstructPath(cameFrom, currentNode);<br>          &#125;<br>          <span class="hljs-comment">//遍历所有邻接点</span><br>          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; currentNode.getNeighborsSize(); i++) &#123;<br>              <span class="hljs-type">Node</span> <span class="hljs-variable">neighbor</span> <span class="hljs-operator">=</span> currentNode.getNeighbor(i);<br>              <span class="hljs-comment">//获得临界点的Id</span><br>              <span class="hljs-type">String</span> <span class="hljs-variable">nbrId</span> <span class="hljs-operator">=</span> neighbor.getNodeId();<br>              <span class="hljs-comment">//计算邻接点经过当前点(currentNode)的最小g(n)</span><br>              <span class="hljs-type">Integer</span> <span class="hljs-variable">tmpGScore</span> <span class="hljs-operator">=</span> gScore.get(neighbor.getNodeId()) <br>                                  + currentNode.getDistance(neighbor.getNodeId());<br>              <span class="hljs-comment">//如果比之前的路径更优，则修改其父节点</span><br>              <span class="hljs-keyword">if</span>(tmpGScore.compareTo(gScore.get(neighbor.getNodeId())) &lt; <span class="hljs-number">0</span>)&#123;<br>                  cameFrom.put(nbrId, currentNode);<br>                  <span class="hljs-comment">//依次修改g(n) 和 h(n)</span><br>                  gScore.put(nbrId, tmpGScore);<br>                  fScore.put(nbrId, gScore.get(nbrId) + heuristic(neighbor.getPosition(), end, mode));<br>                  <span class="hljs-comment">//把当前点放入待处理的队列中</span><br>                  <span class="hljs-keyword">if</span>(!openSet.contains(neighbor))&#123;<br>                      openSet.add(neighbor);<br>                  &#125;<br>              &#125;<br>          &#125;<br>      &#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可以看出，A*算法可以说是BFS和DFS的结合。</p><p>当g(n)为0时，A*算法退化为DFS, 尽管能够很快找到终点，但只有遍历完所有点才能确定最短的那条，有点好高骛远的感觉。</p><p>当h(n)为0时，A*算法退化为BFS, 即使大方向错了，还是得闷头去走，是一种非启发式的傻瓜算法。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AStar</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020暑期实训算法温故知新</title>
    <link href="/2023/01/10/2020%E6%9A%91%E6%9C%9F%E5%AE%9E%E8%AE%AD%E7%AE%97%E6%B3%95%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0/"/>
    <url>/2023/01/10/2020%E6%9A%91%E6%9C%9F%E5%AE%9E%E8%AE%AD%E7%AE%97%E6%B3%95%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="2020暑期实训算法温故知新"><a href="#2020暑期实训算法温故知新" class="headerlink" title="2020暑期实训算法温故知新"></a>2020暑期实训算法温故知新</h1><blockquote><p>这次接触算法应该是我学习代码以来最多的一次，而且写完这些算法的时间很短，根本来不及进行整理和归纳，因此，我认为进行这样一次温故知新是非常有必要的，一方面，我可以把一些我认为能够通过c++ 的STL优化的算法重写一遍（这次实训最坑的一点就是只能用C，什么都要自己造，而我造的东西移植性又不好，性能也不咋地，哭了~~)，另一方面，我可以对当时一些不是很清楚的算法做一些总结和归类，这也算是我的第一个小题库。</p></blockquote><h2 id="龙虎斗"><a href="#龙虎斗" class="headerlink" title="龙虎斗"></a>龙虎斗</h2><p class="note note-primary">枚举</p><p>轩轩和凯凯正在玩一款叫《龙虎斗》的游戏，游戏的棋盘是一条线段，线段上有 n个兵营(自左至右编号 1~ n)，相邻编号的兵营之间相隔 1 厘米，即棋盘为长度为 n - 1 厘米的线段。i 号兵营里有 ci 位工兵。</p><p>下面图 11 为 n &#x3D; 6 的示例:</p><p><a href="https://res.jisuanke.com/img/upload/20181112/3d78d2abcad862078271fd47579690bf57d5ff7c.png"><img src="https://res.jisuanke.com/img/upload/20181112/3d78d2abcad862078271fd47579690bf57d5ff7c.png" alt="img"></a></p><p>图 11. n &#x3D; 6的示例</p><p>轩轩在左侧，代表 “龙”；凯凯在右侧，代表 “虎”。他们以 m号兵营作为分界，靠左的工兵属于龙势力，靠右的工兵属于虎势力，而 <strong>第 m 号兵营中的工兵很纠结，他们不属于任何一方</strong>。</p><p>一个兵营的气势为：该兵营中的工兵数 × 该兵营到 m 号兵营的距离；参与游戏一方的势力定义为：属于这一方所有兵营的气势之和。</p><p>下面图 22 为 n &#x3D; 6, m &#x3D; 4的示例，其中红色为龙方，黄色为虎方:</p><p><a href="https://res.jisuanke.com/img/upload/20181112/2683c86a65534088f9385aa068a52dae92c7d98c.png"><img src="https://res.jisuanke.com/img/upload/20181112/2683c86a65534088f9385aa068a52dae92c7d98c.png" alt="img"></a></p><p>图 22. n &#x3D; 6, m &#x3D; 4 的示例</p><p>游戏过程中，某一刻天降神兵，共有 s1 位工兵突然出现在了 p1 号兵营。作为轩轩和凯凯的朋友，你知道如果龙虎双方气势差距太悬殊，轩轩和凯凯就不愿意继续玩下去了。为了让游戏继续，你需要选择一个兵营p2，并将你手里的s2 位工兵 <strong>全部</strong> 派往兵营 p2，使得双方气势差距尽可能小。</p><p>注意：你手中的工兵落在哪个兵营，就和该兵营中其他工兵有相同的势力归属(如果落在 m号兵营，则不属于任何势力)。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入文件的第一行包含一个正整数 n，代表兵营的数量。</p><p>接下来的一行包含 n 个正整数，相邻两数之间以一个空格分隔，第 i个正整数代表编号为 i的兵营中起始时的工兵数量 ci。</p><p>接下来的一行包含四个正整数，相邻两数间以一个空格分隔，分别代表 m,p1,s1,s2。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出文件有一行，包含一个正整数，即 p2，表示你选择的兵营编号。</p><p>如果存在多个编号同时满足最优，取最小的编号。</p><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>1 &lt; m &lt; n, 1≤ p1 ≤n。</p><p>对于 20% 的数据，n*&#x3D;3,<em>m</em>&#x3D;2,*ci&#x3D;1,s1,s2≤100。</p><p>另有 20% 的数据，n≤10,p1&#x3D;m,ci&#x3D;1,s1,s2≤100。</p><p>对于 60% 的数据，n≤100,ci&#x3D;1,s1,s2≤100。</p><p>对于 80% 的数据，n≤100,ci,s1,s2≤100。</p><p>对于100% 的数据，n≤$10^5$,ci,s1,s2≤$10^9$。</p><h3 id="样例说明"><a href="#样例说明" class="headerlink" title="样例说明"></a>样例说明</h3><p>样例 1</p><p>双方以 m&#x3D;4号兵营分界，有s1&#x3D;5 位工兵突然出现在 p1&#x3D;6 号兵营。</p><p>龙方的气势为：</p><p> 2 x (4 - 1) + 3 x (4 - 2) + 2 x (4 - 3) &#x3D; 14</p><p>虎方的气势为：</p><p> 2 x (5 - 4) + (3 + 5) x (6 - 4) &#x3D; 18</p><p>当你将手中的s2&#x3D;2 位工兵派往p2&#x3D;2 号兵营时，龙方的气势变为：</p><p>14 + 2 × ( 4 − 2 ) &#x3D; 18</p><p>此时双方气势相等。</p><p>样例 2</p><p>双方以 m &#x3D; 5 号兵营分界，有s1&#x3D;1 位工兵突然出现在 p1&#x3D;4 号兵营。</p><p>龙方的气势为:</p><p>1 × ( 5−1 ) + 1 × ( 5−2 ) + 1 × ( 5−3 ) + ( 1+1 ) × ( 5−4 ) &#x3D; 11</p><p>虎方的气势为:</p><p>16 × ( 6 −5 ) &#x3D; 16</p><p>当你将手中的 s2&#x3D;1 位工兵派往 <em>p</em>2&#x3D;1 号兵营时，龙方的气势变为:</p><p>11+1×(5−1)&#x3D;15</p><p>此时可以使双方气势的差距最小。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>现在看来，当时做题可能是被题目的长度给吓到了，如果时间的限制不太严的话，直接枚举每一个值，分别计算气势差距就OK了，最后时间复杂度在O(n)，我估计当时应该是被时间给卡住了，但直接枚举比较不费脑子，所以也懒得想什么奇淫技巧了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//题目要求输入的数据：</span><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> m;<br><span class="hljs-type">int</span> p1, s1;<br><span class="hljs-type">int</span> p2, s2;<br><br><span class="hljs-comment">//双方的气势</span><br><span class="hljs-type">int</span> lpower = <span class="hljs-number">0</span>, rpower = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//记录当前的最小气势差</span><br>    <span class="hljs-type">int</span> min = <span class="hljs-number">0x3f3f3f3f</span>;<br>    <span class="hljs-comment">//记录当前气势差</span><br>    <span class="hljs-type">int</span> gap;<br>    cin &gt;&gt; n;<br>    <span class="hljs-type">int</span> i ,j;<br>    vector&lt;<span class="hljs-type">int</span>&gt; build;<br>    build.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">//初始化所有数据</span><br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i &lt; n;i++)&#123;<br>        cin &gt;&gt; m;<br>        build.<span class="hljs-built_in">push_back</span>(m);<br>    &#125;<br>    cin &gt;&gt; m &gt;&gt; p1 &gt;&gt; s1 &gt;&gt; s2;<br>    <span class="hljs-comment">//天降神兵后双方的气势</span><br>    build[p1] += s1;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>;i &lt; m ;i++)&#123;<br>        lpower += build[i] * (m - i);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(i = m + <span class="hljs-number">1</span>;i &lt;= n;i++)&#123;<br>        rpower += build[i] * (i - m);<br>    &#125;<br>    <span class="hljs-comment">//对每一个兵营进行遍历，然后计算气势差，记录下最小的那个p2</span><br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>;i &lt;= n;i++)&#123;<br>        <span class="hljs-type">int</span> tmp;<br>        <span class="hljs-keyword">if</span>(i &lt; m)&#123;<br>            tmp = lpower;<br>            lpower += s2 * (m - i);<br>            gap = <span class="hljs-built_in">abs</span>(lpower - rpower);<br>            lpower = tmp;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i &gt; m)&#123;<br>            tmp = rpower;<br>            rpower += s2 * (i - m);<br>            gap = <span class="hljs-built_in">abs</span>(lpower - rpower);<br>            rpower = tmp;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            gap = <span class="hljs-built_in">abs</span>(lpower - rpower);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(gap &lt; min)&#123;<br>            min = gap;<br>            p2 = i;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; p2 &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="大整数加法"><a href="#大整数加法" class="headerlink" title="大整数加法"></a>大整数加法</h2><p class="note note-primary">高精度</p><p>求两个不超过 200200 位的非负整数的和。</p><h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h3><p>有两行，每行是一个不超过 200200 位的非负整数，可能有多余的前导 00。</p><h3 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h3><p>一行，即相加后的结果。结果里不能有多余的前导 00，即如果结果是 342342，那么就不能输出为 03420342。</p><br><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>使用dequeue能够快速头插元素对这题帮助极大！毫无疑问，如果只能使用C语言来解析这题，第一层麻烦就是静态数组，如果正向做加法，会把数组颠三倒四好多次，但如果逆向做加法，由于不清楚各个数组的长度和是否有最终进位，因此空间十分不好申请，还有一点就是，如果不让两个数组长度相同（其中一个用0补充），那么判断条件会增添许多麻烦，如果让其中一个填充0，那头插又会耗费数组大量时间。</p><p>而有了deque，这一切都不是问题，我们可以像做竖式加法一样去思考这个大整数加法。将两个字符串转化一下读到deque中，用头插补0，然后申请一个逆向的迭代器就可以愉快地做加法啦~</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string str1, str2;<br>    cin &gt;&gt; str1 &gt;&gt; str2;<br>    <span class="hljs-type">int</span> len1 = str1.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-type">int</span> len2 = str2.<span class="hljs-built_in">length</span>();<br>    deque&lt;<span class="hljs-type">int</span>&gt; qu1, qu2;<br>    string::reverse_iterator it;<br>    <span class="hljs-keyword">for</span>(it = str1.<span class="hljs-built_in">rbegin</span>(); it != str1.<span class="hljs-built_in">rend</span>();it++)&#123;<br>        qu1.<span class="hljs-built_in">push_front</span>(<span class="hljs-built_in">int</span>((*it) - <span class="hljs-string">&#x27;0&#x27;</span>));<br>    &#125;<br>    <span class="hljs-keyword">for</span>(it = str2.<span class="hljs-built_in">rbegin</span>(); it != str2.<span class="hljs-built_in">rend</span>();it++)&#123;<br>        qu2.<span class="hljs-built_in">push_front</span>(<span class="hljs-built_in">int</span>((*it) - <span class="hljs-string">&#x27;0&#x27;</span>));<br>    &#125;<br>    <span class="hljs-type">int</span> gap;<br>    <span class="hljs-keyword">if</span>(len1 &gt; len2)&#123;<br>        gap = len1 - len2;<br>        <span class="hljs-keyword">while</span>(gap)&#123;<br>            qu2.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">0</span>);<br>            gap--;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        gap = len2 - len1;<br>        <span class="hljs-keyword">while</span>(gap)&#123;<br>            qu1.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">0</span>);<br>            gap--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> cf = <span class="hljs-number">0</span>;<br>    deque&lt;<span class="hljs-type">int</span>&gt; ans;<br>    deque&lt;<span class="hljs-type">int</span>&gt;::reverse_iterator it1, it2;<br>    <span class="hljs-comment">//小学加法</span><br>    <span class="hljs-keyword">for</span>(it1 = qu1.<span class="hljs-built_in">rbegin</span>(), it2 = qu2.<span class="hljs-built_in">rbegin</span>(); it1 != qu1.<span class="hljs-built_in">rend</span>();it1++, it2++)&#123;<br>        <span class="hljs-type">int</span> tmp = *it1 + *it2 + cf;<br>        ans.<span class="hljs-built_in">push_front</span>(tmp % <span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">if</span>(tmp &gt;= <span class="hljs-number">10</span>)cf = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> cf = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(cf == <span class="hljs-number">1</span>)&#123;<br>        ans.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x : ans)cout &lt;&lt; x;<br>    cout &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>有木有很清晰的感觉~~</p></blockquote><br><h2 id="高精度运算"><a href="#高精度运算" class="headerlink" title="高精度运算"></a>高精度运算</h2><p class="note note-primary">高精度</p><blockquote><p>看了几个题，基本都是涉及到大数的加减乘除，因此在这里将其归纳总结起来，再遇到类似的题融会贯通就好。</p></blockquote><h3 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h3><p>将大数用字符串读取进来以后，使用vector进行逐位运算（在不优化的情况下，使用小学竖式加减乘除的思想就OK），这里可能涉及到结构继承。</p><p>代码如下（转自百度百科）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Wint</span>:vector&lt;<span class="hljs-type">int</span>&gt;<br>&#123;<br>    <span class="hljs-built_in">Wint</span>(<span class="hljs-type">int</span> n=<span class="hljs-number">0</span>)<span class="hljs-comment">//默认初始化为0，但0的保存形式为空</span><br>    &#123;<br>        <span class="hljs-built_in">push_back</span>(n);<br>        <span class="hljs-built_in">check</span>();<br>    &#125;<br>    <span class="hljs-comment">//每一种运算完成后，需要将数据整理成正常的十进制表达</span><br>    <span class="hljs-function">Wint&amp; <span class="hljs-title">check</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">empty</span>()&amp;&amp;!<span class="hljs-built_in">back</span>())<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">//去除最高位可能存在的0</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">empty</span>())<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            (*<span class="hljs-keyword">this</span>)[i]+=(*<span class="hljs-keyword">this</span>)[i<span class="hljs-number">-1</span>]/<span class="hljs-number">10</span>;<br>            (*<span class="hljs-keyword">this</span>)[i<span class="hljs-number">-1</span>]%=<span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-built_in">back</span>()&gt;=<span class="hljs-number">10</span>)<br>        &#123;<br>            <span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">back</span>()/<span class="hljs-number">10</span>);<br>            (*<span class="hljs-keyword">this</span>)[<span class="hljs-built_in">size</span>()<span class="hljs-number">-2</span>]%=<span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<span class="hljs-comment">//为使用方便，将进位后的自身返回引用</span><br>    &#125;<br>&#125;;<br><br>istream&amp; <span class="hljs-keyword">operator</span>&gt;&gt;(istream &amp;is,Wint &amp;n)<br>&#123;<br>    string s;<br>    is&gt;&gt;s;<br>    n.<span class="hljs-built_in">clear</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">0</span>; --i)n.<span class="hljs-built_in">push_back</span>(s[i]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">return</span> is;<br>&#125;<br><br><span class="hljs-comment">//该算法只能接受正数输入</span><br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;os,<span class="hljs-type">const</span> Wint &amp;n)<br>&#123;<br>    <span class="hljs-keyword">if</span>(n.<span class="hljs-built_in">empty</span>())os&lt;&lt;<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">0</span>; --i)os&lt;&lt;n[i];<br>    <span class="hljs-keyword">return</span> os;<br>&#125;<br><br><span class="hljs-comment">//大数比较</span><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> Wint &amp;a,<span class="hljs-type">const</span> Wint &amp;b)<br>&#123;<br>    <span class="hljs-keyword">if</span>(a.<span class="hljs-built_in">size</span>()!=b.<span class="hljs-built_in">size</span>())<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">0</span>; --i)<br>        <span class="hljs-keyword">if</span>(a[i]!=b[i])<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> Wint &amp;a,<span class="hljs-type">const</span> Wint &amp;b)<br>&#123;<br>    <span class="hljs-keyword">return</span> !(a!=b);<br>&#125;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Wint &amp;a,<span class="hljs-type">const</span> Wint &amp;b)<br>&#123;<br>    <span class="hljs-keyword">if</span>(a.<span class="hljs-built_in">size</span>()!=b.<span class="hljs-built_in">size</span>())<span class="hljs-keyword">return</span> a.<span class="hljs-built_in">size</span>()&lt;b.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">0</span>; --i)<br>        <span class="hljs-keyword">if</span>(a[i]!=b[i])<span class="hljs-keyword">return</span> a[i]&lt;b[i];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;(<span class="hljs-type">const</span> Wint &amp;a,<span class="hljs-type">const</span> Wint &amp;b)<br>&#123;<br>    <span class="hljs-keyword">return</span> b&lt;a;<br>&#125;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;=(<span class="hljs-type">const</span> Wint &amp;a,<span class="hljs-type">const</span> Wint &amp;b)<br>&#123;<br>    <span class="hljs-keyword">return</span> !(a&gt;b);<br>&#125;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;=(<span class="hljs-type">const</span> Wint &amp;a,<span class="hljs-type">const</span> Wint &amp;b)<br>&#123;<br>    <span class="hljs-keyword">return</span> !(a&lt;b);<br>&#125;<br><br><span class="hljs-comment">//大数加法，逐位相加后整理格式</span><br>Wint&amp; <span class="hljs-keyword">operator</span>+=(Wint &amp;a,<span class="hljs-type">const</span> Wint &amp;b)<br>&#123;<br>    <span class="hljs-keyword">if</span>(a.<span class="hljs-built_in">size</span>()&lt;b.<span class="hljs-built_in">size</span>())a.<span class="hljs-built_in">resize</span>(b.<span class="hljs-built_in">size</span>());<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i!=b.<span class="hljs-built_in">size</span>(); ++i)a[i]+=b[i];<br>    <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">check</span>();<br>&#125;<br>Wint <span class="hljs-keyword">operator</span>+(Wint a,<span class="hljs-type">const</span> Wint &amp;b)<br>&#123;<br>    <span class="hljs-keyword">return</span> a+=b;<br>&#125;<br><br><span class="hljs-comment">//大数减法，重点在于连续借位</span><br>Wint&amp; <span class="hljs-keyword">operator</span>-=(Wint &amp;a,Wint b)<br>&#123;<br>    <span class="hljs-keyword">if</span>(a&lt;b)<span class="hljs-built_in">swap</span>(a,b);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i!=b.<span class="hljs-built_in">size</span>(); a[i]-=b[i],++i)<br>        <span class="hljs-keyword">if</span>(a[i]&lt;b[i])<span class="hljs-comment">//需要借位</span><br>        &#123;<br>            <span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(!a[j])++j;<br>            <span class="hljs-keyword">while</span>(j&gt;i)<br>            &#123;<br>                --a[j];<br>                a[--j]+=<span class="hljs-number">10</span>;<br>            &#125;<br>        &#125;<br>    <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">check</span>();<br>&#125;<br>Wint <span class="hljs-keyword">operator</span>-(Wint a,<span class="hljs-type">const</span> Wint &amp;b)<br>&#123;<br>    <span class="hljs-keyword">return</span> a-=b;<br>&#125;<br><br>Wint <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Wint &amp;a,<span class="hljs-type">const</span> Wint &amp;b)<br>&#123;<br>    Wint n;<br>    n.<span class="hljs-built_in">assign</span>(a.<span class="hljs-built_in">size</span>()+b.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i!=a.<span class="hljs-built_in">size</span>(); ++i)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j!=b.<span class="hljs-built_in">size</span>(); ++j)<br>            n[i+j]+=a[i]*b[j];<br>    <span class="hljs-keyword">return</span> n.<span class="hljs-built_in">check</span>();<br>&#125;<br>Wint&amp; <span class="hljs-keyword">operator</span>*=(Wint &amp;a,<span class="hljs-type">const</span> Wint &amp;b)<br>&#123;<br>    <span class="hljs-keyword">return</span> a=a*b;<br>&#125;<br><br><span class="hljs-function">Wint <span class="hljs-title">divmod</span><span class="hljs-params">(Wint &amp;a,<span class="hljs-type">const</span> Wint &amp;b)</span></span><br><span class="hljs-function"></span>&#123;<br>    Wint ans;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> t=a.<span class="hljs-built_in">size</span>()-b.<span class="hljs-built_in">size</span>(); a&gt;=b; --t)<br>    &#123;<br>        Wint d;<br>        d.<span class="hljs-built_in">assign</span>(t+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>        d.<span class="hljs-built_in">back</span>()=<span class="hljs-number">1</span>;<br>        Wint c=b*d;<br>        <span class="hljs-keyword">while</span>(a&gt;=c)<br>        &#123;<br>            a-=c;<br>            ans+=d;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br>Wint <span class="hljs-keyword">operator</span>/(Wint a,<span class="hljs-type">const</span> Wint &amp;b)<br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">divmod</span>(a,b);<br>&#125;<br>Wint&amp; <span class="hljs-keyword">operator</span>/=(Wint &amp;a,<span class="hljs-type">const</span> Wint &amp;b)<br>&#123;<br>    <span class="hljs-keyword">return</span> a=a/b;<br>&#125;<br>Wint&amp; <span class="hljs-keyword">operator</span>%=(Wint &amp;a,<span class="hljs-type">const</span> Wint &amp;b)<br>&#123;<br>    <span class="hljs-built_in">divmod</span>(a,b);<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br>Wint <span class="hljs-keyword">operator</span>%(Wint a,<span class="hljs-type">const</span> Wint &amp;b)<br>&#123;<br>    <span class="hljs-keyword">return</span> a%=b;<br>&#125;<br><br>Wint&amp; <span class="hljs-keyword">operator</span> !(Wint &amp;a)&#123;<br>    <span class="hljs-keyword">if</span>(a == <span class="hljs-built_in">Wint</span>(<span class="hljs-number">0</span>) || a == <span class="hljs-built_in">Wint</span>(<span class="hljs-number">1</span>))&#123;<br>        a = <span class="hljs-built_in">Wint</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        Wint n = a;<br>        a = <span class="hljs-built_in">Wint</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-function">Wint <span class="hljs-title">i</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(;i &lt;= n;i += <span class="hljs-built_in">Wint</span>(<span class="hljs-number">1</span>))&#123;<br>            a *= i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="引爆炸弹"><a href="#引爆炸弹" class="headerlink" title="引爆炸弹"></a>引爆炸弹</h2><p class="note note-primary">DFS</p><p>在一个 n<em>×</em>m 的方格地图上，某些方格上放置着炸弹。手动引爆一个炸弹以后，炸弹会把炸弹所在的行和列上的所有炸弹引爆，被引爆的炸弹又能引爆其他炸弹，这样连锁下去。</p><p><a href="https://res.jisuanke.com/img/upload/20170327/5dba781484cd6db80572f3bd5fe136b93e3b2e60.png"><img src="https://res.jisuanke.com/img/upload/20170327/5dba781484cd6db80572f3bd5fe136b93e3b2e60.png" alt="img"></a></p><p>现在为了引爆地图上的所有炸弹，需要手动引爆其中一些炸弹，为了把危险程度降到最低，请算出最少手动引爆多少个炸弹可以把地图上的所有炸弹引爆。</p><h3 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行输两个整数 n,m，用空格隔开。</p><p>接下来 n 行，每行输入一个长度为 m 的字符串，表示地图信息。<code>0</code>表示没有炸弹，<code>1</code>表示炸弹。</p><p>数据约定：</p><p>对于 40% 的数据：1≤<em>n</em>,<em>m</em>≤100；</p><p>对于 100% 的数据：1≤<em>n</em>,<em>m</em>≤500；</p><h3 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个整数，表示最少需要手动引爆的炸弹数。</p><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>​使用深度搜索，先引爆一个炸弹，获得一个全新的地图，然后再引爆剩下的炸弹，直到所有的炸弹都被引爆完，然后取较少的引爆次数，直到所有的情况都遍历完获得答案。（这题为什么没有首先考虑广度优先搜索，原因在于地图的面积是很小的，因此在炸弹稀疏的情况下能够较快被引爆完，而选择广度优先搜索的话会占用大量的队列空间）。</p><p>代码如下（具体实现步骤看代码注释）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 使用深度搜索，先引爆一个炸弹，获得一个全新的地图，然后再引爆剩下的炸弹，直到所有的炸弹都被引爆完，</span><br><span class="hljs-comment"> * 然后取较少的引爆次数，直到所有的情况都遍历完获得答案。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span>&#123;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br>    <span class="hljs-built_in">Point</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y):<span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">y</span>(y) &#123;&#125;<br>&#125;;<br><br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt; (ostream&amp; os, <span class="hljs-type">const</span> Point &amp;pos)&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; pos.x &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; pos.y &lt;&lt; <span class="hljs-string">&quot;)&quot;</span>;<br>    <span class="hljs-keyword">return</span> os;<br>&#125;<br><br><span class="hljs-comment">//int min = 0x3f3f3f3f;</span><br><br><span class="hljs-comment">//查看zone中炸弹的位置,如果没有炸弹返回false</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;string&gt; &amp;zone,vector&lt;Point&gt; &amp;bombs)</span></span>&#123;<br>    <span class="hljs-type">int</span> row, col;<br>    row = zone.<span class="hljs-built_in">size</span>();<br>    col = zone[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> i , j;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i &lt; row;i++)&#123;<br>        <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>;j &lt; col;j++)&#123;<br>            <span class="hljs-keyword">if</span>(zone[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>                bombs.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Point</span>(i, j));<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(bombs.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">//引爆其中一个炸弹，并且连锁引爆同一条线上的其他炸弹，获得一个新的地图</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fire_one</span><span class="hljs-params">(vector&lt;string&gt; &amp;zone, Point fire_pos)</span></span>&#123;<br>    <span class="hljs-type">int</span> row = fire_pos.x;<br>    <span class="hljs-type">int</span> col = fire_pos.y;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; zone.<span class="hljs-built_in">size</span>();i++)&#123;<br>        <span class="hljs-keyword">if</span>(zone[i][col] == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>            zone[i][col] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; zone[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();j++)&#123;<br>        <span class="hljs-keyword">if</span>(zone[row][j] == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>            zone[row][j] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//深度搜索函数，参数：zone, 引爆位置，最少炸弹个数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(vector&lt;string&gt; zone, Point fire_pos, <span class="hljs-type">int</span> cur_min, <span class="hljs-type">int</span> &amp;min)</span></span>&#123;<br>    <span class="hljs-built_in">fire_one</span>(zone, fire_pos);<br>    vector&lt;Point&gt; bombs;              <span class="hljs-comment">//存放地图上剩余的所有炸弹</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(zone, bombs))&#123;<br>        <span class="hljs-keyword">while</span>(bombs.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-built_in">bfs</span>(zone, bombs.<span class="hljs-built_in">back</span>(), cur_min + <span class="hljs-number">1</span>, min);<br>            bombs.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span>(cur_min &lt; min)&#123;<br>            min = cur_min;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">//找出地图上的所有炸弹，然后对每一种情况深度优先搜索，最后比较出最小的那个</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fire_bombs</span><span class="hljs-params">(vector&lt;string&gt; &amp;zone)</span></span>&#123;<br>    <span class="hljs-type">int</span> min = <span class="hljs-number">0x3f3f3f3f</span>;<br>    vector&lt;Point&gt; bombs;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(zone, bombs))&#123;<br>        <span class="hljs-keyword">while</span>(bombs.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-built_in">bfs</span>(zone, bombs.<span class="hljs-built_in">back</span>(), <span class="hljs-number">0</span>, min);<br>            bombs.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> min;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    cout &lt;&lt; <span class="hljs-string">&quot;please input row and col:\n&quot;</span>;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    <span class="hljs-comment">//初始化地图zone</span><br>    vector&lt;string&gt; zone;<br>    string tmp;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)&#123;<br>        cin &gt;&gt; tmp;<br>        zone.<span class="hljs-built_in">push_back</span>(tmp);<br>    &#125;<br>    <span class="hljs-type">int</span> min = <span class="hljs-built_in">fire_bombs</span>(zone);<br>    cout &lt;&lt; <span class="hljs-string">&quot;min:&quot;</span> &lt;&lt; min &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="一维跳棋"><a href="#一维跳棋" class="headerlink" title="一维跳棋"></a>一维跳棋</h2><p class="note note-primary">BFS</p><p>一维跳棋是一种在 1×(2<em>N</em>+1) 的棋盘上玩的游戏。一共有 N 个棋子，其中 N 个是黑的，N个是白的。游戏开始前，N 个白棋子被放在一头，N 个黑棋子被放在另一头，中间的格子空着。在这个游戏里有两种移动方法是允许的：你可以把一个棋子移到与它相邻的空格；你可以把一个棋子跳过一个（仅一个）与它不同色的棋子到达空格。</p><p>对于N&#x3D;3 的情况，棋盘状态依次为：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">WWW <span class="hljs-keyword">BBB</span><br><span class="hljs-keyword"></span>WW WBBB<br>WWBW <span class="hljs-keyword">BB</span><br><span class="hljs-keyword"></span>WWBWB <span class="hljs-keyword">B</span><br><span class="hljs-keyword"></span>WWB <span class="hljs-keyword">BWB</span><br><span class="hljs-keyword"></span>W <span class="hljs-keyword">BWBWB</span><br><span class="hljs-keyword"></span> WBWBWB<br><span class="hljs-keyword">BW </span>WBWB<br><span class="hljs-keyword">BWBW </span>WB<br><span class="hljs-keyword">BWBWBW</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">BWBWB </span>W<br><span class="hljs-keyword">BWB </span><span class="hljs-keyword">BWW</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">B </span><span class="hljs-keyword">BWBWW</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">BB </span>WBWW<br><span class="hljs-keyword">BBBW </span>WW<br><span class="hljs-keyword">BBB </span>WWW<br></code></pre></td></tr></table></figure><p>对应的空格所在的位置（从左数）为：3 5 6 4 2 1 3 5 7 6 4 2 3 5 4。</p><h3 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入仅一个整数，表示针对 N(1≤N≤8) 的取值。</p><h3 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h3><p>依次输出空格所在棋盘的位置，每个整数间用空格分隔，每行 5个数（每行结尾无空格，最后一行可以不满 5个数；如果有多组移动步数最小的解，输出第一个数最小的解）。</p><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>求最小的解一般优先考虑广度优先搜索，本题就是这个例子。对于每一种棋况，考虑空格能够移动的情况，而最多的可能情况只有4种：空格往左移动，往右移动一格，当左边（右边）的相邻两个棋子不同时，可以往左（右）跳1格。因此，我们只用检查每一种情况，把符合情况的新棋况放入一格队列中，然后继续取出头部的元素进行搜索，直到遇到结果的情况。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>map&lt;string, <span class="hljs-type">bool</span>&gt; visited;<br><br><span class="hljs-comment">//一种局势状态</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">stat</span>&#123;<br>    string board;<br>    <span class="hljs-type">int</span> space_index;<br>    <span class="hljs-type">int</span> parent;<br>    <span class="hljs-built_in">stat</span>(string b, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> pa):<span class="hljs-built_in">board</span>(b), <span class="hljs-built_in">space_index</span>(index), <span class="hljs-built_in">parent</span>(pa) &#123;&#125;<br>    <br>    <span class="hljs-comment">//将当前局势状态下形成的所有合理新局势状态放入new_stat中</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">check</span><span class="hljs-params">(vector&lt;stat&gt; &amp;new_stat, <span class="hljs-type">int</span> pa)</span> <span class="hljs-type">const</span></span>&#123;        <br>        <span class="hljs-comment">//判断空格是否可以向左移动</span><br>        <span class="hljs-keyword">if</span>(space_index != <span class="hljs-number">0</span>)&#123;<br>            string new_board = board;<br>            <span class="hljs-comment">//最先判断空格是否可以向左跳一格，以保证结果序列中空格坐标小的值排在最前面</span><br>            <span class="hljs-keyword">if</span>(space_index != <span class="hljs-number">1</span>)&#123;                <br>                <span class="hljs-keyword">if</span>(new_board[space_index - <span class="hljs-number">2</span>] != new_board[space_index - <span class="hljs-number">1</span>])&#123;<br>                    new_board[space_index] = new_board[space_index - <span class="hljs-number">2</span>];<br>                    new_board[space_index - <span class="hljs-number">2</span>] = <span class="hljs-string">&#x27; &#x27;</span>;<br>                    <span class="hljs-keyword">if</span>(visited.<span class="hljs-built_in">find</span>(new_board) == visited.<span class="hljs-built_in">end</span>())&#123;<br>                        new_stat.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">stat</span>(new_board, space_index - <span class="hljs-number">2</span>, pa));<br>                    &#125; <br>                &#125;<br>            &#125;<br>            <br>            <span class="hljs-comment">//再判断空格是否可以向左移动一格</span><br>            new_board = board;<br>            new_board[space_index] = new_board[space_index - <span class="hljs-number">1</span>];<br>            new_board[space_index - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27; &#x27;</span>;<br>            <span class="hljs-keyword">if</span>(visited.<span class="hljs-built_in">find</span>(new_board) == visited.<span class="hljs-built_in">end</span>())&#123;<br>                new_stat.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">stat</span>(new_board, space_index - <span class="hljs-number">1</span>, pa));<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> size = board.<span class="hljs-built_in">size</span>();<br>      <span class="hljs-comment">//判断空格是否可以向右移动</span><br>        <span class="hljs-keyword">if</span>(space_index != size - <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-comment">//先假设向右移动一格</span><br>            string new_board = board;<br>            new_board[space_index] = new_board[space_index + <span class="hljs-number">1</span>];<br>            new_board[space_index + <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27; &#x27;</span>;<br>            <span class="hljs-keyword">if</span>(visited.<span class="hljs-built_in">find</span>(new_board) == visited.<span class="hljs-built_in">end</span>())&#123;<br>                new_stat.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">stat</span>(new_board, space_index + <span class="hljs-number">1</span>, pa));<br>            &#125;<br>            <span class="hljs-comment">//判断空格是否可以向右跳一格</span><br>            <span class="hljs-keyword">if</span>(space_index != size - <span class="hljs-number">2</span>)&#123;<br>                new_board = board;<br>                <span class="hljs-keyword">if</span>(new_board[space_index + <span class="hljs-number">1</span>] != new_board[space_index + <span class="hljs-number">2</span>])&#123;<br>                    new_board[space_index] = new_board[space_index + <span class="hljs-number">2</span>];<br>                    new_board[space_index + <span class="hljs-number">2</span>] = <span class="hljs-string">&#x27; &#x27;</span>;<br>                    <span class="hljs-keyword">if</span>(visited.<span class="hljs-built_in">find</span>(new_board) == visited.<span class="hljs-built_in">end</span>())&#123;<br>                        new_stat.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">stat</span>(new_board, space_index + <span class="hljs-number">2</span>, pa));<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//声明非循环队列，继承自vector(因为不需要删除首个元素)</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">myQueue</span>:vector&lt;stat&gt;&#123;<br>    <span class="hljs-type">int</span> front;<br>    <span class="hljs-built_in">myQueue</span>()&#123;front = <span class="hljs-number">0</span>;&#125;<br>    <br>    <span class="hljs-function">stat <span class="hljs-title">get_front</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">at</span>(front);<br>    &#125;<br>    <span class="hljs-comment">//只是头指针移动，而不弹出结点，以回溯路径</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">qu_pop</span><span class="hljs-params">()</span></span>&#123;<br>        front++;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//初始化</span><br>    <span class="hljs-type">int</span> n;<br>    cout &lt;&lt; <span class="hljs-string">&quot;please input number of every side:&quot;</span>;<br>    cin &gt;&gt; n;<br>    myQueue qu;<br>    string start, end;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>; i++)&#123;<br>        <span class="hljs-keyword">if</span>(i &lt; n)&#123;<br>            start.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;w&#x27;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i == n)&#123;<br>            start.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27; &#x27;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            start.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;b&#x27;</span>);<br>        &#125;<br>    &#125;<br>    string::reverse_iterator r_it;<br>    <span class="hljs-keyword">for</span>(r_it = start.<span class="hljs-built_in">rbegin</span>(); r_it != start.<span class="hljs-built_in">rend</span>(); r_it++)&#123;<br>        end.<span class="hljs-built_in">push_back</span>(*r_it);<br>    &#125;<br>    <br>    <span class="hljs-comment">//将最初的局势状态放入队列中</span><br>    <span class="hljs-function">stat <span class="hljs-title">tmp</span><span class="hljs-params">(start, n, <span class="hljs-number">-1</span>)</span></span>;<br>    qu.<span class="hljs-built_in">push_back</span>(tmp);<br>    visited[tmp.board] = <span class="hljs-literal">true</span>;<br>    <br>    vector&lt;stat&gt; new_stat;  <span class="hljs-comment">//用于存放生成的新状态</span><br>    <br>    <span class="hljs-comment">//处理队列中的元素</span><br>    <span class="hljs-keyword">while</span>(qu.<span class="hljs-built_in">size</span>() != qu.front)&#123;<br>        tmp = qu.<span class="hljs-built_in">get_front</span>();  <span class="hljs-comment">//获取首个未处理的元素</span><br>        <br>        <span class="hljs-comment">//如果该元素为目标，则回溯路径，输出结果</span><br>        <span class="hljs-keyword">if</span>(tmp.board == end)&#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>            <span class="hljs-keyword">while</span>(tmp.parent != <span class="hljs-number">-1</span>)&#123;<br>                ans.<span class="hljs-built_in">push_back</span>(tmp.space_index);<br>                tmp = qu.<span class="hljs-built_in">at</span>(tmp.parent);<br>            &#125;<br>            vector&lt;<span class="hljs-type">int</span>&gt;::reverse_iterator re_it;<br>            <span class="hljs-keyword">for</span>(re_it = ans.<span class="hljs-built_in">rbegin</span>(); re_it != ans.<span class="hljs-built_in">rend</span>(); re_it++)&#123;<br>                cout &lt;&lt; *re_it + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>            &#125;cout &lt;&lt; endl;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <br>        <span class="hljs-type">int</span> pa = qu.front;   <span class="hljs-comment">//记录每个新元素的父元素在队列中的位置，以回溯路径</span><br>        qu.<span class="hljs-built_in">qu_pop</span>();<br>        new_stat.<span class="hljs-built_in">clear</span>();<br>        tmp.<span class="hljs-built_in">check</span>(new_stat, pa);<br>        vector&lt;stat&gt;::iterator it;<br>        <span class="hljs-keyword">for</span>(it = new_stat.<span class="hljs-built_in">begin</span>(); it != new_stat.<span class="hljs-built_in">end</span>(); it++)&#123;<br>            visited[it-&gt;board] = <span class="hljs-literal">true</span>;<br>            qu.<span class="hljs-built_in">push_back</span>(*it);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="数独"><a href="#数独" class="headerlink" title="数独"></a>数独</h2><p class="note note-primary">DFS</p><p>蒜头君今天突然开始还念童年了，想回忆回忆童年。他记得自己小时候，有一个很火的游戏叫做数独。便开始来了一局紧张而又刺激的高阶数独。蒜头君做完发现没有正解，不知道对不对？ 不知道聪明的你能否给出一个标准答案？</p><p>标准数独是由一个给与了提示数字的 9×9 网格组成，我们只需将其空格填上数字，使得每一行，每一列以及每一个 3×3 宫都没有重复的数字出现。</p><p><a href="https://res.jisuanke.com/img/upload/20180109/c3dfbb8ec436c33bfef3a976cca3516a76192cb8.png"><img src="https://res.jisuanke.com/img/upload/20180109/c3dfbb8ec436c33bfef3a976cca3516a76192cb8.png" alt="img"></a></p><h3 id="输入格式-4"><a href="#输入格式-4" class="headerlink" title="输入格式"></a>输入格式</h3><p>一个 9×9 的数独，数字之间用空格隔开。<code>0</code>表示需要填写的数字。</p><h3 id="输出格式-4"><a href="#输出格式-4" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一个 9×9 的数独，把出入中的<code>0</code>替换成需要填写的数字即可。</p><h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><p>由于只用求出一个解，所以使用深度优先搜索，由于在填数字的过程中需要频繁地查找地图中的元素以判断是否违反规则。如果直接查找，则每一次都需要消耗大约9+9+9个时间单位，但其实这是没有必要的，因为我们只需要知道和它相同的值是否在同一条线或者同一个九宫格内就行，因此这里可以使用哈希表来降低查找时间。</p><p>对于查找到的每一个空格，我们需要遍历数字1~9，如果填入该数字后不会违反规则，我们就填入它，然后查找下一个空格，直到这个查找的指针遍历到最后一个位置，算法结束。如果当前空格已经遍历完所有可能的数字，则将该位置重置为0，并且从哈希表中删除它，再回到前一个位置进行遍历。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/** </span><br><span class="hljs-comment"> * ubuntu sukodu 秒杀算法</span><br><span class="hljs-comment"> * 使用vector存储board，数据类型为int,空余位置用0来替代</span><br><span class="hljs-comment"> * 规则:每行，每列和每个小方格里面都是数字1-9</span><br><span class="hljs-comment"> * 能够快速初始化界面</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 解决办法：深度优先搜索</span><br><span class="hljs-comment"> * 对于每一个位置，找出它的所有可能数字，然后在此基础上处理下一个位置</span><br><span class="hljs-comment"> * 检查是否符合规则：用哈希表存储相同数字的位置，删除方法：遍历该vector</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> row;<br>    <span class="hljs-type">int</span> col;<br>    <span class="hljs-built_in">Point</span>(<span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c)&#123;<br>        row = r;<br>        col = c;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">equal</span><span class="hljs-params">(Point a)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> a.row == row &amp;&amp; a.col == col;<br>    &#125;<br>&#125;;<br><br>unordered_map&lt;<span class="hljs-type">int</span>, vector&lt;Point&gt; &gt; points;<br><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">board</span>(<span class="hljs-number">9</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">9</span>, <span class="hljs-number">0</span>));<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init_board</span><span class="hljs-params">()</span></span>&#123;<br>    string input;<br>    <span class="hljs-comment">//8 + 9</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;format: &quot;</span> &lt;&lt; <span class="hljs-string">&quot;123456789\n&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;-----------------\n&quot;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>;i++)&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;line &quot;</span> &lt;&lt; i + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot;: &quot;</span>;<br>        <span class="hljs-built_in">getline</span>(cin, input);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; j++)&#123;<br>            board[i][j] = (<span class="hljs-type">int</span>)(input[j] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>            <span class="hljs-keyword">if</span>(board[i][j])points[board[i][j]].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Point</span>(i, j));<br>        &#125;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">//检查该位置放置的数字是否符合条件</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> val, Point pos)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it = points[val].<span class="hljs-built_in">begin</span>(); it != points[val].<span class="hljs-built_in">end</span>(); it++)&#123;<br>        <span class="hljs-keyword">if</span>(pos.row == it-&gt;row || pos.col == it-&gt;col)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span>(pos.row/<span class="hljs-number">3</span> == it-&gt;row/<span class="hljs-number">3</span> &amp;&amp; pos.col/<span class="hljs-number">3</span> == it-&gt;col/<span class="hljs-number">3</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">del</span><span class="hljs-params">(<span class="hljs-type">int</span> val, Point pos)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it = points[val].<span class="hljs-built_in">begin</span>(); it != points[val].<span class="hljs-built_in">end</span>(); it++)&#123;<br>        <span class="hljs-keyword">if</span>(it-&gt;<span class="hljs-built_in">equal</span>(pos))&#123;<br>            points[val].<span class="hljs-built_in">erase</span>(it);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//获取第一个需要填写的位置坐标</span><br><span class="hljs-function">Point <span class="hljs-title">init_pos</span><span class="hljs-params">(Point pos)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(board[pos.row][pos.col])&#123;<br>        <span class="hljs-keyword">if</span>(pos.<span class="hljs-built_in">equal</span>(<span class="hljs-built_in">Point</span>(<span class="hljs-number">8</span>, <span class="hljs-number">8</span>)))&#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;it&#x27;s full!\n&quot;</span>;<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(pos.col == <span class="hljs-number">8</span>)&#123;<br>            pos.row++;<br>            pos.col = <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            pos.col++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pos;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">disp_board</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">9</span>;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>;j++)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;,%d&quot;</span> + !j, board[i][j]);<br>        &#125;cout &lt;&lt; endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">DFS</span><span class="hljs-params">(Point pos)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">9</span>;i++)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(i, pos))&#123;<br>            board[pos.row][pos.col] = i;<br>            points[i].<span class="hljs-built_in">push_back</span>(pos);<br>            <span class="hljs-function">Point <span class="hljs-title">new_pos</span><span class="hljs-params">(pos)</span></span>;<br>            <span class="hljs-keyword">while</span>(board[new_pos.row][new_pos.col])&#123;<br>                <span class="hljs-keyword">if</span>(new_pos.<span class="hljs-built_in">equal</span>(<span class="hljs-built_in">Point</span>(<span class="hljs-number">8</span>, <span class="hljs-number">8</span>)))&#123;<br>                    <span class="hljs-built_in">disp_board</span>();<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(new_pos.col == <span class="hljs-number">8</span>)&#123;<br>                    new_pos.row++;<br>                    new_pos.col = <span class="hljs-number">0</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    new_pos.col++;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//找到一个空位置</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">DFS</span>(new_pos))<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            board[pos.row][pos.col] = <span class="hljs-number">0</span>;<br>            <span class="hljs-built_in">del</span>(i, pos);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">init_board</span>();<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">DFS</span>(<span class="hljs-built_in">init_pos</span>(<span class="hljs-built_in">Point</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>))))cout &lt;&lt; <span class="hljs-string">&quot;no solution!\n&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br><h2 id="任务系统"><a href="#任务系统" class="headerlink" title="任务系统"></a>任务系统</h2><p class="note note-primary">优先队列</p><p>蒜头君设计了一个任务系统。这个系统是为了定时提醒蒜头君去完成一些事情。</p><p>系统大致如下，初始的时候，蒜头君可能会注册很多任务，每一个任务的注册如下:</p><p>Register $Q_{num}$ Period</p><p>表示从系统启动开始，每过 Period 秒提醒蒜头君完成编号为 $Q_{num}$的任务。</p><p>你能计算出蒜头君最先被提醒的 k个任务吗？</p><h3 id="输入格式-5"><a href="#输入格式-5" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行输入 n(0&lt;n≤50000)，k(0&lt;k≤10000)，其中 n表示蒜头君注册的任务数量。</p><p>接下来 n行，每行输入一条注册命令，其中0&lt;$q_{num}$≤3000，0≤Period≤3000。</p><h3 id="输出格式-5"><a href="#输出格式-5" class="headerlink" title="输出格式"></a>输出格式</h3><p>顺序输出 k行，表示依次提醒的任务的编号。如果同一时间有多个任务，最先提醒编号小的任务。</p><h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><p>使用优先队列（堆结构），每次弹出时间最近的任务后，更新该任务的下一次触发时间放入队列中排序，直到前k次输出完。</p><p>eg: 堆结构经常是在插入和弹出之间交替进行的。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; single_time;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">task</span>&#123;<br>    <span class="hljs-type">int</span> num, time;<br>    <span class="hljs-built_in">task</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y):<span class="hljs-built_in">num</span>(x), <span class="hljs-built_in">time</span>(y) &#123;&#125;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> task &amp;a) <span class="hljs-type">const</span>&#123;<br>        <span class="hljs-keyword">if</span>(time &gt; a.time)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(time == a.time &amp;&amp; num &gt; a.num)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">//优先队列的排序规则：对于运算符 &lt; , 如果返回true，就把前一个参数排在前面，而</span><br><span class="hljs-comment">//优先队列总是弹出最后一个元素</span><br>priority_queue&lt;task&gt; qu;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n ,k;<br>    cin &gt;&gt; n &gt;&gt; k;<br>    string buff;<br>    <span class="hljs-type">int</span> num, time;<br>    <span class="hljs-keyword">while</span>(n--)&#123;<br>        cin &gt;&gt; buff &gt;&gt; num &gt;&gt; time;<br>        single_time[num] = time;<br>        qu.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">task</span>(num, time));<br>    &#125;<br>    <span class="hljs-keyword">while</span>(k--)&#123;<br>        task tmp = qu.<span class="hljs-built_in">top</span>();<br>        qu.<span class="hljs-built_in">pop</span>();<br>        cout &lt;&lt; tmp.num &lt;&lt; endl;<br>        <span class="hljs-comment">//更新下一次的触发时间，并放入优先队列中</span><br>        tmp.time += single_time[tmp.num];<br>        qu.<span class="hljs-built_in">push</span>(tmp);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>枚举</tag>
      
      <tag>高精度</tag>
      
      <tag>DFS</tag>
      
      <tag>BFS</tag>
      
      <tag>优先队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity-数据保存和加载</title>
    <link href="/2022/11/13/Unity-%E6%95%B0%E6%8D%AE%E4%BF%9D%E5%AD%98%E5%92%8C%E5%8A%A0%E8%BD%BD/"/>
    <url>/2022/11/13/Unity-%E6%95%B0%E6%8D%AE%E4%BF%9D%E5%AD%98%E5%92%8C%E5%8A%A0%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="Unity-数据保存和加载"><a href="#Unity-数据保存和加载" class="headerlink" title="Unity-数据保存和加载"></a>Unity-数据保存和加载</h1><h2 id="Json"><a href="#Json" class="headerlink" title="Json"></a>Json</h2><p>使用Unity自带的JsonUtility</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-built_in">string</span> dataString = JsonUtility.ToJson(data);<br>data = JsonUtility.FromJson&lt;SaveData&gt;(dataString);<br></code></pre></td></tr></table></figure><h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><h2 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h2><p>适用于玩家存档</p><p>使用<code>BinaryFormatter</code>序列化和反序列化二进制数据，使用<code>FileStream</code>创建或打开文件流</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> UnityEditor;<br><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.IO;<br><span class="hljs-keyword">using</span> System.Runtime.Serialization.Formatters.Binary;<br><br>[<span class="hljs-meta">Serializable</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SaveData</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> HP;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> atk;<br>&#125;;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">JsonTest</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    [<span class="hljs-meta">SerializeField</span>] <span class="hljs-keyword">public</span> SaveData data;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnGUI</span>()</span> <br>    &#123;<br>        <span class="hljs-built_in">string</span> filePath = Application.persistentDataPath + <span class="hljs-string">&quot;/game.save&quot;</span>;<br>        <span class="hljs-keyword">if</span>(GUILayout.Button(<span class="hljs-string">&quot;Save&quot;</span>)) <br>        &#123;<br>            BinaryFormatter formatter = <span class="hljs-keyword">new</span> BinaryFormatter();<br>            <span class="hljs-keyword">using</span>(FileStream file = File.Create(filePath)) &#123;<br>                formatter.Serialize(file, data);<br>            &#125;<br>            Debug.Log(<span class="hljs-string">&quot;save at: &quot;</span> + filePath);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(GUILayout.Button(<span class="hljs-string">&quot;Load&quot;</span>)) <br>        &#123;<br>            <span class="hljs-keyword">if</span>(File.Exists(filePath)) <br>            &#123;<br>                BinaryFormatter formatter = <span class="hljs-keyword">new</span> BinaryFormatter();<br>                <span class="hljs-keyword">using</span>(FileStream file = File.Open(filePath, FileMode.Open)) &#123;<br>                    data = formatter.Deserialize(file) <span class="hljs-keyword">as</span> SaveData;<br>                &#125;<br>                Debug.Log(<span class="hljs-string">&quot;load at: &quot;</span> + filePath);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PBRT-反射模型</title>
    <link href="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/"/>
    <url>/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="PBRT-反射模型"><a href="#PBRT-反射模型" class="headerlink" title="PBRT-反射模型"></a>PBRT-反射模型</h1><h2 id="前置概念"><a href="#前置概念" class="headerlink" title="前置概念"></a>前置概念</h2><h3 id="表面反射模型来源"><a href="#表面反射模型来源" class="headerlink" title="表面反射模型来源"></a>表面反射模型来源</h3><p>测量数据：测量得到的真实世界表面反射分布特性</p><p>现象学模型：试图描述真实世界表面定性特性的方程，往往具有修改其行为的直观参数</p><p>模拟：模拟来自微观几何的光散射以生成反射数据</p><p>物理光学：使用光的详细模型推导，计算成本往往很高</p><p>几何光学：与模拟方法一样，如果已知表面的低级散射和几何特性，有时可以直接从这些描述中导出封闭形式的反射模型</p><h3 id="反射类别"><a href="#反射类别" class="headerlink" title="反射类别"></a>反射类别</h3><h4 id="漫反射"><a href="#漫反射" class="headerlink" title="漫反射"></a>漫反射</h4><p>在所有表面上均匀散射光</p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220803172709083.png" alt="image-20220803172709083"></p><h4 id="光泽镜面反射"><a href="#光泽镜面反射" class="headerlink" title="光泽镜面反射"></a>光泽镜面反射</h4><p>优先在一组反射方向上散射光，它们显示其他对象的模糊反射，如塑料或高光涂料</p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220803172825184-9518906.png" alt="image-20220803172825184"></p><h4 id="完美镜面反射"><a href="#完美镜面反射" class="headerlink" title="完美镜面反射"></a>完美镜面反射</h4><p>将入射光散射到一个单一的出射方向，如镜子和玻璃</p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220803172943090.png" alt="image-20220803172943090"></p><h4 id="逆反射"><a href="#逆反射" class="headerlink" title="逆反射"></a>逆反射</h4><p>沿着入射光的方向散射光</p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220803172956661.png" alt="image-20220803172956661"></p><p>大多数反射分布函数是各向同性的，即入射光沿绕着一个点的法线轴进行旋转，其反射光的分布不会改变。对于各向异性而言，则会反射不同数量的光，比如拉丝金属、布和光盘</p><h3 id="材质类别"><a href="#材质类别" class="headerlink" title="材质类别"></a>材质类别</h3><ul><li>电介质，是不导电的材质。它们具有实数值的折射率并透射一部分入射光，如玻璃、矿物油、水、空气</li><li>金属导体。材质是不透明的，并反射大部分照明，一部分光也传输到导体内部被吸收，在pbrt中忽略透射效应，只对导体的反射分量进行建模，导体具有复数值的折射率$\bar\eta &#x3D; \eta + i k$</li><li>半导体。pbrt中不讨论这种材质</li></ul><h3 id="反射坐标系"><a href="#反射坐标系" class="headerlink" title="反射坐标系"></a>反射坐标系</h3><p>计算反射时使用的坐标系，由正交基向量$(s, t, n)$定义，在调用BSDF方法之前，世界空间中的$w$方向向量被转换到该坐标系中</p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220803173503728.png" alt="image-20220803173503728"></p><p>也可以使用球坐标来表示：</p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220803173552071.png" alt="image-20220803173552071"></p><p>其转换公式为：</p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220803173642332.png" alt="image-20220803173642332"></p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220803173657471.png" alt="image-20220803173657471"></p><h3 id="反射率"><a href="#反射率" class="headerlink" title="反射率"></a>反射率</h3><p><strong>半球-方向反射率</strong>是一个2D函数，它在给定方向上由于在半球上的恒定照明而产生全反射，或者等效地，由于来自给定方向的光而在半球上产生全反射，他被定义为</p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220804110253016.png" alt="image-20220804110253016"></p><p>注意，该方程和散射方程相比少了入射辐射度那一项，即$L_i(p, w_i)$</p><p>表面的<strong>半球-半球反射率</strong>公式如下：</p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220804110803145.png" alt="image-20220804110803145"></p><p>当入射光的方向相同时，它给出表面反射的入射光的分量。对于内层积分，得到的是给定入射方向下整个半球上的反射率，对于外层积分，得到的是所有入射方向得到的半球反射率的总和</p><h2 id="镜面反射和透射"><a href="#镜面反射和透射" class="headerlink" title="镜面反射和透射"></a>镜面反射和透射</h2><p>出射方向和入射方向两者相对发现的夹角相同<br>$$<br>\theta_i &#x3D; \theta_o<br>$$<br>其中$\phi_o &#x3D; \phi_i + \pi$，对于透射而言，也有相同的$\phi$方程，输出方向$\theta_t$由<strong>斯涅尔(Snell)定律</strong>给出，折射率描述了光在特定介质中的传播速度比在真空中慢多少，Snell定律如下：</p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220804111432881.png" alt="image-20220804111432881"></p><p>一般来说，折射率随着光的波长而变化，入射光通常在两种不同介质之间的边界处向多个方向散射，这种效应称为色散。在图形学中往往忽略这种波长相关性</p><h3 id="菲涅耳反射-Fresnel-Reflection"><a href="#菲涅耳反射-Fresnel-Reflection" class="headerlink" title="菲涅耳反射(Fresnel Reflection)"></a>菲涅耳反射(Fresnel Reflection)</h3><p>Snell定律给出了透射方向的计算方法，此时还需要计算被反射或透射的入射光比例</p><p>给定折射率和入射光线与表面法线的夹角，菲涅耳方程指定了材质对入射照明的两种不同偏振态的相应反射比，pbrt中假设光是非偏振的，则反射比是平行和垂直偏振项的平方的平均值(注：这里的定义和维基百科中不同，后者定义为算数平均值)</p><p>维基百科的解释：<a href="https://zh.wikipedia.org/zh-cn/%E8%8F%B2%E6%B6%85%E8%80%B3%E6%96%B9%E7%A8%8B">https://zh.wikipedia.org/zh-cn/%E8%8F%B2%E6%B6%85%E8%80%B3%E6%96%B9%E7%A8%8B</a></p><p>注意区分折射率和透射比的区别</p><p>折射率表，给出真空中光速与介质中光速之比</p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220804113537221.png" alt="image-20220804113537221"></p><p>电介质的菲涅耳反射比公式为</p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220804114405629.png" alt="image-20220804114405629"></p><p>两者分别为平行偏振光的反射比和垂直偏振光的反射比。余弦项应该全部大于或等于0，因此计算$cos\theta_i$和$cos\theta_t$时，几何法线应该分别翻转到与$w_i$和$w_t$的同一侧</p><p>对于非偏振光，菲涅耳反射比为</p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220804114641941.png" alt="image-20220804114641941"></p><p>透射比为$1 - F_r$</p><p>对于复折射率$\bar\eta &#x3D; \eta + i k$而言，其中一些入射光可能被材质吸收并转化为热量。其中$k$是吸收系数</p><p>导体和电介质之间边界处的菲涅耳反射比由如下公式给出：</p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220804171832328.png" alt="image-20220804171832328"></p><p>其中</p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220804171844472.png" alt="image-20220804171844472"></p><h3 id="镜面反射"><a href="#镜面反射" class="headerlink" title="镜面反射"></a>镜面反射</h3><p>菲涅耳方程给出了反射光的分量，$F_r(w)$，我们需要一个BRDF使得</p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220804172352552.png" alt="image-20220804172352552"></p><p>其中$w_r &#x3D; R(w_0, n)$是$w_0$关于表面法线$n$反射的镜面反射向量</p><p>由于镜面反射时，一个入射方向只会对应一个出射方向，因此使用冲激函数来表达BRDF，代换相关因子得</p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220804172645620.png" alt="image-20220804172645620"></p><p>反射向量$w_r$的计算方法为</p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220804172808989.png" alt="image-20220804172808989"></p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220804172826644.png" alt="image-20220804172826644"></p><h3 id="镜面透射"><a href="#镜面透射" class="headerlink" title="镜面透射"></a>镜面透射</h3><p>使用$\tau$表示由菲涅耳方程给出的透射到出射方向的入射能量的分量，因此$\tau &#x3D; 1 - F_r(w_i)$，则透射的通量微分为</p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220804173105665.png" alt="image-20220804173105665"></p><p>根据定义有</p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220804173223448.png" alt="image-20220804173223448"></p><p>将立体角转化为球面角</p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220804173245732.png" alt="image-20220804173245732"></p><p>对斯涅尔定律关于$\theta$微分，则有</p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220804173331297.png" alt="image-20220804173331297"></p><p>综合上述2个方程有</p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220804173428246.png" alt="image-20220804173428246"></p><p>因为$\phi_i &#x3D; \phi_o + \pi $，因此$d\phi_i &#x3D; d\phi_o$，最终有出射辐射度关于入射辐射度、折射率、透射比的关系</p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220804173624864.png" alt="image-20220804173624864"></p><p>类似地，根据散射方程以及上式得到BTDF函数的表达式如下</p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220804173800035.png" alt="image-20220804173800035"></p><p>其中$T(w_o, n)$是镜面透射向量</p><p>透射方向$w_t$的计算方法为</p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220804174610067.png" alt="image-20220804174610067"></p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220804174546488.png" alt="image-20220804174546488"></p><p>其中，$w_i, w_o, n$都是单位向量，$n$朝向入射介质的一边</p><p>$cos\theta_t$的计算公式为</p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220804174729748.png" alt="image-20220804174729748"></p><h2 id="兰伯特反射-Lambertian-Reflection"><a href="#兰伯特反射-Lambertian-Reflection" class="headerlink" title="兰伯特反射(Lambertian Reflection)"></a>兰伯特反射(Lambertian Reflection)</h2><p>Lambertian模型模拟了一个完美的漫反射表面，该表面在所有方向上均等地散射入射照明，其反射分布函数为$f &#x3D; R&#x2F;\pi$，其中$R$为散射的入射光的分量</p><h2 id="微表面模型"><a href="#微表面模型" class="headerlink" title="微表面模型"></a>微表面模型</h2><p>许多基于几何光学的表面反射和透射建模都基于这样的方法，即粗糙表面可以建模为小的微表面的集合，由微表面组成的表面通常称为高度场，其在统计上描述平面方向的分布。在pbrt中，使用microsurface描述微表面，macrosurface来描述底层的平滑表面</p><p>两种不同的微表面横截面如下</p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220804190931264.png" alt="image-20220804190931264"></p><p>基于微表面的BRDF模型通过对来自大量微表面的光散射进行统计建模来工作，假设被照亮的微分区域$dA$与单个微表面的面积相比大很多，则此时有大量的微表面将被照亮，并且它们的聚合行为决定了观察到的散射</p><p>微表面模型的两个主要组成成分：</p><ul><li>微表面的分布</li><li>描述光如何从单个微表面散射的BRDF</li></ul><p>考虑微表面的局部照明效果，主要是三种情况：</p><ul><li>微表面被另一个面阻挡</li><li>位于相邻微表面的阴影中</li><li>相互反射，导致微表面反射的光比直接光照和低级微表面BRDF预测的更多，因为有来自其他方向的光，见图c</li></ul><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220804191901766.png" alt="image-20220804191901766"></p><h3 id="Oren-Nayar漫反射"><a href="#Oren-Nayar漫反射" class="headerlink" title="Oren-Nayar漫反射"></a>Oren-Nayar漫反射</h3><p>Oren和Nayer发现粗糙表面通常随着照明方向接近观察方向而显得更亮，他们提出的反射模型通过V型微表面描述粗糙表面，该微表面由球形高斯分布描述，具有单个参数$\sigma$，即微表面方向角的标准差</p><p>在V形假设下，可以通过仅考虑相邻的微表面来解释相互反射，因此，该模型推导出的BRDF对凹槽集合的聚合反射进行建模，结果考虑了微表面之间的阴影、遮蔽和相互反射，其近似公式为</p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220804192501193.png" alt="image-20220804192501193"></p><p>其中$\sigma$用弧度来表示，且有</p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220804192539367.png" alt="image-20220804192539367"></p><h3 id="微表面分布函数"><a href="#微表面分布函数" class="headerlink" title="微表面分布函数"></a>微表面分布函数</h3><p>微表面的一个重要特征使用分布函数$D(w_h)$表示，它给出了具有微表面法线$w_h$的微表面的微分面积</p><p>微表面分布函数必须归一化以确保他们在物理上是合理的，如果我们考虑沿法线方向$n$在微表面上的入射光线，那么每条光线必须恰好与微表面相交一次。给定微表面的微分面积$dA$，那么该区域上方的微表面的投影面积必须等于$dA$</p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220804193937391.png" alt="image-20220804193937391"></p><p>注：这里暂时理解为，微表面上不能出现倒下的三角形，这种情况下一条光线可能与多个微表面相交，投影面积也会有重叠</p><p>可以用公式表述为</p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220804203737294.png" alt="image-20220804203737294"></p><p>Beckmann和Spizzichino提出了一种广泛使用的基于微表面斜率高斯分布的微表面分布函数，它的传统定义是</p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220804194211106.png" alt="image-20220804194211106"></p><p>如果$\sigma$是微表面的均方根(RMS)斜率，则$\alpha &#x3D; \sqrt2 \sigma$</p><p>如果是各向异性分布，其中的法线分布会随$w_h$的方位角方向而变化，例如，给定垂直于$x$轴的微表面的$\alpha_x$和$y$轴的$\alpha_y$，则中间方向的$\alpha$值可以通过这些值构造一个椭圆，相应的各向异性微表面分布函数为</p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220804194636309.png" alt="image-20220804194636309"></p><p>另一个有用的微表面分布函数来自Trowbridge和Reitz，其各向异性表达式由下式给出</p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220804194850274.png" alt="image-20220804194850274"></p><p>两者的函数图像如下，其中，横坐标为$\theta$的值，它是微表面法线$w_h$和宏表面法线$(0, 0, 1)$之间的夹角</p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220804194926402.png" alt="image-20220804194926402"></p><p>从图中可以看出，TR模型具有更高的尾部，对于远离表面法线的方向，它更慢地下降到0，该特性与许多真实世界表面非常匹配</p><p>微表面模型可以这样理解，每个平面包含多个微平面，这些微平面的取向是各种各样的，但大致满足上述函数图像的分布，即和原始取向相似的微表面法线数目更多，不相似的更少。当表面完全光滑时，所有微表面取向一致，此时就是完美的镜面反射</p><h3 id="遮蔽和阴影"><a href="#遮蔽和阴影" class="headerlink" title="遮蔽和阴影"></a>遮蔽和阴影</h3><p>现在考虑微表面的局部照明效果，使用遮蔽-阴影函数$G_1(w, w_h)$进行建模，它给出了具有法线$w_h$的微表面从$w$方向可见的分量(或比例)。通常情况下，微表面可见的概率与其方向$w_h$无关，因此可以写成$G_1(w)$</p><p>从$w$方向看到的微表面面积为$dAcos\theta$，则$G_1$的归一化约束为</p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220804195536192.png" alt="image-20220804195536192"></p><p>换句话说，给定方向$w$的可见微表面的投影面积必须等于$(w \cdot n) &#x3D; cos\theta$乘以宏观表面的微分面积$dA$</p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220804195828344.png" alt="image-20220804195828344"></p><p>如果$A^+(w)$是从$w$方向看到的前向微表面的投影面积，而$A^-(w)$是来自方程[8.13]的后向微表面的投影面积，则$cos\theta &#x3D; A^+(w) - A^-(w)$，因此，我们可以将遮蔽阴影函数写为可见微表面面积与总前向微表面面积的比率：</p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220804200910224.png" alt="image-20220804200910224"></p><p>使用辅助函数$\Lambda (w)$表示每个可见微表面区域中，不可见遮蔽微表面面积：</p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220804201034421.png" alt="image-20220804201034421"></p><p>则遮蔽函数可以重新表述为</p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220804201057255.png" alt="image-20220804201057255"></p><p>在附近点高度不相关的假设下，各向同性BeckmannSpizzichino分布的$\Lambda(w)$为</p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220804201408163.png" alt="image-20220804201408163"></p><p>其中$a &#x3D; 1&#x2F;(\alpha tan\theta)$和$erf$是误差函数，$erf(x) &#x3D; 2&#x2F;\sqrt\pi \int_0^x e^{-{x^{‘}}^2} d x^{‘} $</p><p>在不相关高度假设下，Trowbridge-Reitz分布的$\Lambda(w)$为</p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220804201746637.png" alt="image-20220804201746637"></p><p>其$G_1(w)$函数图像如下</p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220804201838562.png" alt="image-20220804201838562"></p><p>可以发现，增加表面的粗糙度会导致函数更快地下降到0，此时可见微表面更少，在视角垂直于微表面时，几乎所有微表面都不可见</p><p>与微表面分布的几何特性相关的最后一个函数是$G(w_o, w_i)$，它给出了微分区域中从$w_o$和$w_i$方向都可以看到的微表面的比例。假设一个微表面从两个方向都可见的概率，等于它从每个方向独立可见的概率之积，则有</p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220804202341710.png" alt="image-20220804202341710"></p><p>实际中两者往往并不独立，这导致$G$被低估，另一个更准确的模型认为，微表面上的给定点越靠上，微表面的可见性就越高，该模型表述为</p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220804202547719.png" alt="image-20220804202547719"></p><h3 id="Torrance-Sparrow模型"><a href="#Torrance-Sparrow模型" class="headerlink" title="Torrance-Sparrow模型"></a>Torrance-Sparrow模型</h3><p>该微表面模型用于模拟金属表面，他们将表面建模为完美光滑的镜面微表面的集合，只有那些法线等于半角向量的微表面能导致完美镜面反射，即</p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220804203018432.png" alt="image-20220804203018432"></p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220804203104577.png" alt="image-20220804203104577"></p><p>推导如下，各个符号的含义如下图</p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220804205025123.png" alt="image-20220804205025123"></p><p>考虑入射微表面的微分通量</p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220804204832535.png" alt="image-20220804204832535"></p><p>方向为$w_h$的微表面的微分面积为</p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220804204933940.png" alt="image-20220804204933940"></p><p>该乘积的前两项描述了每单位面积中，具有正确取向的平面的微分面积</p><p>带入前一个式子有</p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220804205243308.png" alt="image-20220804205243308"></p><p>如果我们假设微表面根据菲涅耳定律单独反射光，则出射通量为</p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220804205313638.png" alt="image-20220804205313638"></p><p>再次使用辐射度的定义，反射出的辐射度为</p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220804205335991.png" alt="image-20220804205335991"></p><p>结合等式[8.16],[8.15]有</p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220804205418158.png" alt="image-20220804205418158"></p><p>镜面反射下，$dw_h, dw_o$有如下关系(在14章推导)</p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220804205522866.png" alt="image-20220804205522866"></p><p>带入前一个方程有</p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220804205549398.png" alt="image-20220804205549398"></p><p>最后，添加几何衰减项$G(w_0, w_i)$，得到Torrance-Sparrow BRDF:</p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220804205625055.png" alt="image-20220804205625055"></p><p>该模型的优点之一是其推导不依赖于所使用的特定微表面分布，也不依赖于具体的菲涅耳函数，因此可以用于导体和电介质</p><p>对于BTDF，从折射率为$\eta_i$的介质到折射率为$\eta_o$的介质，其$dw_h$和$dw_o$的关系如下</p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220805091117589.png" alt="image-20220805091117589"></p><p>此时的BTDF为</p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220805091157882.png" alt="image-20220805091157882"></p><p>其中$\eta &#x3D; \eta_i &#x2F; \eta_o$，对于镜面透射，半角向量为</p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220805091325928.png" alt="image-20220805091325928"></p><h2 id="菲涅耳入射效应"><a href="#菲涅耳入射效应" class="headerlink" title="菲涅耳入射效应"></a>菲涅耳入射效应</h2><p>假设某个材质的表面是分层的，菲涅耳反射会减少到达分层对象的底层光量，考虑一张抛光的木桌或者涂有光泽油漆的墙壁，如果从正面看过去，主要看到的是本身颜料的颜色，即漫反射的分量；如果从倾斜的角度看过去，则看到的底层颜色较少，此时它被菲涅耳效应引起的更多的光泽反射所覆盖</p><p>Ashikhmin和Shirley开发的BRDF模型模拟漫反射底层表面，其上方有光滑的镜面反射表面，漫反射表面的反射效果通过考虑菲涅耳效应后剩余的能量进行分配和调节。当入射光接近法线时，大部分光线透射到漫反射层，此时漫反射项占据主导地位。当入射光接近掠射时，光泽反射成为主要的反射模式</p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220805092310351.png" alt="image-20220805092310351"></p><p>该模型基于光泽镜面反射项和漫反射项的加权和，光泽镜面项导出为</p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220805092553725.png" alt="image-20220805092553725"></p><p>其中$D(w_h)$是微表面分布项，$F(w_o)$代表菲涅耳反射比</p><p>Schlick将菲涅耳反射近似为</p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220805092710194.png" alt="image-20220805092710194"></p><p>其中$R$是表面在法向入射时的反射率，可以看到，入射角度越大，即视角越倾斜，反射率的值越大，反射所占的分量越多</p><p>最后，以下等式中的漫反射项以物理上合理的方式模拟了基于菲涅耳入射效应：</p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220805094239333.png" alt="image-20220805094239333"></p><p>其中，$R_s$是镜面反射的反射率，$R_d$是漫反射的反射率</p><h2 id="傅里叶基BSDF"><a href="#傅里叶基BSDF" class="headerlink" title="傅里叶基BSDF"></a>傅里叶基BSDF</h2><p>该模型使用傅里叶基表示具有缩放余弦项和的BSDF，对于某些具有逆反射性的材质来说处理较好</p><p>其BSDF公式如下：</p><p><img src="/2022/07/16/PBRT-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/image-20220805095117759.png" alt="image-20220805095117759"></p><p>其中，$\mu$是天顶角，$\phi$是方位角，$a_k(\mu_i, \mu_o)$表示一对特定天顶角余弦的傅里叶级数，这主要通过查表来得到</p><p>推导以及计算$a_k$的方法见原书8.6节</p>]]></content>
    
    
    <categories>
      
      <category>CG</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CG</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PBRT-采样和重建</title>
    <link href="/2022/07/15/PBRT-%E9%87%87%E6%A0%B7%E5%92%8C%E9%87%8D%E5%BB%BA/"/>
    <url>/2022/07/15/PBRT-%E9%87%87%E6%A0%B7%E5%92%8C%E9%87%8D%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="PBRT-采样和重建"><a href="#PBRT-采样和重建" class="headerlink" title="PBRT-采样和重建"></a>PBRT-采样和重建</h1><h2 id="理想采样和重建"><a href="#理想采样和重建" class="headerlink" title="理想采样和重建"></a>理想采样和重建</h2><p>采样和重建的过程可以概括为：</p><p>连续时间信号$x(t)$ -&gt; 高采样率采样 -&gt; 离散时间信号$x[n]$ -&gt; 重建滤波，去除高频 -&gt; 连续时间信号$\tilde{x}(t)$ -&gt; 低采样率像素采样 -&gt; 最终离散时间像素值$\tilde{x}[n]$ </p><p>使用脉冲列函数对原始图像采样：</p><p><img src="/2022/07/15/PBRT-%E9%87%87%E6%A0%B7%E5%92%8C%E9%87%8D%E5%BB%BA/image-20220712100636304.png" alt="image-20220712100636304"></p><p><img src="/2022/07/15/PBRT-%E9%87%87%E6%A0%B7%E5%92%8C%E9%87%8D%E5%BB%BA/image-20220712100653700.png" alt="image-20220712100653700"></p><p>这些采样值可以用于通过选择重建过滤器函数$r(x)$并计算卷积来定义重建函数$\tilde{f}$</p><p><img src="/2022/07/15/PBRT-%E9%87%87%E6%A0%B7%E5%92%8C%E9%87%8D%E5%BB%BA/image-20220712100812303.png" alt="image-20220712100812303"></p><p><img src="/2022/07/15/PBRT-%E9%87%87%E6%A0%B7%E5%92%8C%E9%87%8D%E5%BB%BA/image-20220712100825911.png" alt="image-20220712100825911"></p><p>选择理想滤波器box函数的定义为：</p><p><img src="/2022/07/15/PBRT-%E9%87%87%E6%A0%B7%E5%92%8C%E9%87%8D%E5%BB%BA/image-20220712101136331.png" alt="image-20220712101136331"></p><p>在频域下，理想采样和重建可以用如下公式表述：</p><p><img src="/2022/07/15/PBRT-%E9%87%87%E6%A0%B7%E5%92%8C%E9%87%8D%E5%BB%BA/image-20220712101216862.png" alt="image-20220712101216862"></p><p><img src="/2022/07/15/PBRT-%E9%87%87%E6%A0%B7%E5%92%8C%E9%87%8D%E5%BB%BA/image-20220712101301504.png" alt="image-20220712101301504"></p><h2 id="抗锯齿"><a href="#抗锯齿" class="headerlink" title="抗锯齿"></a>抗锯齿</h2><p>原始信号中的高频细节泄露到频谱的较低频率区域重建信号，这些新的低频伪像被称为<strong>锯齿(aliasing)</strong></p><p><img src="/2022/07/15/PBRT-%E9%87%87%E6%A0%B7%E5%92%8C%E9%87%8D%E5%BB%BA/image-20220712090553607.png" alt="image-20220712090553607"></p><p>如上图，当采样率太低时，函数频谱的的副本重叠，导致在执行重建时产生锯齿</p><h2 id="抗锯齿技术"><a href="#抗锯齿技术" class="headerlink" title="抗锯齿技术"></a>抗锯齿技术</h2><p>预锯齿：采样形成的伪像</p><p>后锯齿：重建形成的伪像</p><h3 id="非均匀采样"><a href="#非均匀采样" class="headerlink" title="非均匀采样"></a>非均匀采样</h3><p>可以通过以非均匀方式改变采样之间的间距来减少锯齿的视觉影响，令$\xi$ 表示0到1之间的随机数，则基于脉冲串的非均匀采样集为</p><p><img src="/2022/07/15/PBRT-%E9%87%87%E6%A0%B7%E5%92%8C%E9%87%8D%E5%BB%BA/image-20220712091028454.png" alt="image-20220712091028454"></p><p>非均匀采样往往会将规则的锯齿伪像变成噪声，这对人类视觉系统的干扰较小。在频域空间中，采样信号的副本也会随机移位，这样在执行重建时，结果是随机误差而不是相干锯齿</p><h3 id="自适应采样"><a href="#自适应采样" class="headerlink" title="自适应采样"></a>自适应采样</h3><p>如果可以识别频率高于Nyquist极限（信号中最大频率的两倍，即完美重建的最小采样频率）的信号区域，我们可以在这些区域采集额外的采样，而无需到处增加采样频率的计算费用。然而，找到所有需要超采样的地方是困难的</p><h3 id="预过滤"><a href="#预过滤" class="headerlink" title="预过滤"></a>预过滤</h3><p>过滤（即模糊）原始函数，这样就不会保留在所使用的采样率下无法准确捕获的高频。过滤后的重建不再受到大量高频信号的干扰，因此在低频区域的重建效果要比直接重建要好。这也说明，只有先模糊后采样能够达到抗锯齿的效果</p><h2 id="在图像合成中的应用"><a href="#在图像合成中的应用" class="headerlink" title="在图像合成中的应用"></a>在图像合成中的应用</h2><p>可以将图像视为$2D(x, y)$位置到辐射值$L$的函数：</p><p><img src="/2022/07/15/PBRT-%E9%87%87%E6%A0%B7%E5%92%8C%E9%87%8D%E5%BB%BA/image-20220712092122464.png" alt="image-20220712092122464"></p><p>由于在采样之前，通常不可能对$f$进行预过滤以从中去除高频，因此可以采取另外两种策略：</p><p>在最终图像中将采样率提高到超出基本像素间距</p><p>使用非均匀分布采样以将锯齿转化为噪声</p><p>对于特定图像的位置，该点的辐射通常会随着时间（如果场景中有移动物体）和镜头上的位置（如果相机具有有限光圈镜头）而变化，因此，场景函数还取决于时间$t$和$(u, v)$镜头位置</p><p>若使用统计技术来估计沿给定光线的辐射度，当重复给定同一光线时，它们可能返回不同的辐射值，如果进一步扩展场景辐射函数以包括积分采样器使用的采样值，可以将其表示为更高维的图像函数：</p><p><img src="/2022/07/15/PBRT-%E9%87%87%E6%A0%B7%E5%92%8C%E9%87%8D%E5%BB%BA/image-20220712093512656.png" alt="image-20220712093512656"></p><p>采样在每个维度上的分布和在不同维度上的分布都会影响到图像的质量。例如，如果能够确保图像$(x, y)$位置往往在镜头上具有不同的$(u, v)$位置，则生成的渲染图像将具有较小误差，因为每个采样更有可能考虑其相邻采样没有的场景信息</p><h2 id="渲染中的锯齿来源"><a href="#渲染中的锯齿来源" class="headerlink" title="渲染中的锯齿来源"></a>渲染中的锯齿来源</h2><p>几何图形是渲染采样中出现锯齿最常见的原因之一。当几何物体投影到图像平面上时，对象的边界会形成阶跃函数，该函数具有无限的频率内容，使用完美的重建过滤器进行锯齿采样时会导致ringing伪像，这种效应称为Gibbs现象</p><p><img src="/2022/07/15/PBRT-%E9%87%87%E6%A0%B7%E5%92%8C%E9%87%8D%E5%BB%BA/image-20220712095302167.png" alt="image-20220712095302167"></p><p>如上图，当阶跃函数使用sinc过滤器重建锯齿采样时，重建的函数将具有”ringing”伪像，它在真实函数周围震荡</p><p>场景中非常小的对象也会导致几何锯齿。当几何体足够小时，它可能落在图像平面上的采样点之间而消失在图像上，或者在动画的多个帧中重新出现</p><p>另一个锯齿来源可能来自对象的纹理和材质。未正确过滤的纹理贴图或闪亮表面上的小高光可能会导致着色锯齿，当采样率不足以对这些特征进行充分采样，就会导致锯齿。</p><h2 id="像素"><a href="#像素" class="headerlink" title="像素"></a>像素</h2><p>构成图像的像素是图像平面上离散点处图像函数的点采样</p><p>将连续坐标$c$截断为离散坐标$d$：<br>$$<br>d &#x3D; \lfloor c \rfloor<br>$$<br>将离散坐标转换为连续坐标：<br>$$<br>c &#x3D; d + 1&#x2F;2<br>$$<br>则离散范围$[x_0, x_1]$的连续坐标范围是$[x_0, x_1 + 1)$</p><p><img src="/2022/07/15/PBRT-%E9%87%87%E6%A0%B7%E5%92%8C%E9%87%8D%E5%BB%BA/image-20220712101805788.png" alt="image-20220712101805788"></p><h2 id="评估采样模式：采样差异-Discrepancy"><a href="#评估采样模式：采样差异-Discrepancy" class="headerlink" title="评估采样模式：采样差异(Discrepancy)"></a>评估采样模式：采样差异(Discrepancy)</h2><p>差异(discrepancy)可用于计算n维采样位置模式(pattern)的质量，分布良好的模式具有低差异值，因此采样模式生成问题可以被认为是寻找合适的低差异点模式之一。</p><p>差异的基本思想是，n维空间域$[0, 1)^n$中的一组点的质量可以通过该域的信息来计算：对每个区域内部的点进行计数，并将每个区域的容量与其内部的采样点数目进行比较。给定的容量比例应该和其中的采样点数的比例大致相同</p><p><img src="/2022/07/15/PBRT-%E9%87%87%E6%A0%B7%E5%92%8C%E9%87%8D%E5%BB%BA/image-20220712103239528.png" alt="image-20220712103239528"></p><p>上图表示给定采样点的着色盒子的差异。其中，落在盒子区域的采样点比例为$1&#x2F;4$，盒子的容量为$0.3 \times 0.3 &#x3D; 0.09$，因此该特殊盒子的差异为$0.16$。通常，我们感兴趣的是找到所有可能的盒子(或其他形状)的最大差异来衡量采样的质量。</p><p>一个感性的理解是，如果采样点较少，大容量盒子包含的采样点少，差异大；采样点分布不均匀，则在采样稀疏的地方，大盒子包含少量采样点，在采样密集的地方，小盒子包含大量采样点，都会导致差异增大</p><p>为了计算一组点的差异，可以选择一组形状$B$，它们是$[0, 1)^n$的子集，如选择形状为盒子，且限定其一个角落在原点，则有</p><p><img src="/2022/07/15/PBRT-%E9%87%87%E6%A0%B7%E5%92%8C%E9%87%8D%E5%BB%BA/image-20220712104446339.png" alt="image-20220712104446339"></p><p>其中$0 \leq v_i &lt; 1$，给定采样点序列$P &#x3D; x_1, …, x_N$，则$P$相对于$B$的差异是</p><p><img src="/2022/07/15/PBRT-%E9%87%87%E6%A0%B7%E5%92%8C%E9%87%8D%E5%BB%BA/image-20220712104557273.png" alt="image-20220712104557273"></p><p>其中，$#{x_i \in b}$表示在形状$b$中的采样点的个数，$V(b)$表示$b$的容量</p><p>当形状集合$B$是角落在原点的盒子时，该值被称为带星差异$D^*_N(P)$</p><p>考虑一维点集</p><p><img src="/2022/07/15/PBRT-%E9%87%87%E6%A0%B7%E5%92%8C%E9%87%8D%E5%BB%BA/image-20220712105448101.png" alt="image-20220712105448101"></p><p>此时$x_i$的星差为</p><p><img src="/2022/07/15/PBRT-%E9%87%87%E6%A0%B7%E5%92%8C%E9%87%8D%E5%BB%BA/image-20220712105516577.png" alt="image-20220712105516577"></p><p>例如，当$b$为$[0, 3&#x2F;2N)$时，仅包含采样点$x_1$，则$D &#x3D; 3&#x2F;2N - 1&#x2F;N &#x3D; 1&#x2F;2N$</p><p>一维中一系列点的星形差异的边界已经被证明为</p><p><img src="/2022/07/15/PBRT-%E9%87%87%E6%A0%B7%E5%92%8C%E9%87%8D%E5%BB%BA/image-20220712105720214-7594641.png" alt="image-20220712105720214"></p><p>根据低差异度量，1D中的这种均匀序列是最佳的，这不利于不规则抖动模式产生噪声。幸运的是，更高维度的低差异模式远不如一维的均匀，换句话说，高维情况下具有伪随机变化的模式相对于均匀模式具有更低的差异性，这有利于我们使用随机采样。</p><p>最小距离模式：计算一组点中任意两个采样点之间的最小距离也可以被用来度量采样模式的质量。这有助于弥补差异度量的弊端：一些低差异点集表现出一些采样聚集，这些过近的采样点提供有用信息的可能性更小</p><p>泊松盘模式：该模式下，没有两个点比某个距离$d$更近。该模式对于$2D$图像采样非常有效，但是在更复杂的渲染情况下进行高维采样时不如更好的低差异模式有效</p><h2 id="图像采样"><a href="#图像采样" class="headerlink" title="图像采样"></a>图像采样</h2><h3 id="分层采样"><a href="#分层采样" class="headerlink" title="分层采样"></a>分层采样</h3><p>分层采样将像素区域细分为矩形区域，并在每个区域内生成单个采样，这些区域被称为层(strata)</p><p>分层背后的关键思想是，通过将采样区域细分为互不重叠的区域并从每个区域中抽取一个采样，我们不太可能完全错过图像的重要特征，大部分情况下，它们不会全部挤在像素的某个角落。从信号处理的角度看，我们隐式地定义了一个整体采样率，即层越小，拥有的层越多，采样率越高</p><p>分层采样器通过将层的中心点随机抖动到层宽度和高度的一半，将每个采样放置在层内的随机点，这种抖动导致的非均匀性有助于将锯齿转化为噪声</p><p>直接将分层应用于高维采样会导致维度灾难，例如在五个维度上各分四层采样，此时每一层的每一次采样都要生成一个采样点，则每个像素的采样总数为$4^5 &#x3D; 1024$。一种解决办法是，我们可能希望每个像素只取4个采样，但是仍然要在所有维度上对采样进行分层，即独立地生成4个二维分层图像采样、4个一维分层时间采样和4个二维分层镜头采样，然后我们随机地讲时间和镜头采样值与每个图像采样相关联，结果是每个像素都有采样，这些采样一起具有良好的采样空间覆盖。下图展示了独立采样和相互关联的一个例子：</p><p><img src="/2022/07/15/PBRT-%E9%87%87%E6%A0%B7%E5%92%8C%E9%87%8D%E5%BB%BA/image-20220712113739902.png" alt="image-20220712113739902"></p><p><strong>分层采样的局限性</strong></p><p>采样数组存在的问题：</p><p>数组中的采样本身最好在2D中分布良好，这里的分层将提高每个单独采样向量的计算结果的质量</p><p>最好确保一个图像采样的数组中的每个采样与图像附近采样的任何采样值不太相似。相反，我们希望这些点相对于它们的邻居分布得很好，这样在单个像素周围的区域上，整个采样空间都有很好的覆盖</p><p>若要求每个图像有任意数量的采样数，可以只生成$n \times 1$或$1 \times n$的分层模式，但这样不能保证另一个维度的良好模式</p><p><strong>拉丁超立方体采样(LHS)</strong></p><p>LHS可以生成任意数量维度的采样，并且具有相当好的分布</p><p>LHS将每个维度的轴均匀划分成$n$个区域，并在每个$n$区域沿着对角线生成抖动采样，然后这些采样在每个维度上随机打乱，创建一个分布良好的模式</p><p><img src="/2022/07/15/PBRT-%E9%87%87%E6%A0%B7%E5%92%8C%E9%87%8D%E5%BB%BA/image-20220712160321093.png" alt="image-20220712160321093"></p><p>如上图，LHS选择的采样使得网格的每行和每列中仅存在一个样本。LHS可以通过沿着对角线在单元格中生成随机采样，然后随机排列它们的坐标来完成</p><p>并且，当样本投影到采样尺寸的任何轴上时，它可以最大限度地减少样本聚集。例如，分层采样时可能将点投影到某个轴的附近</p><p><img src="/2022/07/15/PBRT-%E9%87%87%E6%A0%B7%E5%92%8C%E9%87%8D%E5%BB%BA/image-20220712160752598.png" alt="image-20220712160752598"></p><p>LHS的弊端在于，它很容易导致采样点共线，且大面积采样域附近没有采样，例如，当原始采样的排列唯一时，它们将全部留在开始的地方。随着$n$的增加，LHS的效果会越来越差</p><h3 id="Halton采样"><a href="#Halton采样" class="headerlink" title="Halton采样"></a>Halton采样</h3><p>Halton算法基于直接生成低差异点集的算法，它不仅保证生成的点不会聚集在一起太近，而且生成同时在采样向量的所有维度上分布良好的点</p><h4 id="Hammersley和Halton序列"><a href="#Hammersley和Halton序列" class="headerlink" title="Hammersley和Halton序列"></a>Hammersley和Halton序列</h4><p>Halton和Hammersley序列是两个密切相关的低差异点集，两者都基于radical inverse构造</p><p><strong>radical inversion</strong></p><p>对于正整数a, 他可以表示为基数为b的数字序列：</p><p><img src="/2022/07/15/PBRT-%E9%87%87%E6%A0%B7%E5%92%8C%E9%87%8D%E5%BB%BA/image-20220805202438221.png" alt="image-20220805202438221"></p><p>其中$d_i(a)$的范围是$[0, b - 1]$</p><p>基数b的radical inverse函数$\Phi_b(a)$通过反映关于小数点的这些数字，将非负整数a转化为$[0, 1)$中的小数：</p><p><img src="/2022/07/15/PBRT-%E9%87%87%E6%A0%B7%E5%92%8C%E9%87%8D%E5%BB%BA/image-20220805202624002.png" alt="image-20220805202624002"></p><p>因此，数字$d_i(a)$对radical inverse的贡献是$d_i(a)&#x2F;b^i$</p><p><strong>van der Corput序列</strong></p><p>该序列是最简单的低差异序列之一，它是由基数为2的radical inverse函数给出的一维序列</p><p><img src="/2022/07/15/PBRT-%E9%87%87%E6%A0%B7%E5%92%8C%E9%87%8D%E5%BB%BA/image-20220805202809281.png" alt="image-20220805202809281"></p><p>序列的部分例子如下，注意Base和$\Phi$都是二进制的值</p><p><img src="/2022/07/15/PBRT-%E9%87%87%E6%A0%B7%E5%92%8C%E9%87%8D%E5%BB%BA/image-20220805203250598.png" alt="image-20220805203250598"></p><p>注意序列间的值尽量保证合理良好的最小距离</p><p>该序列的差异是</p><p><img src="/2022/07/15/PBRT-%E9%87%87%E6%A0%B7%E5%92%8C%E9%87%8D%E5%BB%BA/image-20220805203422430.png" alt="image-20220805203422430"></p><p>它与$n$维中的无限差异序列获得的最佳差异相匹配</p><p><img src="/2022/07/15/PBRT-%E9%87%87%E6%A0%B7%E5%92%8C%E9%87%8D%E5%BB%BA/image-20220805203500064.png" alt="image-20220805203500064"></p><p>为了在n维Halton序列中生成点，可以对于每个模式的维度都设置不同的基b，基必须彼此互质，否则两个序列间具有相关性，表现出来的就是n维采样时坐标间的相关性，比如生成对角线分布的采样点</p><p>选择使用前n个质数作为基，得到Halton序列</p><p><img src="/2022/07/15/PBRT-%E9%87%87%E6%A0%B7%E5%92%8C%E9%87%8D%E5%BB%BA/image-20220805204104575.png" alt="image-20220805204104575"></p><p>Halton序列最有用的特性之一是，即使事先不知道所需要的采样数也可以使用它，序列的所有前缀均分布良好，因此在向序列中添加额外采样时，将依然保持低差异</p><p>n维Halton序列的差异是</p><p><img src="/2022/07/15/PBRT-%E9%87%87%E6%A0%B7%E5%92%8C%E9%87%8D%E5%BB%BA/image-20220805204237122.png" alt="image-20220805204237122"></p><p>该结果渐进最优</p><p>如果采样数N固定，则可以使用Hammersley点集，从而使差异稍微降低，该点集定义为</p><p><img src="/2022/07/15/PBRT-%E9%87%87%E6%A0%B7%E5%92%8C%E9%87%8D%E5%BB%BA/image-20220805204327422.png" alt="image-20220805204327422"></p><p>其中N是采样总数，$b_i$都是素数，下图分别显示了Halton序列的前216个点和Hammersley序列的前256个点</p><p><img src="/2022/07/15/PBRT-%E9%87%87%E6%A0%B7%E5%92%8C%E9%87%8D%E5%BB%BA/image-20220805204500888.png" alt="image-20220805204500888"></p><p>Hammersley和Halton序列的缺点是，随着基数b的增加，采样值和b也会越接近，此时采样值会出现明显的规律，该问题可以使用加扰动的Halton和Hammersley序列来解决，其中在计算radical inverse时对数字应用置换：</p><p><img src="/2022/07/15/PBRT-%E9%87%87%E6%A0%B7%E5%92%8C%E9%87%8D%E5%BB%BA/image-20220805205156854.png" alt="image-20220805205156854"></p><p>其中p是$(0, 1, …, b - 1)$的一个排列数，注意，对于每个数字a都使用相同的排列作用于给定基数b的所有采样点</p><p>Halton序列的对比结果如下，选取的是$(\Phi_{29}(a), \Phi_{31}(a))$</p><p><img src="/2022/07/15/PBRT-%E9%87%87%E6%A0%B7%E5%92%8C%E9%87%8D%E5%BB%BA/image-20220805205428633.png" alt="image-20220805205428633"></p><p>该部分还可参考文章：</p><p><a href="https://zhuanlan.zhihu.com/p/20197323">https://zhuanlan.zhihu.com/p/20197323</a></p><h3 id="0-2-序列采样"><a href="#0-2-序列采样" class="headerlink" title="(0, 2)序列采样"></a>(0, 2)序列采样</h3><p>该方法利用了某些低差异序列的显著特性，它使得我们能够满足采样的两个理想特性：为像素值的图像样本生成样本向量，使得每个像素采样的采样值相对彼此良好分布，同时使得像素中所有像素采样的采样值的集合整体良好分布</p><h3 id="最大化最小距离采样"><a href="#最大化最小距离采样" class="headerlink" title="最大化最小距离采样"></a>最大化最小距离采样</h3><p>该方法使用一对不同的生成器矩阵，它们不仅生成(0, 2)序列，而且还专门设计用于最大化采样之间的距离</p><h3 id="Sobol采样"><a href="#Sobol采样" class="headerlink" title="Sobol采样"></a>Sobol采样</h3><p>Sobol采样器基于$Sobol^{‘}$ 的一系列生成器矩阵，这些矩阵生成的序列对应的样本在生成效率和实现上都非常出色，它完全基于基数2计算，同时在采样向量的所有$n$个维度上分布良好</p><p>该算法的弊端是，它们在收敛之前容易出现结构网格伪像</p><h2 id="图像重建"><a href="#图像重建" class="headerlink" title="图像重建"></a>图像重建</h2><p>给定精心选择的图像采样，我们需要将采样及其计算出的辐射值转换为像素值以供显示或存储。通过以下步骤计算输出图像中每个像素的最终值：</p><ol><li>从图像采样集合重建一个连续的图像函数$\tilde{L}$</li><li>对函数$\tilde{L}$进行预过滤，以去除像素间距超过Nyquist极限的任何频率</li><li>在像素位置采样$\tilde{L}$以计算最终像素值</li></ol><p>其中，前两个步骤可以通过单个过滤器函数组合起来，没有必要显式表达连续图像函数</p><p>为了重建像素值，考虑在特定像素附近插入采样的问题，为了计算像素$I(x, y)$的最终值，插值会导致计算加权平均值</p><p><img src="/2022/07/15/PBRT-%E9%87%87%E6%A0%B7%E5%92%8C%E9%87%8D%E5%BB%BA/image-20220712164554084.png" alt="image-20220712164554084"></p><p>其中：</p><p>$L(x_i, y_i)$是位于$(x_i, y_i)$的第$i$个采样的辐射值</p><p>$w(x_i, y_i)$是$Camera$返回的采样贡献权重，计算这些权重的方式决定了胶片测量的辐射量</p><p>$f$是过滤函数，和像素点到采样点的距离有关</p><h3 id="Box过滤器"><a href="#Box过滤器" class="headerlink" title="Box过滤器"></a>Box过滤器</h3><p>box过滤器对图像正方形区域内的所有采样进行同等加权，效率高，效果差，可能导致后锯齿(重建过程中产生的伪像)</p><p><img src="/2022/07/15/PBRT-%E9%87%87%E6%A0%B7%E5%92%8C%E9%87%8D%E5%BB%BA/image-20220712165437263.png" alt="image-20220712165437263"></p><h3 id="三角过滤器"><a href="#三角过滤器" class="headerlink" title="三角过滤器"></a>三角过滤器</h3><p>权重在过滤器的方形范围内从过滤器中心线性下降</p><p><img src="/2022/07/15/PBRT-%E9%87%87%E6%A0%B7%E5%92%8C%E9%87%8D%E5%BB%BA/image-20220712165534267.png" alt="image-20220712165534267"></p><h3 id="Gaussian过滤器"><a href="#Gaussian过滤器" class="headerlink" title="Gaussian过滤器"></a>Gaussian过滤器</h3><p>此过滤器应用以像素为中心并且围绕其镜像对称的高斯凹凸，从过滤器中减去其范围末尾的高斯值，以使其在极限处变为0。高斯过滤器会导致轻微模糊，但这可以帮助掩盖图像中任何剩余的锯齿</p><p>半径为$r$的一维高斯滤波函数为</p><p><img src="/2022/07/15/PBRT-%E9%87%87%E6%A0%B7%E5%92%8C%E9%87%8D%E5%BB%BA/image-20220712223514396.png" alt="image-20220712223514396"></p><p>其中，$\alpha$控制过滤器的衰减率，值越小，衰减越慢，图像越模糊。第二项保证高斯函数在其范围结束时为0，而不是突然出现下降</p><h3 id="Mitchell过滤器"><a href="#Mitchell过滤器" class="headerlink" title="Mitchell过滤器"></a>Mitchell过滤器</h3><p>该过滤器倾向于在ringing(图像中实际边缘旁边的幻觉边缘)和模糊(主要是过度模糊)之间进行权衡，这两者也是来自效果较差的重建过滤器产生的两种常见伪像</p><p>在实践中，Mitchell过滤器的负瓣提高了边缘的清晰度，然而，如果它们变得太大，ringing往往开始进入图像，此外，由于最终像素值可能因此变为负值，因此最终需要将其限制在合法的输出范围内</p><p><img src="/2022/07/15/PBRT-%E9%87%87%E6%A0%B7%E5%92%8C%E9%87%8D%E5%BB%BA/image-20220712165955287.png" alt="image-20220712165955287"></p><p>如上图，左边为高斯过滤器，右边为Mitchell过滤器，高斯过滤器给出的图像往往有些模糊，而Mitchell过滤器的负瓣有助于突出和锐化最终图像的边缘</p><h3 id="Windowed-Sinc过滤器"><a href="#Windowed-Sinc过滤器" class="headerlink" title="Windowed Sinc过滤器"></a>Windowed Sinc过滤器</h3><p>该过滤器的其中一部分是sinc函数的变体，它会在一段距离后变为0，附加参数$\tau$控制sinc函数在被截取(clamp)到0之前经过的周期数；另一部分是Lanczos窗口函数，Lanczos窗口只是sinc函数的中心瓣，通过缩放来覆盖$\tau$ 周期：</p><p><img src="/2022/07/15/PBRT-%E9%87%87%E6%A0%B7%E5%92%8C%E9%87%8D%E5%BB%BA/image-20220712225759090.png" alt="image-20220712225759090"></p><p><img src="/2022/07/15/PBRT-%E9%87%87%E6%A0%B7%E5%92%8C%E9%87%8D%E5%BB%BA/image-20220712225850701.png" alt="image-20220712225850701"></p><p>左图为截断的sinc函数和Lanczos窗口函数，右图为两个函数的乘积</p>]]></content>
    
    
    <categories>
      
      <category>CG</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CG</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PBRT-采样前置知识</title>
    <link href="/2022/07/14/PBRT-%E9%87%87%E6%A0%B7%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/"/>
    <url>/2022/07/14/PBRT-%E9%87%87%E6%A0%B7%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="PBRT-采样前置知识"><a href="#PBRT-采样前置知识" class="headerlink" title="PBRT-采样前置知识"></a>PBRT-采样前置知识</h1><p>[TOC]</p><h2 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h2><h3 id="直角坐标表示"><a href="#直角坐标表示" class="headerlink" title="直角坐标表示"></a>直角坐标表示</h3><p>复数的基本单位是$i &#x3D; \sqrt{-1} $，复数空间的每个数可以表示为$a + bi$的形式，其中，a是实部，b是虚部</p><p>复数可以在复平面上表示，复平面的横纵坐标分别为实部和虚部，例如：</p><p><img src="/2022/07/14/PBRT-%E9%87%87%E6%A0%B7%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/image-20220710144921937.png" alt="image-20220710144921937"></p><h3 id="极坐标表示"><a href="#极坐标表示" class="headerlink" title="极坐标表示"></a>极坐标表示</h3><p>复数使用极坐标可以表示为$(r, \theta)$，其中$r &#x3D; \sqrt{a^2 + b^2}$，也称为强度，$\theta &#x3D; arctan(\frac{b}{a})$，也称为相位</p><p>例如，复数$4 + 3i$的直角坐标为$(4, 3)$，极坐标为$(5, arctan(\frac{3}{4}))$</p><p><img src="/2022/07/14/PBRT-%E9%87%87%E6%A0%B7%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/image-20220710145314702.png" alt="image-20220710145314702"></p><p>极坐标转直角坐标：</p><p>令复数的极坐标为$(r, \theta)$，则直角坐标为$(rcos\theta, rsin\theta)$</p><h3 id="复数波和实数波"><a href="#复数波和实数波" class="headerlink" title="复数波和实数波"></a>复数波和实数波</h3><p>实数波表示为$cos\theta$和$sin\theta$的形式，复数波使用$e^{i\theta}$表示，且有：<br>$$<br>e^{i\theta} &#x3D; cos\theta + i\ sin\theta<br>$$<br>当$\theta &#x3D; \pi$时，有欧拉公式：<br>$$<br>e^{i\pi} &#x3D; -1<br>$$<br>两者的示意图如下：</p><p><img src="/2022/07/14/PBRT-%E9%87%87%E6%A0%B7%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/image-20220710150202363.png" alt="image-20220710150202363"></p><p>可以通过组合复数波得到实数波：<br>$$<br>cos\theta &#x3D; \frac{e^{i\theta} + e^{-i\theta}}{2} \<br>sin\theta &#x3D; \frac{e^{i\theta} - e^{-i\theta}}{2i}<br>$$</p><h2 id="正弦信号"><a href="#正弦信号" class="headerlink" title="正弦信号"></a>正弦信号</h2><h3 id="连续时间"><a href="#连续时间" class="headerlink" title="连续时间"></a>连续时间</h3><p>$$<br>x(t) &#x3D; Acos(w_0t + \phi)<br>$$</p><p><img src="/2022/07/14/PBRT-%E9%87%87%E6%A0%B7%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/image-20220710175530363.png" alt="image-20220710175530363"></p><p><strong>性质</strong></p><p><strong>周期性</strong><br>$$<br>x(t) &#x3D; x(t + T_0), period &#x3D; smallest\ \ T_0<br>$$<br><strong>相变和时移等价</strong><br>$$<br>Acos[w_0(t + t_0)] &#x3D; Acos[w_0t + w_0 t_0] \<br>Acos[w_0(t + t_0) + \phi] &#x3D; Acos[w_0 t + w_0 t + \phi]<br>$$<br><strong>频率不具有周期性</strong></p><p>假设有2个信号：<br>$$<br>x_1(t) &#x3D; Acos(w_1 t + \phi) \<br>x_2(t) &#x3D; Acos(w_2 t + \phi)<br>$$<br>如果$w_1 \neq w_2$，则$x_1(t) \neq x_2(t)$</p><h3 id="离散时间"><a href="#离散时间" class="headerlink" title="离散时间"></a>离散时间</h3><p>$$<br>x[n] &#x3D; Acos(\Omega_0n + \phi)<br>$$</p><p><img src="/2022/07/14/PBRT-%E9%87%87%E6%A0%B7%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/image-20220710175835803.png" alt="image-20220710175835803"></p><p><strong>性质</strong></p><p><strong>特定条件下具有周期</strong></p><p>假设有：<br>$$<br>x[n] &#x3D; x[n + N]<br>$$<br>将式子展开：<br>$$<br>Acos[\Omega_0 (n + N) + \phi] &#x3D; Acos[\Omega_0 n + \Omega_0 N + \phi]<br>$$<br>如果具有周期性，需要满足：<br>$$<br>\Omega_0 N &#x3D; 2\pi m \<br>N &#x3D; \frac{2\pi m}{\Omega_0}<br>$$<br>其中$N, m$都是整数，此时周期为最小的$N$</p><p><strong>时移等于相变</strong><br>$$<br>Acos[\Omega_0(n + n_0)] &#x3D; Acos[\Omega_0 n + \Omega_0 n_0]<br>$$<br><strong>相变不一定等于时移</strong></p><p>对于式子：<br>$$<br>x[n] &#x3D; Acos[\Omega_0 n + \phi]<br>$$<br>当且仅当$\phi &#x3D; n_0\Omega_0$时，有：<br>$$<br>Acos[\Omega_0 n + \phi] &#x3D; Acos[\Omega_0(n + n_0)]<br>$$<br>否则，相变无法转换成时移</p><p><strong>频率具有周期性</strong></p><p>假设有两个信号：<br>$$<br>x_1[n] &#x3D; Acos[\Omega_1 n + \phi] \<br>x_2[n] &#x3D; Acos[\Omega_2 n + \phi]<br>$$<br>当且仅当$\Omega_1 &#x3D; \Omega_2 + 2\pi m$时，$x_1[n] &#x3D; x_2[n]$</p><h2 id="复指数信号"><a href="#复指数信号" class="headerlink" title="复指数信号"></a>复指数信号</h2><h3 id="连续时间-1"><a href="#连续时间-1" class="headerlink" title="连续时间"></a>连续时间</h3><p>$$<br>x(t)<br> &#x3D;  Ce^{at} \<br> &#x3D;  |C|e^{j\theta} e^{(r+jw_0)t} \<br> &#x3D;  |C|e^{rt} e^{j(w_0t + \theta)} \<br> &#x3D;  |C|e^{rt}cos(w_0 t + \theta) + j |C| e^{rt} sin(w_0 t + \theta)<br>$$</p><h3 id="离散时间-1"><a href="#离散时间-1" class="headerlink" title="离散时间"></a>离散时间</h3><p>$$<br>x[n]<br> &#x3D;  C \alpha^n \<br> &#x3D;  |C|e^{j\theta} (|\alpha| e^{j\Omega_0})^n \<br> &#x3D;  |C||\alpha |^n e^{j(\Omega_0 n + \theta)} \<br> &#x3D;  |C||\alpha |^n cos(\Omega_0 n + \theta) + j |C||\alpha |^n sin(\Omega_0 n + \theta)<br>$$</p><h2 id="单位阶跃和单位脉冲函数"><a href="#单位阶跃和单位脉冲函数" class="headerlink" title="单位阶跃和单位脉冲函数"></a>单位阶跃和单位脉冲函数</h2><h3 id="离散时间-2"><a href="#离散时间-2" class="headerlink" title="离散时间"></a>离散时间</h3><p>离散时间单位阶跃函数：<br>$$<br>u[n] &#x3D;<br>\left{<br>\begin{aligned}<br>1, &amp; n \geq 0\<br>0, &amp; n &lt; 0<br>\end{aligned}<br>\right.<br>$$<br><img src="/2022/07/14/PBRT-%E9%87%87%E6%A0%B7%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/image-20220710180108618.png" alt="image-20220710180108618"></p><p>离散时间单位脉冲函数：<br>$$<br>\delta[n] &#x3D;<br>\left{<br>\begin{aligned}<br>1, n &#x3D; 0 \<br>0, n \neq 0<br>\end{aligned}<br>\right.<br>$$<br><img src="/2022/07/14/PBRT-%E9%87%87%E6%A0%B7%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/image-20220710180052505.png" alt="image-20220710180052505"></p><p>关系：<br>$$<br>\delta [n] &#x3D; u[n] - u[n - 1]<br>$$</p><p>$$<br>u[n]<br> &#x3D;  \sum_{m &#x3D; -\infty}^{n} \delta [m] \<br> &#x3D;  \sum_{k &#x3D; 0}^{+\infty} \delta[n - k]<br>$$</p><h3 id="连续时间-2"><a href="#连续时间-2" class="headerlink" title="连续时间"></a>连续时间</h3><p>连续时间单位阶跃函数：<br>$$<br>u(t) &#x3D;<br>\left{<br>\begin{aligned}<br>1, &amp; t \geq 0\<br>0, &amp; t &lt; 0<br>\end{aligned}<br>\right.<br>$$<br><img src="/2022/07/14/PBRT-%E9%87%87%E6%A0%B7%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/image-20220710180156518.png" alt="image-20220710180156518"></p><p>连续时间单位脉冲函数：<br>$$<br>\delta(t) &#x3D;<br>\left{<br>\begin{aligned}<br>1, t &#x3D; 0 \<br>0, t \neq 0<br>\end{aligned}<br>\right.<br>$$<br><img src="/2022/07/14/PBRT-%E9%87%87%E6%A0%B7%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/image-20220710180220745.png" alt="image-20220710180220745"></p><p>关系：<br>$$<br>\delta (t) &#x3D; \frac{du(t)}{dt}<br>$$</p><p>$$<br>u(t) &#x3D; \int_{-\infty}^{t} \delta(\tau) d\tau<br>$$</p><h2 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h2><p>对于线性时不变系统，离散时间下的卷积公式：<br>$$<br>y[n] &#x3D; \sum_{k &#x3D; -\infty}^{+\infty} x[k]h[n - k]<br>$$<br>记为：<br>$$<br>y[n] &#x3D; x[n] * h[n]<br>$$<br>相当于把$h[n]$沿y轴翻转后向右平移n个单位，得到函数$h_1[n]$，再将$h_1[n]$与$x[n]$相乘并求线性组合，即可得到卷积结果$y[n]$</p><p>当$h[n]$为脉冲序列时，卷积相当于将$x[n]$复制到每一个脉冲的位置</p><p>连续时间下的卷积公式：<br>$$<br>y(t) &#x3D; \int_{-\infty}^{+\infty} x(\tau)h(t - \tau)d\tau<br>$$<br>记为：<br>$$<br>y(t) &#x3D; x(t) * h(t)<br>$$</p><p>卷积的性质：</p><p>交换律</p><p>分配律</p><p>结合律</p><h2 id="傅里叶级数"><a href="#傅里叶级数" class="headerlink" title="傅里叶级数"></a>傅里叶级数</h2><p>傅里叶级数可以理解为复指数的线性组合</p><h3 id="连续时间-3"><a href="#连续时间-3" class="headerlink" title="连续时间"></a>连续时间</h3><p>连续时间傅里叶级数：<br>$$<br>x(t) &#x3D; \sum_{-\infty}^{+\infty}a^k e^{jkw_0t}<br>$$</p><p>傅里叶级数系数：<br>$$<br>a_k &#x3D; \frac{1}{T} \int_{T} x(t) e^{-jkw_0t} dt<br>$$<br>该系数又称为频谱系数</p><p>需要注意，傅里叶级数的求和范围是负无穷大到正无穷大，而傅里叶级数系数的积分范围是一个周期</p><p>性质：</p><p><img src="/2022/07/14/PBRT-%E9%87%87%E6%A0%B7%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/image-20220710163937597.png" alt="image-20220710163937597"></p><h3 id="离散时间-3"><a href="#离散时间-3" class="headerlink" title="离散时间"></a>离散时间</h3><p>离散时间傅里叶级数：<br>$$<br>x[n] &#x3D; \sum_{k&#x3D;<N>}a_k e^{jkw_0n}<br>$$<br>傅里叶级数系数：<br>$$<br>a_k &#x3D; \frac{1}{N} \sum_{k&#x3D;<N>} x[n] e^{-jkw_0n}<br>$$<br>离散时间傅里叶级数只对1个周期内的复指数做线性组合，这是因为$(k + N)w_0 &#x3D; kw_0 + 2\pi$，即此时的复指数具有周期性</N></N></p><p>性质：</p><p><img src="/2022/07/14/PBRT-%E9%87%87%E6%A0%B7%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/image-20220710164537300.png" alt="image-20220710164537300"></p><h2 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h2><h3 id="连续时间-4"><a href="#连续时间-4" class="headerlink" title="连续时间"></a>连续时间</h3><p>连续时间非周期信号的傅里叶变换：<br>$$<br>x(t) &#x3D; \frac{1}{2\pi} \int_{-\infty}^{+\infty} X(jw)e^{jwt} dw<br>$$</p><p>$$<br>X(jw) &#x3D; \int_{-\infty}^{+\infty} x(t) e^{-jwt} dt<br>$$</p><p>可记为：<br>$$<br>x(t) \overset{\mathscr{F}}{\longleftrightarrow} X(jw)<br>$$</p><p>其中，$X(jw)$是$x(t)$的傅里叶变换，它告诉我们将$x(t)$表示为不同频率正弦信号的线性组合所需要的信息，即信号的<strong>频域</strong></p><p>这里的思想是，将信号的周期设为无穷大，则频率趋近于0，周期信号就近似地变为非周期信号。同时，组成信号的复指数成分之间的频率差异也趋近于0，$w &#x3D; kw_0$可视为连续</p><p>对于周期信号而言，其傅里叶级数系数为非周期傅里叶变换的一个样本，因为此时的频率$w_0$为一固定的值，对应的$w &#x3D; kw_0$是离散的点</p><p>同时，一个傅里叶级数系数为$a_k$的周期信号的傅里叶变换，可以看成是出现在谐波关系的频率上的一串冲激函数，发生于第$k$次谐波频率$w_0$的冲激函数的面积是第$k$个傅里叶级数系数$a_k$的$2\pi$倍，用公式表述为：<br>$$<br>X(jw) &#x3D; \sum_{-\infty}^{+\infty} 2\pi a_k \delta(w - kw_0)<br>$$</p><p>连续时间傅里叶变换的性质：</p><p><img src="/2022/07/14/PBRT-%E9%87%87%E6%A0%B7%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/image-20220710171809580.png" alt="image-20220710171809580"></p><p>利用微分和积分的性质，可以将线性常系数微分方程先进行傅里叶变换，求解后在进行逆变换，还原成方程的最终解</p><p>在时域下做卷积等价于在频域下做乘积，该性质常用于滤波，如低通滤波器、高通滤波器</p><p>在时域下做乘积等价于在频域下做卷积，相当于位移信号的频率，该性质常用于调制，如复指数调制、正弦调制，频分多路复用</p><p>连续时间基本傅里叶变换对：</p><p><img src="/2022/07/14/PBRT-%E9%87%87%E6%A0%B7%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/image-20220710173455221.png" alt="image-20220710173455221"></p><p><img src="/2022/07/14/PBRT-%E9%87%87%E6%A0%B7%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/image-20220710173514585.png" alt="image-20220710173514585"></p><h3 id="离散时间-4"><a href="#离散时间-4" class="headerlink" title="离散时间"></a>离散时间</h3><p>离散时间非周期信号的傅里叶变换：<br>$$<br>x[n] &#x3D; \frac{1}{2\pi} \int_{2\pi} X(e^{jw})e^{jwn}dw<br>$$</p><p>$$<br>X(e^{jw}) &#x3D; \sum_{m &#x3D; -\infty}^{+\infty} x[n] e^{-jwt}<br>$$</p><p>在离散时间下，傅里叶变换具有周期性</p><p>周期信号的傅里叶级数系数同样是非周期信号傅里叶变换的一个样本</p><p>离散时间傅里叶变换的性质：</p><p><img src="/2022/07/14/PBRT-%E9%87%87%E6%A0%B7%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/image-20220710174315904.png" alt="image-20220710174315904"></p><p>离散时间基本傅里叶变换对：</p><p><img src="/2022/07/14/PBRT-%E9%87%87%E6%A0%B7%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/image-20220710174408866.png" alt="image-20220710174408866"></p><p><img src="/2022/07/14/PBRT-%E9%87%87%E6%A0%B7%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/image-20220710174430090.png" alt="image-20220710174430090"></p><p><img src="/2022/07/14/PBRT-%E9%87%87%E6%A0%B7%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/image-20220710174508729.png" alt="image-20220710174508729"></p><h3 id="对偶关系"><a href="#对偶关系" class="headerlink" title="对偶关系"></a>对偶关系</h3><p><img src="/2022/07/14/PBRT-%E9%87%87%E6%A0%B7%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/image-20220710174605514.png" alt="image-20220710174605514"></p><h2 id="采样定理"><a href="#采样定理" class="headerlink" title="采样定理"></a>采样定理</h2><p>在一定条件下，一个连续时间信号完全可以用该信号在等时间间隔点上的值或样本来表示，并且可以用这些样本值把信号全部恢复出来</p><p>采样混叠（aliasing)</p><p>如果采样频率$w$小于信号最大频率$w_m$的两倍，则会发生频率混叠，导致高频的成分变成低频。因此，只有受限带宽才可能不发生混叠</p><p>采样和重建的一般步骤：</p><ol><li>使用脉冲串采样，在频域中得到周期性的频率变化</li><li>使用低通滤波器重建，在频域中截取频率</li></ol><p>采样率转换：</p><p>抽取(降采样)：降低采样周期，去掉中间的0值</p><p>内插(升采样)：提高采样周期，在中间添加0值</p><p>离散时间采样：</p><p>$x[n]$ -&gt; 采样 -&gt; $x_p[n]$ -&gt; 抽取 -&gt; $x_d[n]$ -&gt; 内插 -&gt; $x_p[n]$ -&gt; 滤波重建 -&gt; $x[n]$ </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>PBRT-辐射度量学</title>
    <link href="/2022/07/13/PBRT-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/"/>
    <url>/2022/07/13/PBRT-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="PBRT-辐射度量学"><a href="#PBRT-辐射度量学" class="headerlink" title="PBRT-辐射度量学"></a>PBRT-辐射度量学</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>辐射度量学是对辐射能量传递的现象学研究，假设几何光学(geometric optics)是描述光和光散射的合适模型，这引申出一些关于光行为的基本假设：</p><ul><li><p>线性：光学系统的两个输入的组合效果等于每个单独输入效果的总和</p></li><li><p>能量守恒：当光从表面或参与介质散射时，散射事件永远不会产生比开始时更多的能量</p></li><li><p>无极化：忽略电磁场的极化，因此，光的唯一相关属性是按照波长(或频率)的分布</p></li><li><p>无荧光或磷光：</p><p>  荧光是指物体吸收其他不可见波长的辐射时进入激发态，并且退激发并发出出射光，持续时间短，注意该定义与一般情况下定义的微弱的光亮有区别</p><p>  磷光是指轰击辐射停止后持续存在的荧光</p><p>  无荧光或磷光是指一个波长的光行为完全独立于其他波长或时间的光行为。与极化一样，包含这些影响并不困难，但是他们对系统的实用价值相对较小</p></li><li><p>稳态：假设环境中的光已经达到平衡，因此其辐射分布不会随着时间变化，现实场景中，这几乎是在光线下瞬间发生的，因此在实践中不受限制，磷光违反稳态假设</p></li><li><p>采用几何光学模型无法考虑衍射和干涉效应</p></li></ul><h2 id="基本量"><a href="#基本量" class="headerlink" title="基本量"></a>基本量</h2><p>渲染核心的四个辐射量：通量(flux)、辐照度(irradiance)或辐射出射度(radiant exitance)、强度(intensity)和辐射度(radiance)。它们都可以通过在时间、面积和方向上依次取极限来从能量中导出。所有这些辐射量一般都依赖于波长</p><h3 id="能量-Energy"><a href="#能量-Energy" class="headerlink" title="能量(Energy)"></a>能量(Energy)</h3><p>单位：焦耳($J$)</p><p>照明源发射光子，每个光子都处于特定波长，并且携带特定数量的能量。所有基本的辐射量都是测量光子的有效方法，波长为$\lambda$ 的光子携带能量为：</p><p><img src="/2022/07/13/PBRT-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220703121631858.png" alt="image-20220703121631858"></p><p>$c$是光速，$299,472,458m&#x2F;s$，$h$是普朗克常数，$h \approx 6.626 \times 10^{-34} m^2 kg &#x2F; s $</p><h3 id="通量-Flux"><a href="#通量-Flux" class="headerlink" title="通量(Flux)"></a>通量(Flux)</h3><p>单位：焦耳&#x2F;秒($J&#x2F;s$)或瓦特($W$)</p><p>辐射通量，也称为功率，是单位时间内通过表面区域或空间区域的总能量。辐射通量可以通过对每个微分时间的微分能量的极限求得：</p><p><img src="/2022/07/13/PBRT-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220703122116769.png" alt="image-20220703122116769"></p><p>相反，给定作为时间函数的通量，我们可以对一系列时间进行积分以计算总能量：</p><p><img src="/2022/07/13/PBRT-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220703122451893.png" alt="image-20220703122451893"></p><p>光源的总发射量(emission)通常用通量来表示，对于点光源来说，通过任何一个球面的通量是相同的</p><p>注意，考虑通量的时候不关心面积，即不需要知道光照面积的大小，只关心某个时间内能量的大小</p><h3 id="辐照度和辐射出射度-Irradiance-and-Radiant-Exitance"><a href="#辐照度和辐射出射度-Irradiance-and-Radiant-Exitance" class="headerlink" title="辐照度和辐射出射度(Irradiance and Radiant Exitance)"></a>辐照度和辐射出射度(Irradiance and Radiant Exitance)</h3><p>单位：瓦特&#x2F;平方米($W&#x2F;m^2$)</p><p>任何通量测量都需要一个区域，在该区域上测量单位时间的光子。给定一个有限区域$A$，我们可以通过$E &#x3D; \Phi &#x2F; A$定义该区域的平均功率密度。这个量要么是辐照度($E$)，即到达表面的通量的面积密度，要么是辐射出射度($M$)，即离开表面的通量的面积密度。有时辐照度也可以指离开表面的通量</p><p>可以通过在点$p$处取每个微分区域的微分功率极限，来定义辐照度和辐射出射度：</p><p><img src="/2022/07/13/PBRT-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220703133655140.png" alt="image-20220703133655140"></p><p>可以积分一个区域的辐照度来计算功率：</p><p><img src="/2022/07/13/PBRT-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220703133748372.png" alt="image-20220703133748372"></p><p>以点光源为例，外球体上一点的辐照度小于内球体上一点的辐照度，如果点光源在所有方向上照射相同数量的照明，那么对于此配置中具有半径$r$的球体：</p><p><img src="/2022/07/13/PBRT-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220703134022262.png" alt="image-20220703134022262"></p><p>这解释了一个点从光接收到的能量会随着光的平方距离而下降</p><p>当光线照射到物体表面时，如果光线与表面成一定角度，则接收到光的表面积更大，相应地每单位的光通量(即辐照度)会更小。如果$A$很小，则接收通量的区域$A_2$大约为$A&#x2F;cos\theta$，对于$A_2$内的点，其辐照度为：</p><p><img src="/2022/07/13/PBRT-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220703134438343.png" alt="image-20220703134438343"></p><p><img src="/2022/07/13/PBRT-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220703134516094.png" alt="image-20220703134516094"></p><h3 id="立体角和强度-Solid-Angle-and-Intensity"><a href="#立体角和强度-Solid-Angle-and-Intensity" class="headerlink" title="立体角和强度(Solid Angle and Intensity)"></a>立体角和强度(Solid Angle and Intensity)</h3><p>立体角单位：球面度(steradians, $sr$)</p><p>立体角是平面中的2D角度到球体角度的延伸。平面角指的是某个物体相对于某个位置所对的总角度，考虑点$p$周围的单位圆，如果将阴影对象投影到该圆上，圆$s$的某个长度将被其投影覆盖，$s$的弧长等于物体对向的弧度</p><p><img src="/2022/07/13/PBRT-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220703135150876.png" alt="image-20220703135150876"></p><p>从$p$点看到的物体的平面角等于它从$p$看到的对角，等效于单位球面上弧$s$的长度。即$1 radians$对应弧长$1 r$</p><p>立体角将2D单位圆扩展为3D单位球体，总面积$s$是物体所对的立体角。立体角以球面度$sr$测量，整个球面对着$4\pi sr$的立体角，半球对应$2\pi sr$，$1 steradians$对应弧面积$1r^2$</p><p><img src="/2022/07/13/PBRT-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220703135454437.png" alt="image-20220703135454437"></p><p>通过将$c$投影到单位球体上，并测量其投影面积来计算物体$c$在三个维度上所对的立体角$s$</p><p>强度单位：瓦特&#x2F;球面度($W&#x2F;sr$)</p><p>考虑发射光子的无穷小光源，如果我们将该光源置于单位球体的中心，我们就可以计算出发射功率的角密度，这就是强度(Intensity)，用字母$I$表示，在整个方向范围内，我们有：</p><p><img src="/2022/07/13/PBRT-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220703141013497.png" alt="image-20220703141013497"></p><p>一般来说，我们更关心取方向微分椎体(differential cone)的极限：</p><p><img src="/2022/07/13/PBRT-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220703141131215.png" alt="image-20220703141131215"></p><p>其中，$w$表示以$p$为中心的单位球面上的点指向$p$的归一化向量</p><p>可以通过积分一系列立体角的强度来得到通量：给定强度作为方向的函数$I(w)$，我们可以在有限的一组方向 $\Omega$ 上积分以得到通量</p><p><img src="/2022/07/13/PBRT-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220703141527384.png" alt="image-20220703141527384"></p><p>强度描述了光的方向分布，它只对光源有意义</p><h3 id="辐射度-Radiance"><a href="#辐射度-Radiance" class="headerlink" title="辐射度(Radiance)"></a>辐射度(Radiance)</h3><p>单位：瓦特&#x2F;球面度·平方米( $W&#x2F;m^2sr$ )</p><p>辐照度和辐射出射度为我们提供了点$p$处每个微分区域的微分功率，但他们不区分功率的方向分布。辐射度执行最后一步，并测量相对于立体角的辐照度或辐射出射度，它定义为</p><p><img src="/2022/07/13/PBRT-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220703142028432.png" alt="image-20220703142028432"></p><p>使用$E_w$表示垂直于$w$方向的表面的辐照度，换句话说，辐射度不是根据入射在$p$表面的辐照度来测量的。测量区域的这种变化有助于消除辐射定义中的$cos \theta$项</p><p>辐射度是每单位面积、每单位立体角的通量密度，他被定义为</p><p><img src="/2022/07/13/PBRT-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220703142445640.png" alt="image-20220703142445640"></p><p>其中$dA^{\perp}$是$dA$在垂直于$w$的假设表面上的投影面积，因此，当关注的入射方向锥$dw$变得非常小，表面上关注的局部区域$dA$也变得非常小</p><p><img src="/2022/07/13/PBRT-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220703142900072.png" alt="image-20220703142900072"></p><p>如果给定辐射度，所有其他值都可以根据面积和方向上辐射度积分计算。辐射度的另一个很好的特性是穿过真空的光线保持恒定，因此它是使用光线追踪的自然量</p><h2 id="入射和出射辐射函数-Incident-and-Exitant-Radiance-Functions"><a href="#入射和出射辐射函数-Incident-and-Exitant-Radiance-Functions" class="headerlink" title="入射和出射辐射函数(Incident and Exitant Radiance Functions)"></a>入射和出射辐射函数(Incident and Exitant Radiance Functions)</h2><p>当光线与场景中的表面相互作用时，辐射函数$L$通常跨表面边界不连续，在最极端的完全不透明表面(如镜子)下，略高于表面和略低于表面的辐射函数可能完全无关，此时的辐射度函数定义为方程(5.3)：</p><p><img src="/2022/07/13/PBRT-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220703144752653.png" alt="image-20220703144752653"></p><p>但是，我们更愿意使用到达该点的辐射(例如，由于光源的照明)和离开该点的辐射(例如，由于表面反射)来进行区分</p><p>使用$L_i(p, w)$表示入射辐射度，这里的$w$指向远离表面的方向，也有些书上方向相反。注意，$L_i(p, -w)$表示到达表面另一侧的辐射</p><p>使用$L_o(p, w)$表示出射辐射度，$w$指向远离表面的方向</p><p><img src="/2022/07/13/PBRT-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220703144837046.png" alt="image-20220703144837046"></p><p>这些更直观的入射和出射辐射函数与方程(5.3)的单边限制之间存在简单的关系：</p><p><img src="/2022/07/13/PBRT-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220703145902417.png" alt="image-20220703145902417"></p><p>注意，这里的$L^+(p, w)$表示从光源射向$p$点外表面的光线的辐射度，尽管$w$依然是远离表面的($w \cdot \boldsymbol{n_p} &gt; 0$)，所以需要取反来保持方向一致。$L^-(p, w)$同理</p><p>对于空间中不存在表面的那些点，$L$是连续的，因此$L^+ &#x3D; L^-$，即</p><p><img src="/2022/07/13/PBRT-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220703150027546.png" alt="image-20220703150027546"></p><p>此时，$L_i$和$L_0$仅在方向上反转</p><h2 id="亮度和光度学-Luminance-and-Photometry"><a href="#亮度和光度学-Luminance-and-Photometry" class="headerlink" title="亮度和光度学(Luminance and Photometry)"></a>亮度和光度学(Luminance and Photometry)</h2><p>单位：坎德拉&#x2F;平方米($cd&#x2F;m^2$)</p><p>所有辐射测量都有相应的光度测量。光度学(Photometry)是根据人类视觉系统感知可见电磁辐射的研究，可以通过对光谱响应曲线$V(\lambda)$进行积分，将光谱辐射量转化为光度量，其中，$V(\lambda)$ 描述人眼对各种波长的灵敏度，例如，特定能量的光谱功率分布(SPD, Spectral Power Distribution)在绿色波长下比在蓝色波长下更亮</p><p>使用$Y$表示亮度，计算公式为</p><p><img src="/2022/07/13/PBRT-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220703152353711.png" alt="image-20220703152353711"></p><p>选择CIE $Y(\lambda)$三色曲线和$V(\lambda)$成正比，使用颜色的$XYZ$表示(第5.2.1节)为</p><p><img src="/2022/07/13/PBRT-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220703152653085.png" alt="image-20220703152653085"></p><p>辐射度量和光度测量的单位对比：</p><p><img src="/2022/07/13/PBRT-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220703152737061.png" alt="image-20220703152737061"></p><h2 id="辐射积分-Radiometric-Integrals"><a href="#辐射积分-Radiometric-Integrals" class="headerlink" title="辐射积分(Radiometric Integrals)"></a>辐射积分(Radiometric Integrals)</h2><p>表面法线为$n$，点$p$处的辐照度是一组方向$\Omega$上的辐射度的积分</p><p><img src="/2022/07/13/PBRT-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220703153213813.png" alt="image-20220703153213813"></p><p>注意，这里的$cos\theta$项是由于辐射度定义里的$dA^{\perp }$产生的，$\theta$为$w$和$n$之间的夹角，显然有，$\theta$值越大，光线和表面越接近平行，此时单位面积上分得的通量更小，即光照度更小，如果写成$\frac{1}{|cos\theta|}$，则计算成了照射到的面积$A$上的通量</p><p>辐照度通常计算在半球$H^2(n)$上</p><p><img src="/2022/07/13/PBRT-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220703155345346.png" alt="image-20220703155345346"></p><p>点p处的辐照度，由辐照度的积分乘以该点上方整个上半球入射方向余弦给出</p><h3 id="投影立体角上的积分"><a href="#投影立体角上的积分" class="headerlink" title="投影立体角上的积分"></a>投影立体角上的积分</h3><p>投影立体角，是通过将物体投影到单位球面上得到单位球弧面，然后将所得形状向下投影到垂直于表面法线的单位圆盘上来得到</p><p><img src="/2022/07/13/PBRT-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220703155818477.png" alt="image-20220703155818477"></p><p>这样，对于余弦加权立体角方向上的半球积分被转化为投影立体角上的积分</p><p><img src="/2022/07/13/PBRT-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220703155923039.png" alt="image-20220703155923039"></p><p>半球上的积分变为</p><p><img src="/2022/07/13/PBRT-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220703160330231.png" alt="image-20220703160330231"></p><p>也可以通过在物体表面积$A$上的积分来计算从某个物体发射到发现周围半球的总通量</p><p><img src="/2022/07/13/PBRT-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220703160514874.png" alt="image-20220703160514874"></p><h3 id="球坐标上的积分"><a href="#球坐标上的积分" class="headerlink" title="球坐标上的积分"></a>球坐标上的积分</h3><p>方向向量和球面角之间的转化</p><p><img src="/2022/07/13/PBRT-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220703160815860.png" alt="image-20220703160815860"></p><p><img src="/2022/07/13/PBRT-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220703160830417.png" alt="image-20220703160830417"></p><p>微分面积$dw$和球面角之间的关系</p><p><img src="/2022/07/13/PBRT-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220703160919500.png" alt="image-20220703160919500"></p><p><img src="/2022/07/13/PBRT-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220703160942798.png" alt="image-20220703160942798"></p><p>解释：将微分面积看做长方形，其水平方向上的边长根据弧长公式$s &#x3D; \theta_0 r$给出，这里$\theta_0 &#x3D; d\phi, r &#x3D; 1 * sin\theta &#x3D; sin\theta$，垂直方向上的边长同样根据弧长公式计算，这里$\theta_0 &#x3D; d\theta, r &#x3D; 1 $ </p><p>方程(5.4)和$\Omega &#x3D; H^2(n)$可以等价写为</p><p><img src="/2022/07/13/PBRT-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220703161641814.png" alt="image-20220703161641814"></p><p>注意$\theta$的增长方向是$+Z$到$-Z$，如果所有方向的辐射度都相同，则方程简化为<br>$$<br>E &#x3D; \int_0^{2\pi} \int_0^{\pi&#x2F;2}L_i cos\theta sin\theta, d\theta d\phi &#x3D; L_i \int_0^{2\pi} \int_0^{\pi&#x2F;2} \frac{1}{4} sin2\theta, d2\theta d\phi &#x3D; \frac{L_i}{4} \int_0^{2\pi}-cos2\theta \vert_0^{\pi&#x2F;2}, d\phi \<br>&#x3D; \frac{L_i}{2} \int_0^{2\pi} , d\phi &#x3D; \pi L_i<br>$$<br>方向向量到球面角的转换可以通过下式</p><p><img src="/2022/07/13/PBRT-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220703163240560.png" alt="image-20220703163240560"></p><h3 id="面积积分"><a href="#面积积分" class="headerlink" title="面积积分"></a>面积积分</h3><p>将微分面积$dA$和微分立体角$dw$之间的关系表示为</p><p><img src="/2022/07/13/PBRT-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220703164240627.png" alt="image-20220703164240627"></p><p><img src="/2022/07/13/PBRT-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220703164254749.png" alt="image-20220703164254749"></p><p>解释：$r$是$p$到$dA$的距离，$\theta$是$dA$表面法线和到点$p$的向量之间的角度，$cos\theta$项将$dA$投影到其所在的球面上，令此时的面积$dA^{\perp} &#x3D; dA cos\theta $，则$dA^{\perp}$和$dw$所对的立体角相同，根据立体角公式$A_0 &#x3D; w_0 r^2$有<br>$$<br>\frac{dw}{1^2} &#x3D; \frac{dA^{\perp}}{r^2} \iff dw &#x3D; \frac{dA cos\theta}{r^2}<br>$$<br>此时可以将四边形光源的辐照度积分写为</p><p><img src="/2022/07/13/PBRT-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220703165218050.png" alt="image-20220703165218050"></p><p>$L$是四边形表面发射的辐射度，$\theta_i$是$p$处的表面法线与$p$到灯光上$p^{‘}$点的方向之间的角度，$\theta_0$是灯光上$p^{‘}$点的表面法线和从$p^{‘}$ 到$p$方向之间的角度</p><h2 id="表面反射"><a href="#表面反射" class="headerlink" title="表面反射"></a>表面反射</h2><p>当光线入射到表面时，表面会散射光，并将其中一部分反射回环境，为了模拟这种反射，需要描述两种效应：反射光的光谱分布及其方向分布。描述这些光反射机制主要有两个抽象：</p><ul><li>BRDF：双向反射分布函数，描述了忽略次表面光传输影响的点处的表面反射，材质对其传输机制没有显著影响，实现高效</li><li>BSSRDF：双向散射表面反射率分布函数，描述了半透明材质的光反射更泛化的配置</li></ul><h3 id="The-BRDF-Bidirectional-Reflectance-Distribution-Function"><a href="#The-BRDF-Bidirectional-Reflectance-Distribution-Function" class="headerlink" title="The BRDF(Bidirectional Reflectance Distribution Function)"></a>The BRDF(Bidirectional Reflectance Distribution Function)</h3><p>双向反射分布函数给出了描述表面反射的形式，我们想要知道沿着$w_i$方向的入射辐射度$L_i(p, w_i)$有多少辐射度$L_o(p, w_0)$离开表面，其模型如下图</p><p><img src="/2022/07/13/PBRT-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220703171943374.png" alt="image-20220703171943374"></p><p>该模型描述了沿$w_i$方向的入射光从表面沿$w_0$方向散射,如果$w_i$被认为是方向的微分锥体，则$p$处的微分辐照度为</p><p><img src="/2022/07/13/PBRT-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220703172341460.png" alt="image-20220703172341460"></p><p>根据几何光学的线性假设，反射的微分辐射度和辐照度成正比</p><p><img src="/2022/07/13/PBRT-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220703172504235.png" alt="image-20220703172504235"></p><p>比例常数定义特定方向$w_i$和$w_0$的表面BRDF</p><p><img src="/2022/07/13/PBRT-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220703172630681.png" alt="image-20220703172630681"></p><p>基于物理的BRDF有两个重要的约束</p><ul><li><p>交换性：对于所有的方向对$w_i, w_0$，有$f_r(p, w_i, w_0) &#x3D; f_r(p, w_0, w_i)$</p></li><li><p>能量守恒：反射光的总能量小于或等于入射光的能量。对于所有方向的$w_0$有</p><p>  <img src="/2022/07/13/PBRT-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220703173137690.png" alt="image-20220703173137690"></p></li></ul><p>表面的双向投射分布函数(BTDF, Bidirectional Transmittance Distribution Function)描述了透射光的分布，可以用类似于BRDF的方式来定义，BTDF表示为$f_t(p, w_0, w_i)$，其中$w_0$和$w_i$在$p$周围的相对半球位置。需要注意的是，BTDF不遵守交换性</p><p>为了方便起见，将BRDF和BTDF一起考虑为$f(p, w_0, w_i)$，根据定义有</p><p><img src="/2022/07/13/PBRT-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220703173508264.png" alt="image-20220703173508264"></p><p>这里出射辐射度的微分是相对于入射立体角的微分。$cos\theta_i$的绝对值主要是遵循一致性约定，如“假设表面法线指向表面之外”，我们可以在$p$点周围的入射方向球面上积分这个方程，以根据入射亮度计算$w_0$方向的出射辐射度</p><p><img src="/2022/07/13/PBRT-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220703173819880.png" alt="image-20220703173819880"></p><p>这是渲染中的基本方程，它描述了如何根据表面的散射特性，将光线在某个点的入射分布转换为出射分布。当球体$S^2$是积分域时，它通常被称为<strong>散射方程</strong>，或者知识在上半球$H^2(n)$积分</p><h3 id="The-BSSRDF-The-Bidirectional-Scattering-Surface-Reflectance-Distribution-Function"><a href="#The-BSSRDF-The-Bidirectional-Scattering-Surface-Reflectance-Distribution-Function" class="headerlink" title="The BSSRDF(The Bidirectional Scattering Surface Reflectance Distribution Function)"></a>The BSSRDF(The Bidirectional Scattering Surface Reflectance Distribution Function)</h3><p>双向散射表面反射率分布函数，是描述具有大量次表面光传输的材质散射的方程，它是如下的分布函数</p><p><img src="/2022/07/13/PBRT-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220703174353181.png" alt="image-20220703174353181"></p><p>该函数描述了$w_0$方向上$p_0$点的出射微分辐射度，与$w_i$方向上$p_i$点的入射微分通量之比</p><p>BSSRDF散射方程的一般化需要对表面积和入射方向进行积分</p><p><img src="/2022/07/13/PBRT-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/image-20220703184721537.png" alt="image-20220703184721537"></p><p>随着点$p_i$和$p_0$之间的距离增加，$S$的值通常会减少，这一事实对次表面散射算法实现有很大帮助</p>]]></content>
    
    
    <categories>
      
      <category>CG</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CG</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UnityShader-标准光照Shader</title>
    <link href="/2021/07/23/UnityShader%20-%E6%A0%87%E5%87%86%E5%85%89%E7%85%A7Shader/"/>
    <url>/2021/07/23/UnityShader%20-%E6%A0%87%E5%87%86%E5%85%89%E7%85%A7Shader/</url>
    
    <content type="html"><![CDATA[<h1 id="UnityShader-标准光照Shader"><a href="#UnityShader-标准光照Shader" class="headerlink" title="UnityShader-标准光照Shader"></a>UnityShader-标准光照Shader</h1><h2 id="BumpedDiffuse-shader"><a href="#BumpedDiffuse-shader" class="headerlink" title="BumpedDiffuse.shader"></a>BumpedDiffuse.shader</h2><p>包含不透明物体渲染、凹凸纹理、漫反射、各种光源的计算，默认为平行光设置阴影</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><code class="hljs glsl">Shader &quot;Unity Shaders Book/Common/Bumped Diffuse&quot; &#123;<br>Properties &#123;<br>_Color (&quot;Color Tint&quot;, Color) = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>_MainTex (&quot;Main Tex&quot;, <span class="hljs-number">2</span>D) = &quot;white&quot; &#123;&#125;<br>_BumpMap (&quot;Normal Map&quot;, <span class="hljs-number">2</span>D) = &quot;bump&quot; &#123;&#125;<br>&#125;<br>SubShader &#123;<br>Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot;&#125;<br><br>Pass &#123; <br>Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;<br><br>CGPROGRAM<br><br><span class="hljs-meta">#pragma multi_compile_fwdbase</span><br><br><span class="hljs-meta">#pragma vertex vert</span><br><span class="hljs-meta">#pragma fragment frag</span><br><br><span class="hljs-meta">#include &quot;Lighting.cginc&quot;</span><br><span class="hljs-meta">#include &quot;AutoLight.cginc&quot;</span><br><br>fixed4 _Color;<br><span class="hljs-type">sampler2D</span> _MainTex;<br>float4 _MainTex_ST;<br><span class="hljs-type">sampler2D</span> _BumpMap;<br>float4 _BumpMap_ST;<br><br>struct a2v &#123;<br>float4 vertex : POSITION;<br>float3 normal : NORMAL;<br>float4 tangent : TANGENT;<br>float4 texcoord : TEXCOORD0;<br>&#125;;<br><br>struct v2f &#123;<br>float4 pos : SV_POSITION;<br>float4 uv : TEXCOORD0;<br>float4 TtoW0 : TEXCOORD1;  <br>float4 TtoW1 : TEXCOORD2;  <br>float4 TtoW2 : TEXCOORD3;<br>SHADOW_COORDS(<span class="hljs-number">4</span>)<br>&#125;;<br><br>v2f vert(a2v v) &#123;<br>v2f o;<br>o.pos = UnityObjectToClipPos(v.vertex);<br><br>o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;<br>o.uv.zw = v.texcoord.xy * _BumpMap_ST.xy + _BumpMap_ST.zw;<br><br>float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;  <br>fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);  <br>fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);  <br>fixed3 worldBinormal = <span class="hljs-built_in">cross</span>(worldNormal, worldTangent) * v.tangent.w; <br><br>o.TtoW0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);<br>o.TtoW1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);<br>o.TtoW2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);  <br><br>TRANSFER_SHADOW(o);<br><br><span class="hljs-keyword">return</span> o;<br>&#125;<br><br>fixed4 frag(v2f i) : SV_Target &#123;<br>float3 worldPos = float3(i.TtoW0.w, i.TtoW1.w, i.TtoW2.w);<br>fixed3 lightDir = <span class="hljs-built_in">normalize</span>(UnityWorldSpaceLightDir(worldPos));<br>fixed3 viewDir = <span class="hljs-built_in">normalize</span>(UnityWorldSpaceViewDir(worldPos));<br><br>fixed3 bump = UnpackNormal(tex2D(_BumpMap, i.uv.zw));<br>bump = <span class="hljs-built_in">normalize</span>(half3(<span class="hljs-built_in">dot</span>(i.TtoW0.xyz, bump), <span class="hljs-built_in">dot</span>(i.TtoW1.xyz, bump), <span class="hljs-built_in">dot</span>(i.TtoW2.xyz, bump)));<br><br>fixed3 albedo = tex2D(_MainTex, i.uv.xy).rgb * _Color.rgb;<br><br>fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;<br><br> fixed3 diffuse = _LightColor0.rgb * albedo * <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">dot</span>(bump, lightDir));<br><br>UNITY_LIGHT_ATTENUATION(atten, i, worldPos);<br><br><span class="hljs-keyword">return</span> fixed4(ambient + diffuse * atten, <span class="hljs-number">1.0</span>);<br>&#125;<br><br>ENDCG<br>&#125;<br><br>Pass &#123; <br>Tags &#123; &quot;LightMode&quot;=&quot;ForwardAdd&quot; &#125;<br><br>Blend One One<br><br>CGPROGRAM<br><br><span class="hljs-meta">#pragma multi_compile_fwdadd</span><br><span class="hljs-comment">// Use the line below to add shadows for point and spot lights</span><br><span class="hljs-comment">//#pragma multi_compile_fwdadd_fullshadows</span><br><br><span class="hljs-meta">#pragma vertex vert</span><br><span class="hljs-meta">#pragma fragment frag</span><br><br><span class="hljs-meta">#include &quot;Lighting.cginc&quot;</span><br><span class="hljs-meta">#include &quot;AutoLight.cginc&quot;</span><br><br>fixed4 _Color;<br><span class="hljs-type">sampler2D</span> _MainTex;<br>float4 _MainTex_ST;<br><span class="hljs-type">sampler2D</span> _BumpMap;<br>float4 _BumpMap_ST;<br><br>struct a2v &#123;<br>float4 vertex : POSITION;<br>float3 normal : NORMAL;<br>float4 tangent : TANGENT;<br>float4 texcoord : TEXCOORD0;<br>&#125;;<br><br>struct v2f &#123;<br>float4 pos : SV_POSITION;<br>float4 uv : TEXCOORD0;<br>float4 TtoW0 : TEXCOORD1;  <br>float4 TtoW1 : TEXCOORD2;  <br>float4 TtoW2 : TEXCOORD3;<br>SHADOW_COORDS(<span class="hljs-number">4</span>)<br>&#125;;<br><br>v2f vert(a2v v) &#123;<br>v2f o;<br>o.pos = UnityObjectToClipPos(v.vertex);<br><br>o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;<br>o.uv.zw = v.texcoord.xy * _BumpMap_ST.xy + _BumpMap_ST.zw;<br><br>float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;  <br>fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);  <br>fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);  <br>fixed3 worldBinormal = <span class="hljs-built_in">cross</span>(worldNormal, worldTangent) * v.tangent.w; <br><br>o.TtoW0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);<br>o.TtoW1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);<br>o.TtoW2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);  <br><br>TRANSFER_SHADOW(o);<br><br><span class="hljs-keyword">return</span> o;<br>&#125;<br><br>fixed4 frag(v2f i) : SV_Target &#123;<br>float3 worldPos = float3(i.TtoW0.w, i.TtoW1.w, i.TtoW2.w);<br>fixed3 lightDir = <span class="hljs-built_in">normalize</span>(UnityWorldSpaceLightDir(worldPos));<br>fixed3 viewDir = <span class="hljs-built_in">normalize</span>(UnityWorldSpaceViewDir(worldPos));<br><br>fixed3 bump = UnpackNormal(tex2D(_BumpMap, i.uv.zw));<br>bump = <span class="hljs-built_in">normalize</span>(half3(<span class="hljs-built_in">dot</span>(i.TtoW0.xyz, bump), <span class="hljs-built_in">dot</span>(i.TtoW1.xyz, bump), <span class="hljs-built_in">dot</span>(i.TtoW2.xyz, bump)));<br><br>fixed3 albedo = tex2D(_MainTex, i.uv.xy).rgb * _Color.rgb;<br><br> fixed3 diffuse = _LightColor0.rgb * albedo * <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">dot</span>(bump, lightDir));<br><br>UNITY_LIGHT_ATTENUATION(atten, i, worldPos);<br><br><span class="hljs-keyword">return</span> fixed4(diffuse * atten, <span class="hljs-number">1.0</span>);<br>&#125;<br><br>ENDCG<br>&#125;<br>&#125; <br>FallBack &quot;Diffuse&quot;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="BumpedSpecular-shader"><a href="#BumpedSpecular-shader" class="headerlink" title="BumpedSpecular.shader"></a>BumpedSpecular.shader</h2><p>包含不透明物体渲染、凹凸纹理、漫反射、高光反射以及各种光源的计算，默认为平行光设置阴影</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><code class="hljs glsl">Shader &quot;Unity Shaders Book/Common/Bumped Specular&quot; &#123;<br>Properties &#123;<br>_Color (&quot;Color Tint&quot;, Color) = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>_MainTex (&quot;Main Tex&quot;, <span class="hljs-number">2</span>D) = &quot;white&quot; &#123;&#125;<br>_BumpMap (&quot;Normal Map&quot;, <span class="hljs-number">2</span>D) = &quot;bump&quot; &#123;&#125;<br>_Specular (&quot;Specular Color&quot;, Color) = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>_Gloss (&quot;Gloss&quot;, Range(<span class="hljs-number">8.0</span>, <span class="hljs-number">256</span>)) = <span class="hljs-number">20</span><br>&#125;<br>SubShader &#123;<br>Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &quot;Queue&quot;=&quot;Geometry&quot;&#125;<br><br>Pass &#123; <br>Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;<br><br>CGPROGRAM<br><br><span class="hljs-meta">#pragma multi_compile_fwdbase</span><br><br><span class="hljs-meta">#pragma vertex vert</span><br><span class="hljs-meta">#pragma fragment frag</span><br><br><span class="hljs-meta">#include &quot;UnityCG.cginc&quot;</span><br><span class="hljs-meta">#include &quot;Lighting.cginc&quot;</span><br><span class="hljs-meta">#include &quot;AutoLight.cginc&quot;</span><br><br>fixed4 _Color;<br><span class="hljs-type">sampler2D</span> _MainTex;<br>float4 _MainTex_ST;<br><span class="hljs-type">sampler2D</span> _BumpMap;<br>float4 _BumpMap_ST;<br>fixed4 _Specular;<br><span class="hljs-type">float</span> _Gloss;<br><br>struct a2v &#123;<br>float4 vertex : POSITION;<br>float3 normal : NORMAL;<br>float4 tangent : TANGENT;<br>float4 texcoord : TEXCOORD0;<br>&#125;;<br><br>struct v2f &#123;<br>float4 pos : SV_POSITION;<br>float4 uv : TEXCOORD0;<br>float4 TtoW0 : TEXCOORD1;  <br>                float4 TtoW1 : TEXCOORD2;  <br>                float4 TtoW2 : TEXCOORD3; <br>SHADOW_COORDS(<span class="hljs-number">4</span>)<br>&#125;;<br><br>v2f vert(a2v v) &#123;<br> v2f o;<br> o.pos = UnityObjectToClipPos(v.vertex);<br> <br> o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;<br> o.uv.zw = v.texcoord.xy * _BumpMap_ST.xy + _BumpMap_ST.zw;<br><br>TANGENT_SPACE_ROTATION;<br><br>float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;  <br>                fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);  <br>                fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);  <br>                fixed3 worldBinormal = <span class="hljs-built_in">cross</span>(worldNormal, worldTangent) * v.tangent.w; <br>                <br>                o.TtoW0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);  <br>                o.TtoW1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);  <br>                o.TtoW2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);  <br>  <br>  TRANSFER_SHADOW(o);<br> <br> <span class="hljs-keyword">return</span> o;<br>&#125;<br><br>fixed4 frag(v2f i) : SV_Target &#123;<br>float3 worldPos = float3(i.TtoW0.w, i.TtoW1.w, i.TtoW2.w);<br>fixed3 lightDir = <span class="hljs-built_in">normalize</span>(UnityWorldSpaceLightDir(worldPos));<br>fixed3 viewDir = <span class="hljs-built_in">normalize</span>(UnityWorldSpaceViewDir(worldPos));<br><br>fixed3 bump = UnpackNormal(tex2D(_BumpMap, i.uv.zw));<br>bump = <span class="hljs-built_in">normalize</span>(half3(<span class="hljs-built_in">dot</span>(i.TtoW0.xyz, bump), <span class="hljs-built_in">dot</span>(i.TtoW1.xyz, bump), <span class="hljs-built_in">dot</span>(i.TtoW2.xyz, bump)));<br><br>fixed3 albedo = tex2D(_MainTex, i.uv.xy).rgb * _Color.rgb;<br><br>fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;<br><br> fixed3 diffuse = _LightColor0.rgb * albedo * <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">dot</span>(bump, lightDir));<br> <br> fixed3 halfDir = <span class="hljs-built_in">normalize</span>(lightDir + viewDir);<br> fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="hljs-built_in">pow</span>(<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">dot</span>(bump, halfDir)), _Gloss);<br><br>UNITY_LIGHT_ATTENUATION(atten, i, worldPos);<br><br><span class="hljs-keyword">return</span> fixed4(ambient + (diffuse + specular) * atten, <span class="hljs-number">1.0</span>);<br>&#125;<br><br>ENDCG<br>&#125;<br><br>Pass &#123; <br>Tags &#123; &quot;LightMode&quot;=&quot;ForwardAdd&quot; &#125;<br><br>Blend One One<br><br>CGPROGRAM<br><br><span class="hljs-meta">#pragma multi_compile_fwdadd</span><br><span class="hljs-comment">// Use the line below to add shadows for point and spot lights</span><br><span class="hljs-comment">//#pragma multi_compile_fwdadd_fullshadows</span><br><br><span class="hljs-meta">#pragma vertex vert</span><br><span class="hljs-meta">#pragma fragment frag</span><br><br><span class="hljs-meta">#include &quot;Lighting.cginc&quot;</span><br><span class="hljs-meta">#include &quot;AutoLight.cginc&quot;</span><br><br>fixed4 _Color;<br><span class="hljs-type">sampler2D</span> _MainTex;<br>float4 _MainTex_ST;<br><span class="hljs-type">sampler2D</span> _BumpMap;<br>float4 _BumpMap_ST;<br><span class="hljs-type">float</span> _BumpScale;<br>fixed4 _Specular;<br><span class="hljs-type">float</span> _Gloss;<br><br>struct a2v &#123;<br>float4 vertex : POSITION;<br>float3 normal : NORMAL;<br>float4 tangent : TANGENT;<br>float4 texcoord : TEXCOORD0;<br>&#125;;<br><br>struct v2f &#123;<br>float4 pos : SV_POSITION;<br>float4 uv : TEXCOORD0;<br>float4 TtoW0 : TEXCOORD1;  <br>                float4 TtoW1 : TEXCOORD2;  <br>                float4 TtoW2 : TEXCOORD3;<br>SHADOW_COORDS(<span class="hljs-number">4</span>)<br>&#125;;<br><br>v2f vert(a2v v) &#123;<br> v2f o;<br> o.pos = UnityObjectToClipPos(v.vertex);<br> <br> o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;<br> o.uv.zw = v.texcoord.xy * _BumpMap_ST.xy + _BumpMap_ST.zw;<br><br>float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;  <br>                fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);  <br>                fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);  <br>                fixed3 worldBinormal = <span class="hljs-built_in">cross</span>(worldNormal, worldTangent) * v.tangent.w; <br><br>  o.TtoW0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);<br>  o.TtoW1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);<br>  o.TtoW2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);  <br> <br> TRANSFER_SHADOW(o);<br> <br> <span class="hljs-keyword">return</span> o;<br>&#125;<br><br>fixed4 frag(v2f i) : SV_Target &#123;<br>float3 worldPos = float3(i.TtoW0.w, i.TtoW1.w, i.TtoW2.w);<br>fixed3 lightDir = <span class="hljs-built_in">normalize</span>(UnityWorldSpaceLightDir(worldPos));<br>fixed3 viewDir = <span class="hljs-built_in">normalize</span>(UnityWorldSpaceViewDir(worldPos));<br><br>fixed3 bump = UnpackNormal(tex2D(_BumpMap, i.uv.zw));<br>bump = <span class="hljs-built_in">normalize</span>(half3(<span class="hljs-built_in">dot</span>(i.TtoW0.xyz, bump), <span class="hljs-built_in">dot</span>(i.TtoW1.xyz, bump), <span class="hljs-built_in">dot</span>(i.TtoW2.xyz, bump)));<br><br>fixed3 albedo = tex2D(_MainTex, i.uv.xy).rgb * _Color.rgb;<br><br> fixed3 diffuse = _LightColor0.rgb * albedo * <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">dot</span>(bump, lightDir));<br> <br> fixed3 halfDir = <span class="hljs-built_in">normalize</span>(lightDir + viewDir);<br> fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="hljs-built_in">pow</span>(<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">dot</span>(bump, halfDir)), _Gloss);<br><br>UNITY_LIGHT_ATTENUATION(atten, i, worldPos);<br><br><span class="hljs-keyword">return</span> fixed4((diffuse + specular) * atten, <span class="hljs-number">1.0</span>);<br>&#125;<br><br>ENDCG<br>&#125;<br>&#125; <br>FallBack &quot;Specular&quot;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>Shader</tag>
      
      <tag>Lighting</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UnityShader-复杂光照</title>
    <link href="/2021/07/22/UnityShader-%E5%A4%8D%E6%9D%82%E5%85%89%E7%85%A7/"/>
    <url>/2021/07/22/UnityShader-%E5%A4%8D%E6%9D%82%E5%85%89%E7%85%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="UnityShader-复杂光照"><a href="#UnityShader-复杂光照" class="headerlink" title="UnityShader-复杂光照"></a>UnityShader-复杂光照</h1><h2 id="渲染路径-Rendering-Path"><a href="#渲染路径-Rendering-Path" class="headerlink" title="渲染路径(Rendering Path)"></a>渲染路径(Rendering Path)</h2><p>渲染路径决定了光照如何应用到UnityShader中，Unity包含3中渲染路径：</p><ul><li>前向渲染路径(Forward Rendering Path)</li><li>延迟渲染路径(Deffered Rendering Path)</li><li>顶点照明路径(Vertex Lit Rendering Path)</li></ul><p>大多数情况下，一个项目只使用一种渲染路径，如果在摄像机中额外设置，则会覆盖掉全局渲染路径</p><p>可以在Pass中使用标签来指定使用的渲染路径，如果没有指定任何渲染路径，那么一些光照变量很可能无法被正确赋值，计算结果也会出现偏差</p><p><img src="/2021/07/22/UnityShader-%E5%A4%8D%E6%9D%82%E5%85%89%E7%85%A7/image-20210820175739669.png" alt="image-20210820175739669"></p><h3 id="前向渲染路径"><a href="#前向渲染路径" class="headerlink" title="前向渲染路径"></a>前向渲染路径</h3><p>最常用的一种渲染路径，每进行一次完整的前向渲染，需要渲染该对象的渲染图元，并计算两个缓冲区信息：颜色缓冲区和深度缓冲区</p><p>前向渲染可以用以下伪代码表示：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs glsl">Pass &#123;<br>    <span class="hljs-keyword">for</span> (each primitive <span class="hljs-keyword">in</span> this model) &#123;<br>        <span class="hljs-keyword">for</span> (each fragment covered by this primitive) &#123;<br>            <span class="hljs-keyword">if</span> (failed <span class="hljs-keyword">in</span> depth test) &#123;<br>                <span class="hljs-comment">// 该片元不可见，舍弃</span><br>                <span class="hljs-keyword">discard</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 进行光照计算</span><br>                float4 color = Shading(materialInfo, pos, normal, lightDir, viewDir);<br>                <span class="hljs-comment">// 更新帧缓冲</span><br>                writeFrameBuffer(fragment, color);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>假设场景中有N个物体，每个物体受到M个光源的影响，那么要渲染整个场景一共需要N*M个Pass</p><p>在Unity中，前向渲染路径有3中处理光照方式：</p><ul><li>逐顶点处理</li><li>逐像素处理</li><li>球谐函数(Spherical Harmonics, SH)处理</li></ul><p>决定一个光源使用哪种处理模式取决于<strong>光源类型</strong>和<strong>渲染模式</strong></p><p>光源类型：该光源是平行光、点光源、聚光源等</p><p>渲染模式：该光源是否是重要的，<strong>如果设置为Important，则按照逐像素光源来处理</strong>，否则按照逐顶点处理，如果你在Base Pass中又没有计算逐顶点光照，那么该光源就不会被纳入计算了</p><p>Unity中会按照重要度对光源进行处理，一般来说，一定数目的光源按照逐像素处理，最多4个光源按照逐顶点方式处理，剩下光源按照SH方式处理，判断规则如下：</p><ul><li>场景中最亮的平行光按照逐像素处理</li><li>渲染模式被设置成Not Important的光源，会按照逐顶点或者SH处理</li><li>渲染模式被设置成Important光源，会按照逐像素处理</li></ul><p>如果以上规则得到的逐像素光源数量小于Quality Setting中的逐像素光源数量(Pixel Light Count)，会有更多的光源按照逐像素的方式进行渲染</p><p>前向渲染分为两种Pass：Base Pass和Additional Pass，它们的设置如下：</p><p><img src="/2021/07/22/UnityShader-%E5%A4%8D%E6%9D%82%E5%85%89%E7%85%A7/forward_rendering.png" alt="forward_rendering.png-175.5kB"></p><p>说明：</p><ul><li>渲染设置中的编译指令会影响光照变量的正确值</li><li>Additional Pass中需要使用编译指令来开启阴影效果</li><li>环境光和自发光在Base Pass中计算，如果在Additional Pass中计算可能被多次计算（每次计算逐像素光源都会重复计算一次环境光ambient）</li><li>在Additional Pass的渲染设置中开启和设置了<strong>混合模式</strong>，这样可以与上一次的光照结果在帧缓存中进行叠加，从而得到最终的多个光照的渲染结果，否则只会得到最后一次光照结果</li><li>一个Unity Shader定义1个或多个Base Pass和一个Additional Pass，一个Base Pass只会执行一次，而一个Additional Pass会根据影响该物体的其他逐像素光源的数目被多次调用，即<strong>每个逐像素光源会执行一次Additional Pass</strong></li></ul><p>常用内置光照变量如下：</p><p><img src="/2021/07/22/UnityShader-%E5%A4%8D%E6%9D%82%E5%85%89%E7%85%A7/image-20210820191518965.png" alt="image-20210820191518965"></p><p>常用内置光照函数如下：</p><p><img src="/2021/07/22/UnityShader-%E5%A4%8D%E6%9D%82%E5%85%89%E7%85%A7/image-20210820191601706.png" alt="image-20210820191601706"></p><h3 id="顶点照明渲染路径"><a href="#顶点照明渲染路径" class="headerlink" title="顶点照明渲染路径"></a>顶点照明渲染路径</h3><p>顶点渲染路径是对硬件配置要求最少、运算性能最高，但同时也是效果最差的类型</p><p>不支持逐像素才能得到的效果，如阴影、法线映射、高精度的光照反射等</p><p>不可以使用逐像素光照变量（Unity只填充逐顶点相关光源变量）</p><p>可访问的内置变量和函数：</p><p><img src="/2021/07/22/UnityShader-%E5%A4%8D%E6%9D%82%E5%85%89%E7%85%A7/image-20210820192142596.png" alt="image-20210820192142596"></p><p><img src="/2021/07/22/UnityShader-%E5%A4%8D%E6%9D%82%E5%85%89%E7%85%A7/image-20210820192202121.png" alt="image-20210820192202121"></p><h3 id="延迟渲染路径"><a href="#延迟渲染路径" class="headerlink" title="延迟渲染路径"></a>延迟渲染路径</h3><p>当场景中包含大量实时光源时，前向渲染的性能会急速下降，因为场景中有多个光源时会执行多次Pass，而每个Pass都要重新渲染一遍物体，导致计算重复</p><p>延迟渲染除了使用颜色缓冲和深度缓冲之外，还会利用额外的缓冲区，称为G缓冲(G-buffer)，用于存储我们所关心的表面（通常指离摄像机最近的表面）的其他信息，如表面法线、位置、用于光照计算的材质属性等</p><p>原理：</p><p>延迟渲染主要包含两个Pass：</p><ol><li><p>第一个Pass中，不进行任何光照计算，仅仅计算哪些片元是可见的（通过深度缓冲技术实现），然后把它的相关信息放到G缓冲区中。具体来说，会把物体的<strong>漫反射颜色、高光反射颜色、平滑度、法线、自发光、深度</strong>等信息渲染到屏幕空间的G缓冲区中，对于每个物体而言只会执行一次</p></li><li><p>第二个Pass中，利用G缓冲区的各个片元信息，例如表面法线、视角方向、漫反射系数等，进行真正的光照计算。此时，我们只需要对G缓冲中的每个屏幕像素执行一次昂贵的光照计算（相比于对每个物体上的每个像素进行计算节省了非常多的性能）</p><p>这里《Shader入门精要》讲得不是很详细，推荐链接：[延迟着色法 - LearnOpenGL CN (learnopengl-cn.github.io)](<a href="https://learnopengl-cn.github.io/05">https://learnopengl-cn.github.io/05</a> Advanced Lighting&#x2F;08 Deferred Shading&#x2F;)</p></li></ol><p>可以用以下伪代码描述：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs glsl">Pass1 &#123;<br>    <span class="hljs-comment">// 不进行真正光照计算</span><br>    <span class="hljs-keyword">for</span> (each primitive <span class="hljs-keyword">in</span> this model) &#123;<br>        <span class="hljs-keyword">for</span> (each fragment covered by this primitive) &#123;<br>            <span class="hljs-keyword">if</span> (failed <span class="hljs-keyword">in</span> depth test)<br>            <span class="hljs-keyword">discard</span>;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 把需要的信息存储到G缓冲中</span><br>                writeGBuffer(materialInfo, pos, normal, lightDir, viewDir);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br>Pass2 &#123;<br>    <span class="hljs-comment">// 利用G缓冲中的信息进行真正的光照计算</span><br>    <span class="hljs-keyword">for</span> (each pixel <span class="hljs-keyword">in</span> the screen) &#123;<br>        <span class="hljs-keyword">if</span> (the pixel is valid) &#123;<br>            <span class="hljs-comment">// 如果像素是有效的</span><br>            <span class="hljs-comment">// 读取它对应的G缓冲中的信息</span><br>            readGBuffer(pixel, materialInfo, pos, normal, lightDir, viewDir);<br>            <br>            <span class="hljs-comment">// 根据读到的信息进行光照计算</span><br>            float4 color = Shading(materialInfo, pos, normal, lightDir, viewDir);<br>            <span class="hljs-comment">// 更新缓冲</span><br>            writeFrameBuffer(pixel, color);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因此，延迟渲染使用的Pass数目通常就2个，这跟场景中包含的光源数目没有关系，只和屏幕空间的大小有关</p><p>对于延迟渲染路径来说，它最适合在场景中光源数目很多，如果使用前向渲染会造成性能瓶颈时使用，且每个光源都能按逐像素方式处理</p><p>缺点：</p><ul><li>不支持真正的抗锯齿功能</li><li>不能处理半透明物体</li><li>对显卡有要求。必须支持MRT、Shader Mode3.0以上、深度渲染纹理以及双面的模板缓冲</li></ul><p><strong>可访问的内置变量和函数</strong></p><p><img src="/2021/07/22/UnityShader-%E5%A4%8D%E6%9D%82%E5%85%89%E7%85%A7/image-20210820201048993.png" alt="image-20210820201048993"></p><h2 id="光源类型"><a href="#光源类型" class="headerlink" title="光源类型"></a>光源类型</h2><p>Unity支持4种光源类型：平行光、点光源、聚光灯和面光源</p><p>常用光源属性：光源位置、方向、颜色、强度、衰减</p><h3 id="平行光"><a href="#平行光" class="headerlink" title="平行光"></a>平行光</h3><p>照亮范围没有限制，光源没有唯一位置，只有方向，光照强度不会衰减</p><h3 id="点光源"><a href="#点光源" class="headerlink" title="点光源"></a>点光源</h3><p>照亮空间为一个球体，光照强度会随着距离衰减</p><h3 id="聚光灯"><a href="#聚光灯" class="headerlink" title="聚光灯"></a>聚光灯</h3><p>照亮空间为一个锥形区域，在Unity面板中，半径由Range属性决定，张开角度由Spot Angle属性决定</p><br><p>一个用于多光源的Shader如下，其中的光照强度是使用数学公式计算的</p><ul><li>如果场景中包含多个平行光，Unity会选择<strong>最亮的平行光传递给Base Pass进行逐像素处理</strong>，<strong>其他平行光会按照逐顶点或者在Additional Pass中按照逐像素的方式处理</strong></li><li>对于Base Pass来说，它处理的逐像素光源类型一定是平行光</li></ul><p>该过程可以在Unity的帧调试器(Frame Debugger)中实验</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><code class="hljs glsl">Shader &quot;Forward Rendering&quot; &#123;<br>Properties &#123;<br>_Diffuse (&quot;Diffuse&quot;, Color) = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>_Specular (&quot;Specular&quot;, Color) = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>_Gloss (&quot;Gloss&quot;, Range(<span class="hljs-number">8.0</span>, <span class="hljs-number">256</span>)) = <span class="hljs-number">20</span><br>&#125;<br>SubShader &#123;<br>Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;<br><br>Pass &#123;<br><span class="hljs-comment">// Pass for ambient light &amp; first pixel light (directional light)</span><br>Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;<br><br>CGPROGRAM<br><br><span class="hljs-comment">// Apparently need to add this declaration </span><br>            <span class="hljs-comment">// 保证在Shader中使用光照衰减等光照变量可以被正确赋值</span><br><span class="hljs-meta">#pragma multi_compile_fwdbase</span><br><br><span class="hljs-meta">#pragma vertex vert</span><br><span class="hljs-meta">#pragma fragment frag</span><br><br><span class="hljs-meta">#include &quot;Lighting.cginc&quot;</span><br><br>fixed4 _Diffuse;<br>fixed4 _Specular;<br><span class="hljs-type">float</span> _Gloss;<br><br>struct a2v &#123;<br>float4 vertex : POSITION;<br>float3 normal : NORMAL;<br>&#125;;<br><br>struct v2f &#123;<br>float4 pos : SV_POSITION;<br>float3 worldNormal : TEXCOORD0;<br>float3 worldPos : TEXCOORD1;<br>&#125;;<br><br>v2f vert(a2v v) &#123;<br>v2f o;<br>o.pos = UnityObjectToClipPos(v.vertex);<br><br>o.worldNormal = UnityObjectToWorldNormal(v.normal);<br><br>o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<br><br><span class="hljs-keyword">return</span> o;<br>&#125;<br><br>fixed4 frag(v2f i) : SV_Target &#123;<br>fixed3 worldNormal = <span class="hljs-built_in">normalize</span>(i.worldNormal);<br>fixed3 worldLightDir = <span class="hljs-built_in">normalize</span>(_WorldSpaceLightPos0.xyz);<br><br>fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;<br><br> fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">dot</span>(worldNormal, worldLightDir));<br><br> fixed3 viewDir = <span class="hljs-built_in">normalize</span>(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);<br> fixed3 halfDir = <span class="hljs-built_in">normalize</span>(worldLightDir + viewDir);<br><br>                <span class="hljs-comment">// Compute specular term</span><br> fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="hljs-built_in">pow</span>(<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">dot</span>(worldNormal, halfDir)), _Gloss);<br><br>                <span class="hljs-comment">// The attenuation of directional light is always 1</span><br>fixed atten = <span class="hljs-number">1.0</span>;<br><br><span class="hljs-keyword">return</span> fixed4(ambient + (diffuse + specular) * atten, <span class="hljs-number">1.0</span>);<br>&#125;<br><br>ENDCG<br>&#125;<br><br>Pass &#123;<br><span class="hljs-comment">// Pass for other pixel lights</span><br>Tags &#123; &quot;LightMode&quot;=&quot;ForwardAdd&quot; &#125;<br><br>            <span class="hljs-comment">// 计算得到的光照结果可以在帧缓存中与之前的光照结果进行叠加</span><br>            <span class="hljs-comment">// 如果没有使用Blend命令，Additional Pass会直接覆盖掉之前的光照结果</span><br>Blend One One<br><br>CGPROGRAM<br><br><span class="hljs-comment">// Apparently need to add this declaration</span><br><span class="hljs-meta">#pragma multi_compile_fwdadd</span><br><br><span class="hljs-meta">#pragma vertex vert</span><br><span class="hljs-meta">#pragma fragment frag</span><br><br><span class="hljs-meta">#include &quot;Lighting.cginc&quot;</span><br><span class="hljs-meta">#include &quot;AutoLight.cginc&quot;</span><br><br>fixed4 _Diffuse;<br>fixed4 _Specular;<br><span class="hljs-type">float</span> _Gloss;<br><br>struct a2v &#123;<br>float4 vertex : POSITION;<br>float3 normal : NORMAL;<br>&#125;;<br><br>struct v2f &#123;<br>float4 pos : SV_POSITION;<br>float3 worldNormal : TEXCOORD0;<br>float3 worldPos : TEXCOORD1;<br>&#125;;<br><br>v2f vert(a2v v) &#123;<br>v2f o;<br>o.pos = UnityObjectToClipPos(v.vertex);<br><br>o.worldNormal = UnityObjectToWorldNormal(v.normal);<br><br>o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<br><br><span class="hljs-keyword">return</span> o;<br>&#125;<br><br>fixed4 frag(v2f i) : SV_Target &#123;<br>fixed3 worldNormal = <span class="hljs-built_in">normalize</span>(i.worldNormal);<br>                <span class="hljs-comment">// 平行光没有位置信息</span><br><span class="hljs-meta">#ifdef USING_DIRECTIONAL_LIGHT</span><br>fixed3 worldLightDir = <span class="hljs-built_in">normalize</span>(_WorldSpaceLightPos0.xyz);<br>                <span class="hljs-comment">// 其他光源有位置信息，光照方向为光源位置 - 世界空间顶点位置</span><br><span class="hljs-meta">#else</span><br>fixed3 worldLightDir = <span class="hljs-built_in">normalize</span>(_WorldSpaceLightPos0.xyz - i.worldPos.xyz);<br><span class="hljs-meta">#endif</span><br><br>fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">dot</span>(worldNormal, worldLightDir));<br><br>fixed3 viewDir = <span class="hljs-built_in">normalize</span>(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);<br>fixed3 halfDir = <span class="hljs-built_in">normalize</span>(worldLightDir + viewDir);<br>fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="hljs-built_in">pow</span>(<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">dot</span>(worldNormal, halfDir)), _Gloss);<br><br>                <span class="hljs-comment">// 注意到一次只能计算一个光源的强度!</span><br>                <span class="hljs-comment">// 平行光不衰减</span><br><span class="hljs-meta">#ifdef USING_DIRECTIONAL_LIGHT</span><br>fixed atten = <span class="hljs-number">1.0</span>;<br><span class="hljs-meta">#else</span><br><span class="hljs-meta">#if defined (POINT)</span><br>                        <span class="hljs-comment">// 将世界空间中的顶点变换到光源空间</span><br>        float3 lightCoord = mul(unity_WorldToLight, float4(i.worldPos, <span class="hljs-number">1</span>)).xyz;<br>                        <span class="hljs-comment">// 使用该坐标模的平方计算衰减</span><br>                        <span class="hljs-comment">// dot出来的是一个一维值，因此.rr把它变成二维值用于在u,v方向采样</span><br>                        <span class="hljs-comment">// UNITY_ATTEN_CHANNEL 得到衰减纹理中衰减值所在的分量</span><br>        fixed atten = tex2D(_LightTexture0, <span class="hljs-built_in">dot</span>(lightCoord, lightCoord).rr).UNITY_ATTEN_CHANNEL;<br>    <span class="hljs-meta">#elif defined (SPOT)</span><br>        float4 lightCoord = mul(unity_WorldToLight, float4(i.worldPos, <span class="hljs-number">1</span>));<br>                        <span class="hljs-comment">// 聚光灯的衰减计算，原理待补充</span><br>        fixed atten = (lightCoord.z &gt; <span class="hljs-number">0</span>) * tex2D(_LightTexture0, lightCoord.xy / lightCoord.w + <span class="hljs-number">0.5</span>).w * tex2D(_LightTextureB0, <span class="hljs-built_in">dot</span>(lightCoord, lightCoord).rr).UNITY_ATTEN_CHANNEL;<br>    <span class="hljs-meta">#else</span><br>        fixed atten = <span class="hljs-number">1.0</span>;<br>    <span class="hljs-meta">#endif</span><br><span class="hljs-meta">#endif</span><br><br><span class="hljs-keyword">return</span> fixed4((diffuse + specular) * atten, <span class="hljs-number">1.0</span>);<br>&#125;<br><br>ENDCG<br>&#125;<br>&#125;<br>FallBack &quot;Specular&quot;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>由于光源衰减涉及到大量复杂计算，因此Unity选择使用一张纹理作为查找表(Lookup Table, LUT)，以在片元着色器中得到光源的衰减。</p><p><strong>默认情况下，一个物体可以接收除最亮的平行光之外的4个逐像素光照</strong>（理解为存在平行光的情况下，执行4次Additional Pass）。可以通过Edit-&gt;Project Settings-&gt;Quality-&gt;Pixel Light Count修改默认值</p><h2 id="光照衰减"><a href="#光照衰减" class="headerlink" title="光照衰减"></a>光照衰减</h2><p>Unity使用衰减纹理计算逐像素光照的衰减，相比于直接计算能够提高性能</p><p>缺点：</p><ul><li>需要预处理得到采样纹理，纹理大小会影响衰减精度</li><li>不直观，不方便，一旦把数据存储到查找表中，就无法使用其他数学公式计算衰减</li></ul><p>Unity默认使用纹理查找方式来计算逐像素的点光源和聚光源的衰减</p><p><strong>用于光照衰减的纹理</strong></p><p>Unity内部使用_LightTexture0纹理计算光源衰减，其对角线上的纹理颜色值表明在<strong>光源空间</strong>中不同位置的点的衰减值，(0, 0)为最近点，(1, 1)为距离最远的点的衰减，可以通过_LightMatrix0把顶点从世界空间变换到光源空间</p><p>获取顶点在光源空间中的位置：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs glsl">float3 lightCoord = mul(unity_WorldToLight, float4(i.worldPos, <span class="hljs-number">1</span>)).xyz;<br></code></pre></td></tr></table></figure><p>使用坐标的模的平方对衰减纹理进行采样，获得衰减值：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-comment">// 使用该坐标模的平方计算衰减</span><br><span class="hljs-comment">// dot出来的是一个一维值，因此.rr把它变成二维值用于在u,v方向采样</span><br><span class="hljs-comment">// UNITY_ATTEN_CHANNEL 得到衰减纹理中衰减值所在的分量</span><br>fixed atten = tex2D(_LightTexture0, <span class="hljs-built_in">dot</span>(lightCoord, lightCoord).rr).UNITY_ATTEN_CHANNEL;<br></code></pre></td></tr></table></figure><h2 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h2><h3 id="阴影实现"><a href="#阴影实现" class="headerlink" title="阴影实现"></a>阴影实现</h3><p>原理：当一个光源发射的一条光线遇到一个不透明物体时，这条光线就不能再继续照射其他物体，因此物体就会向旁边的物体投射阴影</p><p>在实时渲染中，最常用的是<strong>Shadow Map技术</strong>。该技术首先把摄像机位置放在与光源重合的位置，那么场景中该光源的阴影区域就是那些摄像机看不到的地方</p><p>在前向渲染路径中，如果场景中最重要的平行光开启了阴影，Unity就会为该光源计算**阴影映射纹理(shadowmap)**。该纹理本质为一张深度图，记录了从该光源的位置出发、能看到的场景中距离它最近的表面的位置（具体来说记录了深度，有点类似深度测试）</p><p>Unity选择使用一个额外的Pass（相对于Base 和Additional Pass）来专门更新光源的阴影映射纹理，该Pass的LightMode标签为<strong>ShadowCaster</strong>，该Pass渲染目标为阴影映射纹理（或深度纹理）。</p><p><strong>当开启了光源的阴影效果后</strong>，渲染引擎首先在当前渲染物体的Unity Shader中找到LightMode为ShadowCaster的Pass，如果没有就在Fallback指定的Unity Shader中寻找，如果仍然没有找到，则该物体无法向其他物体投射阴影，但是可以接收来自其他物体投射的阴影</p><br><p>传统阴影映射纹理实现：</p><p>将顶点变换到光源空间，对阴影映射纹理进行采样，得到该位置的深度信息，如果该点深度值小于顶点深度值，说明该点位于阴影中</p><p><strong>Unity中阴影实现：</strong></p><p>采用<strong>屏幕空间的阴影映射技术(Screenspace Shadow Map)<strong>。Unity首先调用LightMode为ShadowCaster的Pass得到</strong>可投射阴影的光源的阴影映射纹理</strong>以及<strong>摄像机的深度纹理</strong>。然后根据光源的阴影映射纹理和摄像机纹理得到<strong>屏幕空间的阴影图</strong>。</p><p>如果摄像机的深度图中记录的表面深度大于转换到阴影映射纹理中的深度值，表面该表面通过了深度测试，是可见的，但是处在该光源的阴影之中。因此，阴影图包含了屏幕空间中所有阴影的区域。如果想要一个物体接收来自其他物体的阴影，只需要在Shader中对阴影图进行采样</p><ul><li><p>一个物体<strong>接收来自其他物体的阴影</strong>：在Shader中<strong>对阴影映射纹理（包括屏幕空间的阴影图）进行采样</strong>，把采样结果和最后光照结果相乘来产生阴影效果</p></li><li><p><strong>向其他物体投射阴影</strong>：把该物体加入到光源的阴影映射纹理计算中，让其他物体在对该阴影映射纹理采样时可以得到该物体的相关信息，该过程通过为该物体执行LightMode为Shadow Caster的Pass来实现。<strong>该Pass通常在Fallback的回调Shader中实现</strong></p></li></ul><p>注意：该技术需要显卡支持MRT，有些移动平台不支持此特性</p><h3 id="不透明物体阴影"><a href="#不透明物体阴影" class="headerlink" title="不透明物体阴影"></a>不透明物体阴影</h3><p>选择让一个物体投射或者接收阴影：设置Mesh Renderer组件中的Cast Shadows和Receive Shadows属性来实现</p><p>默认情况下，在计算光源的阴影映射纹理时会剔除掉物体的背面，对于没有正面的物体而言（如内置的平面），需要将Casst Shadows设置为Two Sided来允许物体的所有面计算阴影信息</p><p><strong>让其他物体接收阴影</strong>：使用三个内置宏，可以在AutoLight.cginc中找到声明</p><ul><li>SHADOW_COORDS：声明一个用于对阴影纹理采样的坐标，参数是下一个可用的插值寄存器的索引值</li><li>TRANSFER_SHADOW：在顶点着色器中计算上一步声明的阴影纹理坐标，不同平台有所差异</li><li>SHADOW_ATTENUATION：对相关纹理进行采样，得到阴影信息，在片元着色器中计算阴影值</li></ul><p>为了确保宏能够正确工作，需要保证：</p><ul><li>a2v中顶点坐标变量名为vertex</li><li>v2f中顶点位置变量名为pos</li></ul><p>只是在Base Pass中实现阴影的代码如下：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><code class="hljs glsl">Shader &quot;Shadow&quot; &#123;<br>Properties &#123;<br>_Diffuse (&quot;Diffuse&quot;, Color) = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>_Specular (&quot;Specular&quot;, Color) = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>_Gloss (&quot;Gloss&quot;, Range(<span class="hljs-number">8.0</span>, <span class="hljs-number">256</span>)) = <span class="hljs-number">20</span><br>&#125;<br>SubShader &#123;<br>Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;<br><br>Pass &#123;<br><span class="hljs-comment">// Pass for ambient light &amp; first pixel light (directional light)</span><br>Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;<br><br>CGPROGRAM<br><br><span class="hljs-comment">// Apparently need to add this declaration </span><br>            <span class="hljs-comment">// 保证在Shader中使用光照衰减等光照变量可以被正确赋值</span><br><span class="hljs-meta">#pragma multi_compile_fwdbase</span><br><br><span class="hljs-meta">#pragma vertex vert</span><br><span class="hljs-meta">#pragma fragment frag</span><br><br>            <span class="hljs-comment">// 包含计算阴影所用的宏</span><br>            <span class="hljs-meta">#include &quot;AutoLight.cginc&quot;</span><br><span class="hljs-meta">#include &quot;Lighting.cginc&quot;</span><br><br>fixed4 _Diffuse;<br>fixed4 _Specular;<br><span class="hljs-type">float</span> _Gloss;<br><br>struct a2v &#123;<br>float4 vertex : POSITION;<br>float3 normal : NORMAL;<br>&#125;;<br><br>struct v2f &#123;<br>float4 pos : SV_POSITION;<br>float3 worldNormal : TEXCOORD0;<br>float3 worldPos : TEXCOORD1;<br>                <span class="hljs-comment">// 声明一个用于对阴影纹理采样的坐标,参数需要下一个可用的插值寄存器的索引值</span><br>                SHADOW_COORDS(<span class="hljs-number">2</span>)<br>&#125;;<br><br>v2f vert(a2v v) &#123;<br>v2f o;<br>o.pos = UnityObjectToClipPos(v.vertex);<br><br>o.worldNormal = UnityObjectToWorldNormal(v.normal);<br><br>o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<br><br>                <span class="hljs-comment">// Pass shadow coordinates to pixel shader</span><br>                <span class="hljs-comment">// 在顶点着色器中计算阴影纹理的坐标</span><br>                TRANSFER_SHADOW(o);<br><br><span class="hljs-keyword">return</span> o;<br>&#125;<br><br>fixed4 frag(v2f i) : SV_Target &#123;<br>fixed3 worldNormal = <span class="hljs-built_in">normalize</span>(i.worldNormal);<br>fixed3 worldLightDir = <span class="hljs-built_in">normalize</span>(_WorldSpaceLightPos0.xyz);<br><br>                <span class="hljs-comment">// Use shadow coordinates to sample shadow map</span><br>                <span class="hljs-comment">// 在片元着色器中计算阴影的值</span><br>                fixed shadow = SHADOW_ATTENUATION(i);<br><br>fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;<br><br> fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">dot</span>(worldNormal, worldLightDir));<br><br> fixed3 viewDir = <span class="hljs-built_in">normalize</span>(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);<br> fixed3 halfDir = <span class="hljs-built_in">normalize</span>(worldLightDir + viewDir);<br><br>                <span class="hljs-comment">// Compute specular term</span><br> fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="hljs-built_in">pow</span>(<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">dot</span>(worldNormal, halfDir)), _Gloss);<br><br>                <span class="hljs-comment">// The attenuation of directional light is always 1</span><br>fixed atten = <span class="hljs-number">1.0</span>;<br><br><span class="hljs-keyword">return</span> fixed4(ambient + (diffuse + specular) * atten * shadow, <span class="hljs-number">1.0</span>);<br>&#125;<br><br>ENDCG<br>&#125;<br><br>Pass &#123;<br><span class="hljs-comment">// Pass for other pixel lights</span><br>Tags &#123; &quot;LightMode&quot;=&quot;ForwardAdd&quot; &#125;<br><br>            <span class="hljs-comment">// 计算得到的光照结果可以在帧缓存中与之前的光照结果进行叠加</span><br>            <span class="hljs-comment">// 如果没有使用Blend命令，Additional Pass会直接覆盖掉之前的光照结果</span><br>Blend One One<br><br>CGPROGRAM<br><br><span class="hljs-comment">// Apparently need to add this declaration</span><br><span class="hljs-meta">#pragma multi_compile_fwdadd</span><br><br><span class="hljs-meta">#pragma vertex vert</span><br><span class="hljs-meta">#pragma fragment frag</span><br><br><span class="hljs-meta">#include &quot;Lighting.cginc&quot;</span><br><span class="hljs-meta">#include &quot;AutoLight.cginc&quot;</span><br><br>fixed4 _Diffuse;<br>fixed4 _Specular;<br><span class="hljs-type">float</span> _Gloss;<br><br>struct a2v &#123;<br>float4 vertex : POSITION;<br>float3 normal : NORMAL;<br>&#125;;<br><br>struct v2f &#123;<br>float4 pos : SV_POSITION;<br>float3 worldNormal : TEXCOORD0;<br>float3 worldPos : TEXCOORD1;<br>&#125;;<br><br>v2f vert(a2v v) &#123;<br>v2f o;<br>o.pos = UnityObjectToClipPos(v.vertex);<br><br>o.worldNormal = UnityObjectToWorldNormal(v.normal);<br><br>o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<br><br><span class="hljs-keyword">return</span> o;<br>&#125;<br><br>fixed4 frag(v2f i) : SV_Target &#123;<br>fixed3 worldNormal = <span class="hljs-built_in">normalize</span>(i.worldNormal);<br>                <span class="hljs-comment">// 平行光没有位置信息</span><br><span class="hljs-meta">#ifdef USING_DIRECTIONAL_LIGHT</span><br>fixed3 worldLightDir = <span class="hljs-built_in">normalize</span>(_WorldSpaceLightPos0.xyz);<br>                <span class="hljs-comment">// 其他光源有位置信息，光照方向为光源位置 - 世界空间顶点位置</span><br><span class="hljs-meta">#else</span><br>fixed3 worldLightDir = <span class="hljs-built_in">normalize</span>(_WorldSpaceLightPos0.xyz - i.worldPos.xyz);<br><span class="hljs-meta">#endif</span><br><br>fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">dot</span>(worldNormal, worldLightDir));<br><br>fixed3 viewDir = <span class="hljs-built_in">normalize</span>(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);<br>fixed3 halfDir = <span class="hljs-built_in">normalize</span>(worldLightDir + viewDir);<br>fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="hljs-built_in">pow</span>(<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">dot</span>(worldNormal, halfDir)), _Gloss);<br><br>                <span class="hljs-comment">// 平行光不衰减</span><br><span class="hljs-meta">#ifdef USING_DIRECTIONAL_LIGHT</span><br>fixed atten = <span class="hljs-number">1.0</span>;<br><span class="hljs-meta">#else</span><br><span class="hljs-meta">#if defined (POINT)</span><br>                        <span class="hljs-comment">// 将世界空间中的顶点变换到光源空间</span><br>        float3 lightCoord = mul(unity_WorldToLight, float4(i.worldPos, <span class="hljs-number">1</span>)).xyz;<br>                        <span class="hljs-comment">// 使用该坐标模的平方计算衰减</span><br>                        <span class="hljs-comment">// dot出来的是一个一维值，因此.rr把它变成二维值用于在u,v方向采样</span><br>                        <span class="hljs-comment">// UNITY_ATTEN_CHANNEL 得到衰减纹理中衰减值所在的分量</span><br>        fixed atten = tex2D(_LightTexture0, <span class="hljs-built_in">dot</span>(lightCoord, lightCoord).rr).UNITY_ATTEN_CHANNEL;<br>    <span class="hljs-meta">#elif defined (SPOT)</span><br>        float4 lightCoord = mul(unity_WorldToLight, float4(i.worldPos, <span class="hljs-number">1</span>));<br>                        <span class="hljs-comment">// 聚光灯的衰减计算，原理待补充</span><br>        fixed atten = (lightCoord.z &gt; <span class="hljs-number">0</span>) * tex2D(_LightTexture0, lightCoord.xy / lightCoord.w + <span class="hljs-number">0.5</span>).w * tex2D(_LightTextureB0, <span class="hljs-built_in">dot</span>(lightCoord, lightCoord).rr).UNITY_ATTEN_CHANNEL;<br>    <span class="hljs-meta">#else</span><br>        fixed atten = <span class="hljs-number">1.0</span>;<br>    <span class="hljs-meta">#endif</span><br><span class="hljs-meta">#endif</span><br><br><span class="hljs-keyword">return</span> fixed4((diffuse + specular) * atten, <span class="hljs-number">1.0</span>);<br>&#125;<br><br>ENDCG<br>&#125;<br>&#125;<br>FallBack &quot;Specular&quot;<br>&#125;<br></code></pre></td></tr></table></figure><p>Unity 绘制屏幕阴影的过程：</p><ul><li>更新摄像机深度纹理</li><li>得到光源的阴影映射纹理</li><li>得到屏幕空间的阴影图</li><li>对阴影图采样并与其他光源混合</li></ul><h3 id="统一管理光照衰减和阴影"><a href="#统一管理光照衰减和阴影" class="headerlink" title="统一管理光照衰减和阴影"></a>统一管理光照衰减和阴影</h3><p>光照衰减和阴影对物体最终的渲染影响本质相同——都是把光照衰减因子和阴影值及光照结果相乘得到最终渲染结果，该过程用代码表示为：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs glsl">fixed4 color = fixed4(ambient + (diffuse + specular) * atten * shadow, <span class="hljs-number">1.0</span>);<br></code></pre></td></tr></table></figure><p>其中光照衰减和阴影的计算可以使用内置的UNITY_LIGHT_ATTENUATION宏实现，该宏接收3个参数：</p><ol><li>atten，该宏会将光照衰减和阴影值相乘的结果存储到该变量中</li><li>结构体v2f</li><li>世界空间的坐标，该参数会用于计算光源空间下的坐标</li></ol><p>使用方法：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-comment">// UNITY_LIGHT_ATTENUATION not only compute attenuation, but also shadow infos</span><br><span class="hljs-comment">// atten被该宏自动生成</span><br>UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);<br></code></pre></td></tr></table></figure><p>如果希望在Additional Pass中添加阴影效果，需要使用<code>#pragma multi_compile_fwdadd_fullshadows</code>编译指令</p><h3 id="透明物体阴影"><a href="#透明物体阴影" class="headerlink" title="透明物体阴影"></a>透明物体阴影</h3><p><strong>让使用透明度测试的物体得到阴影</strong>：把Fallback设置为Transparent&#x2F;Cutout&#x2F;VertexLit</p><p>注意：由于该shader中计算透明度测试时，使用了_Cutoff属性来进行透明度测试，因此我们的Shader中也必须提供名为_Cutoff的属性。</p><p>同时，如果物体背面也会产生阴影，需要将Mesh Renderer组件中的Cast Shadows属性设置为Two Sided，强制Unity计算阴影映射纹理时计算所有面的深度信息</p><p>对于透明度混合的物体添加阴影比较复杂，在Unity中，所有内置的半透明Shader不会产生任何阴影效果。但是可以通过将Fallback设置为VertexLit、Diffuse这些不透明物体使用的Unity Shader来强制生成</p><p><img src="/2021/07/22/UnityShader-%E5%A4%8D%E6%9D%82%E5%85%89%E7%85%A7/alpha_blend_shadow1.png" alt="alpha_blend_shadow1.png-94.9kB"></p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>Shader</tag>
      
      <tag>Lighting</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UnityShader-透明效果</title>
    <link href="/2021/07/17/UnityShader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/"/>
    <url>/2021/07/17/UnityShader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="UnityShader-透明效果"><a href="#UnityShader-透明效果" class="headerlink" title="UnityShader-透明效果"></a>UnityShader-透明效果</h1><p>Unity中通常使用2种方法来实现透明效果：<strong>透明度测试(Alpha Test)<strong>和</strong>透明度混合(Alpha Blending)</strong></p><h2 id="渲染队列-Render-Queue"><a href="#渲染队列-Render-Queue" class="headerlink" title="渲染队列(Render Queue)"></a>渲染队列(Render Queue)</h2><p>Unity使用渲染队列来解决渲染顺序的问题，可以使用SubShader的Queue标签来决定将模型归到哪个渲染队列</p><p><img src="/2021/07/17/UnityShader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/image-20210820164801912.png" alt="image-20210820164801912"></p><h2 id="透明度测试"><a href="#透明度测试" class="headerlink" title="透明度测试"></a>透明度测试</h2><p>只要一个片元的透明度不满足条件（通常是小于某个阈值），那么它对应的片元就会被舍弃</p><p><strong>缺点：</strong>得到的透明效果要么完全透明，要么完全不透明，而且在边缘处往往参差不齐，有锯齿产生</p><p>实现代码：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs glsl">Shader &quot;Alpha Test&quot; &#123;<br>    Properties &#123;<br>        _Color (&quot;Main Tint&quot;, Color) = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>        _MainTex(&quot;Main Tex&quot;, <span class="hljs-number">2</span>D) = &quot;white&quot; &#123;&#125;<br>        <span class="hljs-comment">// 决定调用clip进行透明度测试的判断条件</span><br>        _Cutoff(&quot;Alpha Cutoff&quot;, Range(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) = <span class="hljs-number">0.5</span><br>    &#125;<br><br>    SubShader &#123;<br>        Tags &#123;<br>            <span class="hljs-comment">// 把Shader放入透明度测试队列</span><br>            &quot;Queue&quot; = &quot;AlphaTest&quot;<br>            <span class="hljs-comment">// 该Shader不会受到投影器(Projectors)的影响</span><br>            &quot;IgnoreProjector&quot; = &quot;True&quot;<br>            <span class="hljs-comment">// 把Shader归入到提前定义的组(TransparentCutout组)，指明该Shader是使用了透明度测试的Shader</span><br>            &quot;RenderType&quot; = &quot;TransparentCutout&quot;<br>        &#125;<br><br>        Pass &#123;<br>            Tags &#123;&quot;LightMode&quot; = &quot;ForwardBase&quot;&#125;<br><br>            CGPROGRAM<br><br>            <span class="hljs-meta">#include &quot;Lighting.cginc&quot;</span><br>            <span class="hljs-meta">#pragma vertex vert</span><br>            <span class="hljs-meta">#pragma fragment frag</span><br><br>            fixed4 _Color;<br>            <span class="hljs-type">sampler2D</span> _MainTex;<br>            float4 _MainTex_ST;<br>            fixed _Cutoff;<br><br>            struct a2v &#123;<br>                float4 vertex : POSITION;<br>                float3 normal : NORMAL;<br>                float4 texcoord : TEXCOORD0;<br>            &#125;;<br><br>            struct v2f &#123;<br>                float4 pos : SV_POSITION;<br>                float3 worldNormal : TEXCOORD0;<br>                float3 worldPos : TEXCOORD1;<br>                float2 uv : TEXCOORD2;<br>            &#125;;<br><br>            v2f vert(a2v v) &#123;<br>                v2f o;<br>                o.pos = UnityObjectToClipPos(v.vertex);<br>                o.worldNormal = UnityObjectToWorldNormal(v.normal);<br><br>                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<br>                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);<br><br>                <span class="hljs-keyword">return</span> o;<br>            &#125;<br><br>            fixed4 frag(v2f i) : SV_Target &#123;<br>                <span class="hljs-comment">// 法线经过了插值，所以最好归一化一下</span><br>                fixed3 worldNormal = <span class="hljs-built_in">normalize</span>(i.worldNormal);<br>                fixed3 worldLightDir = <span class="hljs-built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));<br><br>                fixed4 texColor = tex2D(_MainTex, i.uv);<br><br>                <span class="hljs-comment">// Alpha test</span><br>                clip (texColor.a - _Cutoff);<br>                <span class="hljs-comment">// Equal to </span><br>                <span class="hljs-comment">// if ((texColor.a - _Curoff) &lt; 0)</span><br>                <span class="hljs-comment">// discard;</span><br><br>                fixed3 albedo = texColor.rgb * _Color.rgb;<br>                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;<br>                fixed3 diffuse = _LightColor0.rgb * albedo * <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">dot</span>(worldNormal, worldLightDir));<br><br>                <span class="hljs-keyword">return</span> fixed4(ambient + diffuse, <span class="hljs-number">1.0</span>);<br>            &#125;<br>            ENDCG<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 使用内置的Transparent/Cutout/VertexLit来回调Shader，保证该shader无法在显卡上工作时可以由合适的来代替，</span><br>    <span class="hljs-comment">// 也可以保证透明度测试的物体可以正确地向其他物体投射阴影</span><br>    Fallback &quot;Transparent/Cutout/VertexLit&quot;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="透明度混合"><a href="#透明度混合" class="headerlink" title="透明度混合"></a>透明度混合</h2><p>能够得到真正的半透明效果，它会使用当前片元的透明度作为混合因子，与已经存在颜色缓冲中的颜色值进行混合，得到新的颜色。但是，透明度混合需要关闭深度写入（但没有关闭深度测试，依然能够舍弃较远片元），这将由我们自己决定渲染顺序。对于透明度混合来说，深度缓冲是只读的。</p><p><strong>注意，对于不透明物体而言，深度测试和深度检验依然是开启的，该物体依然能够写入颜色缓冲和深度缓冲</strong></p><p>对于半透明物体和不透明物体而言，<strong>应该先渲染不透明物体，再渲染半透明物体</strong></p><p>常用的渲染方法是：</p><ol><li>先渲染所有不透明物体，并开启深度测试和深度写入</li><li>把半透明物体按照距离摄像机的远近进行排序，然后按照从后往前的顺序渲染这些半透明物体，并<strong>开启深度测试</strong>，关闭深度写入。这样深度缓冲中的值都是不透明物体的深度，当透明物体测试深度大于该值，则直接舍弃，否则进行透明混合</li></ol><p>该方法的问题在于，如果物体之间在深度上存在重合像素，则难以确定正确的渲染顺序。比较好的解决方案是：</p><ul><li>尽可能让模型是凸面体</li><li>考虑将复杂的模型拆分成可以独立排序的多个子模型，然后分别对其进行渲染</li><li>使用开启了深度写入的半透明效果来近似模拟物体半透明</li></ul><p>注：对于单个物体而言，由于可以设置多个Pass来分别进行深度处理和颜色处理，因此大多数情况下依然可以方便地获得正确地渲染顺序，但是会增加性能消耗。以上问题对于多物体而言相对更加难以处理。</p><br><h3 id="混合命令"><a href="#混合命令" class="headerlink" title="混合命令"></a>混合命令</h3><p>Unity提供了混合命令Blend来进行混合，该命令在设置混合因子的同时也开启了混合模式，此时片元的透明通道才有意义</p><p><img src="/2021/07/17/UnityShader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/image-20210820165613563.png" alt="image-20210820165613563"></p><p>对于只有两个参数的命令，将使用同样的混合因子来混合RGB通道和A通道（是的，A通道也能够进行混合），该命令相当于实现以下混合公式：<br>$$<br>O_{rgb} &#x3D; SrcFactor \times S_{rgb} + DstFactor \times D_{rgb}<br>$$</p><p>$$<br>O_a &#x3D; SrcFactorA \times S_a + DstFactorA \times D_a<br>$$</p><p>ShaderLab支持的混合因子：</p><p><img src="/2021/07/17/UnityShader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/image-20210820171927516.png" alt="image-20210820171927516"></p><p><strong>混合操作</strong></p><p>使用<code>BlendOp BlendOperation</code>命令来执行混合操作</p><p><img src="/2021/07/17/UnityShader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/image-20210820172354864.png" alt="image-20210820172354864"></p><p><img src="/2021/07/17/UnityShader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/image-20210820172403548.png" alt="image-20210820172403548"></p><h3 id="常见混合类型"><a href="#常见混合类型" class="headerlink" title="常见混合类型"></a>常见混合类型</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-comment">// 正常(Normal), 即透明度混合</span><br>Blend SrcAlpha OneMinusSrcAlpha<br><br><span class="hljs-comment">// 柔和相加(Soft Additive)</span><br>Blend OneMinusDstColor One<br><br><span class="hljs-comment">// 正片叠底(Multiply)，即相乘</span><br>Blend DstColor Zero<br><br><span class="hljs-comment">// 两倍相乘</span><br>Blend DstColor SrcColor<br><br><span class="hljs-comment">// 变暗(Darken)</span><br>BlendOp Min<br>Blend One One<br><br><span class="hljs-comment">// 变亮(Lighten)</span><br>BlendOp Max<br>Blend One One<br><br><span class="hljs-comment">// 滤色(Screen)</span><br>Blend OneMinusDstColor One<br><span class="hljs-comment">// 等同于</span><br><span class="hljs-comment">// Blend One OneMinusSrcColor</span><br><br><span class="hljs-comment">// 线性减淡(Linear Dodge)</span><br>Blend One One<br></code></pre></td></tr></table></figure><p><img src="/2021/07/17/UnityShader-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C/blend.png" alt="blend.png-74.1kB"></p><h3 id="单一半透明效果"><a href="#单一半透明效果" class="headerlink" title="单一半透明效果"></a>单一半透明效果</h3><p>一种半透明Shader的实现代码如下，该Shader的问题在于，当模型本身包含复杂遮挡关系时，可能因为排序错误而产生错误的透明效果</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs glsl">Shader &quot;AABB/Alpha Blend&quot; &#123;<br>    Properties &#123;<br>        _Color (&quot;Main Tint&quot;, Color) = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>        _MainTex(&quot;Main Tex&quot;, <span class="hljs-number">2</span>D) = &quot;white&quot; &#123;&#125;<br>        <span class="hljs-comment">// 在透明纹理的基础上控制整体的透明度</span><br>        _AlphaScale(&quot;Alpha Scale&quot;, Range(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) = <span class="hljs-number">1</span><br>    &#125;<br><br>    SubShader &#123;<br>        Tags &#123;<br>            &quot;Queue&quot; = &quot;Transparent&quot;<br>            &quot;IgnoreProjector&quot; = &quot;True&quot;<br>            &quot;RenderType&quot; = &quot;Transparent&quot;<br>        &#125;<br><br>        Pass &#123;<br>            Tags &#123;&quot;LightMode&quot; = &quot;ForwardBase&quot;&#125;<br><br>            <span class="hljs-comment">// 关闭深度写入</span><br>            ZWrite Off<br>            <span class="hljs-comment">// 将源颜色（该片元着色器产生的颜色）的混合因子设置为SrcAlpha</span><br>            <span class="hljs-comment">// 将目标颜色（已经存在于颜色缓冲取的颜色）的混合因子设置为OneMinusSrcAlpha</span><br>            <span class="hljs-comment">// 该情况下RGB和Alpha通道都使用Alpha混合</span><br>            Blend SrcAlpha OneMinusSrcAlpha<br><br>            <span class="hljs-comment">// 输出的透明度值就是源颜色的透明度</span><br>            <span class="hljs-comment">// Blend SrcAlpha OneMinusSrcAlpha, One Zero</span><br><br>            <span class="hljs-comment">// 用SrcColor的RGB分量来混合RGB，当颜色为黑色时，rgb = 0,代表完全掩盖源颜色</span><br>            <span class="hljs-comment">// 该情况下调整透明度没有意义</span><br>            <span class="hljs-comment">// Blend SrcColor OneMinusSrcColor, One Zero</span><br>            CGPROGRAM<br><br>            <span class="hljs-meta">#include &quot;Lighting.cginc&quot;</span><br>            <span class="hljs-meta">#pragma vertex vert</span><br>            <span class="hljs-meta">#pragma fragment frag</span><br><br>            fixed4 _Color;<br>            <span class="hljs-type">sampler2D</span> _MainTex;<br>            float4 _MainTex_ST;<br>            fixed _AlphaScale;<br><br>            struct a2v &#123;<br>                float4 vertex : POSITION;<br>                float3 normal : NORMAL;<br>                float4 texcoord : TEXCOORD0;<br>            &#125;;<br><br>            struct v2f &#123;<br>                float4 pos : SV_POSITION;<br>                float3 worldNormal : TEXCOORD0;<br>                float3 worldPos : TEXCOORD1;<br>                float2 uv : TEXCOORD2;<br>            &#125;;<br><br>            v2f vert(a2v v) &#123;<br>                v2f o;<br>                o.pos = UnityObjectToClipPos(v.vertex);<br>                o.worldNormal = UnityObjectToWorldNormal(v.normal);<br><br>                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<br>                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);<br><br>                <span class="hljs-keyword">return</span> o;<br>            &#125;<br><br>            fixed4 frag(v2f i) : SV_Target &#123;<br>                <span class="hljs-comment">// 法线经过了插值，所以最好归一化一下</span><br>                fixed3 worldNormal = <span class="hljs-built_in">normalize</span>(i.worldNormal);<br>                fixed3 worldLightDir = <span class="hljs-built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));<br><br>                fixed4 texColor = tex2D(_MainTex, i.uv);<br><br>                fixed3 albedo = texColor.rgb * _Color.rgb;<br><br>                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;<br><br>                fixed3 diffuse = _LightColor0.rgb * albedo * <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">dot</span>(worldNormal, worldLightDir));<br><br>                <span class="hljs-comment">// 只有打开了透明通道才有意义，否则，这些透明度并不会对片元的透明效果由任何影响</span><br>                <span class="hljs-keyword">return</span> fixed4(ambient + diffuse, texColor.a * _AlphaScale);<br>            &#125;<br>            ENDCG<br>        &#125;<br>    &#125;<br>    Fallback &quot;Transparent/VertexLit&quot;<br>&#125;<br></code></pre></td></tr></table></figure><br><h3 id="开启深度写入的半透明效果"><a href="#开启深度写入的半透明效果" class="headerlink" title="开启深度写入的半透明效果"></a>开启深度写入的半透明效果</h3><p>对于单个物体而言，如果不想显示背面的透明效果，并且解决上述Shader产生的错误排序情况，可以<strong>使用两个Pass来渲染模型</strong></p><ol><li>第一个Pass开启深度写入，但是不输出颜色，<strong>只是把模型的深度值写入深度缓冲中</strong></li><li>第二个Pass进行正常的透明度混合，能够按照像素级别的深度排序结果进行透明渲染</li></ol><p>开启深度写入地半透明效果实现如下：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs glsl">Shader &quot;Alpha Blending ZWrite&quot; &#123;<br>    Properties &#123;<br>        _Color (&quot;Main Tint&quot;, Color) = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>        _MainTex(&quot;Main Tex&quot;, <span class="hljs-number">2</span>D) = &quot;white&quot; &#123;&#125;<br>        <span class="hljs-comment">// 在透明纹理的基础上控制整体的透明度</span><br>        _AlphaScale(&quot;Alpha Scale&quot;, Range(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) = <span class="hljs-number">1</span><br>    &#125;<br><br>    SubShader &#123;<br>        Tags &#123;<br>            &quot;Queue&quot; = &quot;Transparent&quot;<br>            &quot;IgnoreProjector&quot; = &quot;True&quot;<br>            &quot;RenderType&quot; = &quot;Transparent&quot;<br>        &#125;<br><br>        <span class="hljs-comment">// Extra pass that renders to depth buffer only</span><br>        Pass &#123;<br>            <span class="hljs-comment">// 开启深度写入，剔除掉模型中被遮挡的片元</span><br>            ZWrite On<br>            <span class="hljs-comment">// Pass不写入任何颜色通道，即不会输出任何颜色</span><br>            ColorMask <span class="hljs-number">0</span><br>        &#125;<br><br>        Pass &#123;<br>            Tags &#123;&quot;LightMode&quot; = &quot;ForwardBase&quot;&#125;<br><br>            <span class="hljs-comment">// 关闭深度写入</span><br>            ZWrite Off<br>            <span class="hljs-comment">// 将源颜色（该片元着色器产生的颜色）的混合因子设置为SrcAlpha</span><br>            <span class="hljs-comment">// 将目标颜色（已经存在于颜色缓冲取的颜色）的混合因子设置为OneMinusSrcAlpha</span><br>            Blend SrcAlpha OneMinusSrcAlpha<br>            CGPROGRAM<br><br>            <span class="hljs-meta">#include &quot;Lighting.cginc&quot;</span><br>            <span class="hljs-meta">#pragma vertex vert</span><br>            <span class="hljs-meta">#pragma fragment frag</span><br><br>            fixed4 _Color;<br>            <span class="hljs-type">sampler2D</span> _MainTex;<br>            float4 _MainTex_ST;<br>            fixed _AlphaScale;<br><br>            struct a2v &#123;<br>                float4 vertex : POSITION;<br>                float3 normal : NORMAL;<br>                float4 texcoord : TEXCOORD0;<br>            &#125;;<br><br>            struct v2f &#123;<br>                float4 pos : SV_POSITION;<br>                float3 worldNormal : TEXCOORD0;<br>                float3 worldPos : TEXCOORD1;<br>                float2 uv : TEXCOORD2;<br>            &#125;;<br><br>            v2f vert(a2v v) &#123;<br>                v2f o;<br>                o.pos = UnityObjectToClipPos(v.vertex);<br>                o.worldNormal = UnityObjectToWorldNormal(v.normal);<br><br>                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<br>                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);<br><br>                <span class="hljs-keyword">return</span> o;<br>            &#125;<br><br>            fixed4 frag(v2f i) : SV_Target &#123;<br>                <span class="hljs-comment">// 法线经过了插值，所以最好归一化一下</span><br>                fixed3 worldNormal = <span class="hljs-built_in">normalize</span>(i.worldNormal);<br>                fixed3 worldLightDir = <span class="hljs-built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));<br><br>                fixed4 texColor = tex2D(_MainTex, i.uv);<br><br>                fixed3 albedo = texColor.rgb * _Color.rgb;<br><br>                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;<br><br>                fixed3 diffuse = _LightColor0.rgb * albedo * <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">dot</span>(worldNormal, worldLightDir));<br><br>                <span class="hljs-comment">// 只有打开了透明通道才有意义，否则，这些透明度并不会对片元的透明效果由任何影响</span><br>                <span class="hljs-keyword">return</span> fixed4(ambient + diffuse, texColor.a * _AlphaScale);<br>            &#125;<br>            ENDCG<br>        &#125;<br>    &#125;<br>    Fallback &quot;Diffuse&quot;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="双面渲染的透明效果"><a href="#双面渲染的透明效果" class="headerlink" title="双面渲染的透明效果"></a>双面渲染的透明效果</h2><p>默认情况下，渲染引擎会剔除物体背面（相对于摄像机方向）的图元，可以使用<code>Cull</code>指令来控制需要剔除哪些面的图元</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs glsl">Cull Back(默认) | Front(剔除正面) | Off(双面渲染)<br></code></pre></td></tr></table></figure><h3 id="透明度测试的双面渲染"><a href="#透明度测试的双面渲染" class="headerlink" title="透明度测试的双面渲染"></a>透明度测试的双面渲染</h3><p>实现代码如下：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs glsl">Shader &quot;Alpha Test Both Sided&quot; &#123;<br>    Properties &#123;<br>        _Color (&quot;Main Tint&quot;, Color) = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>        _MainTex(&quot;Main Tex&quot;, <span class="hljs-number">2</span>D) = &quot;white&quot; &#123;&#125;<br>        <span class="hljs-comment">// 决定调用clip进行透明度测试的判断条件</span><br>        _Cutoff(&quot;Alpha Cutoff&quot;, Range(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) = <span class="hljs-number">0.5</span><br>    &#125;<br><br>    SubShader &#123;<br>        Tags &#123;<br>            &quot;Queue&quot; = &quot;AlphaTest&quot;<br>            &quot;IgnoreProjector&quot; = &quot;True&quot;<br>            &quot;RenderType&quot; = &quot;TransparentCutout&quot;<br>        &#125;<br><br>        Pass &#123;<br>            Tags &#123;&quot;LightMode&quot; = &quot;ForwardBase&quot;&#125;<br><br>            <span class="hljs-comment">// Turn off culling</span><br>            Cull Off<br><br>            CGPROGRAM<br><br>            <span class="hljs-meta">#include &quot;Lighting.cginc&quot;</span><br>            <span class="hljs-meta">#pragma vertex vert</span><br>            <span class="hljs-meta">#pragma fragment frag</span><br><br>            fixed4 _Color;<br>            <span class="hljs-type">sampler2D</span> _MainTex;<br>            float4 _MainTex_ST;<br>            fixed _Cutoff;<br><br>            struct a2v &#123;<br>                float4 vertex : POSITION;<br>                float3 normal : NORMAL;<br>                float4 texcoord : TEXCOORD0;<br>            &#125;;<br><br>            struct v2f &#123;<br>                float4 pos : SV_POSITION;<br>                float3 worldNormal : TEXCOORD0;<br>                float3 worldPos : TEXCOORD1;<br>                float2 uv : TEXCOORD2;<br>            &#125;;<br><br>            v2f vert(a2v v) &#123;<br>                v2f o;<br>                o.pos = UnityObjectToClipPos(v.vertex);<br>                o.worldNormal = UnityObjectToWorldNormal(v.normal);<br><br>                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<br>                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);<br><br>                <span class="hljs-keyword">return</span> o;<br>            &#125;<br><br>            fixed4 frag(v2f i) : SV_Target &#123;<br>                <span class="hljs-comment">// 法线经过了插值，所以最好归一化一下</span><br>                fixed3 worldNormal = <span class="hljs-built_in">normalize</span>(i.worldNormal);<br>                fixed3 worldLightDir = <span class="hljs-built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));<br><br>                fixed4 texColor = tex2D(_MainTex, i.uv);<br><br>                <span class="hljs-comment">// Alpha test</span><br>                clip (texColor.a - _Cutoff);<br>                <span class="hljs-comment">// Equal to </span><br>                <span class="hljs-comment">// if ((texColor.a - _Curoff) &lt; 0)</span><br>                <span class="hljs-comment">// discard;</span><br><br>                fixed3 albedo = texColor.rgb * _Color.rgb;<br>                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;<br>                fixed3 diffuse = _LightColor0.rgb * albedo * <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">dot</span>(worldNormal, worldLightDir));<br><br>                <span class="hljs-keyword">return</span> fixed4(ambient + diffuse, <span class="hljs-number">1.0</span>);<br>            &#125;<br>            ENDCG<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 使用内置的Transparent/Cutout/VertexLit来回调Shader，保证该shader无法在显卡上工作时可以由合适的来代替，</span><br>    <span class="hljs-comment">// 也可以保证透明度测试的物体可以正确地向其他物体投射阴影</span><br>    Fallback &quot;Transparent/Cutout/VertexLit&quot;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="透明度混合的双面渲染"><a href="#透明度混合的双面渲染" class="headerlink" title="透明度混合的双面渲染"></a>透明度混合的双面渲染</h3><p>方法：使用两个Pass，前一个渲染背面，后一个渲染正面</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><code class="hljs glsl">Shader &quot;AABB/Alpha Blend Both Sided&quot; &#123;<br>    Properties &#123;<br>        _Color (&quot;Main Tint&quot;, Color) = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>        _MainTex(&quot;Main Tex&quot;, <span class="hljs-number">2</span>D) = &quot;white&quot; &#123;&#125;<br>        <span class="hljs-comment">// 在透明纹理的基础上控制整体的透明度</span><br>        _AlphaScale(&quot;Alpha Scale&quot;, Range(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) = <span class="hljs-number">1</span><br>    &#125;<br><br>    SubShader &#123;<br>        Tags &#123;<br>            &quot;Queue&quot; = &quot;Transparent&quot;<br>            &quot;IgnoreProjector&quot; = &quot;True&quot;<br>            &quot;RenderType&quot; = &quot;Transparent&quot;<br>        &#125;<br><br>        Pass &#123;<br>            Tags &#123;&quot;LightMode&quot; = &quot;ForwardBase&quot;&#125;<br><br>            <span class="hljs-comment">// First pass renders only back faces</span><br>            Cull Front<br><br>            <span class="hljs-comment">// 关闭深度写入</span><br>            ZWrite Off<br>            <span class="hljs-comment">// 将源颜色（该片元着色器产生的颜色）的混合因子设置为SrcAlpha</span><br>            <span class="hljs-comment">// 将目标颜色（已经存在于颜色缓冲取的颜色）的混合因子设置为OneMinusSrcAlpha</span><br>            <span class="hljs-comment">// 该情况下RGB和Alpha通道都使用Alpha混合</span><br>            Blend SrcAlpha OneMinusSrcAlpha<br><br>            CGPROGRAM<br><br>            <span class="hljs-meta">#include &quot;Lighting.cginc&quot;</span><br>            <span class="hljs-meta">#pragma vertex vert</span><br>            <span class="hljs-meta">#pragma fragment frag</span><br><br>            fixed4 _Color;<br>            <span class="hljs-type">sampler2D</span> _MainTex;<br>            float4 _MainTex_ST;<br>            fixed _AlphaScale;<br><br>            struct a2v &#123;<br>                float4 vertex : POSITION;<br>                float3 normal : NORMAL;<br>                float4 texcoord : TEXCOORD0;<br>            &#125;;<br><br>            struct v2f &#123;<br>                float4 pos : SV_POSITION;<br>                float3 worldNormal : TEXCOORD0;<br>                float3 worldPos : TEXCOORD1;<br>                float2 uv : TEXCOORD2;<br>            &#125;;<br><br>            v2f vert(a2v v) &#123;<br>                v2f o;<br>                o.pos = UnityObjectToClipPos(v.vertex);<br>                o.worldNormal = UnityObjectToWorldNormal(v.normal);<br><br>                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<br>                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);<br><br>                <span class="hljs-keyword">return</span> o;<br>            &#125;<br><br>            fixed4 frag(v2f i) : SV_Target &#123;<br>                <span class="hljs-comment">// 法线经过了插值，所以最好归一化一下</span><br>                fixed3 worldNormal = <span class="hljs-built_in">normalize</span>(i.worldNormal);<br>                fixed3 worldLightDir = <span class="hljs-built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));<br><br>                fixed4 texColor = tex2D(_MainTex, i.uv);<br><br>                fixed3 albedo = texColor.rgb * _Color.rgb;<br><br>                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;<br><br>                fixed3 diffuse = _LightColor0.rgb * albedo * <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">dot</span>(worldNormal, worldLightDir));<br><br>                <span class="hljs-comment">// 只有打开了透明通道才有意义，否则，这些透明度并不会对片元的透明效果由任何影响</span><br>                <span class="hljs-keyword">return</span> fixed4(ambient + diffuse, texColor.a * _AlphaScale);<br>            &#125;<br>            ENDCG<br>        &#125;<br><br>        Pass &#123;<br>            Tags &#123;&quot;LightMode&quot; = &quot;ForwardBase&quot;&#125;<br><br>            <span class="hljs-comment">// Second pass renders only front faces</span><br>            Cull Back<br><br>            <span class="hljs-comment">// 关闭深度写入</span><br>            ZWrite Off<br>            <span class="hljs-comment">// 将源颜色（该片元着色器产生的颜色）的混合因子设置为SrcAlpha</span><br>            <span class="hljs-comment">// 将目标颜色（已经存在于颜色缓冲取的颜色）的混合因子设置为OneMinusSrcAlpha</span><br>            <span class="hljs-comment">// 该情况下RGB和Alpha通道都使用Alpha混合</span><br>            Blend SrcAlpha OneMinusSrcAlpha<br><br>            CGPROGRAM<br><br>            <span class="hljs-meta">#include &quot;Lighting.cginc&quot;</span><br>            <span class="hljs-meta">#pragma vertex vert</span><br>            <span class="hljs-meta">#pragma fragment frag</span><br><br>            fixed4 _Color;<br>            <span class="hljs-type">sampler2D</span> _MainTex;<br>            float4 _MainTex_ST;<br>            fixed _AlphaScale;<br><br>            struct a2v &#123;<br>                float4 vertex : POSITION;<br>                float3 normal : NORMAL;<br>                float4 texcoord : TEXCOORD0;<br>            &#125;;<br><br>            struct v2f &#123;<br>                float4 pos : SV_POSITION;<br>                float3 worldNormal : TEXCOORD0;<br>                float3 worldPos : TEXCOORD1;<br>                float2 uv : TEXCOORD2;<br>            &#125;;<br><br>            v2f vert(a2v v) &#123;<br>                v2f o;<br>                o.pos = UnityObjectToClipPos(v.vertex);<br>                o.worldNormal = UnityObjectToWorldNormal(v.normal);<br><br>                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<br>                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);<br><br>                <span class="hljs-keyword">return</span> o;<br>            &#125;<br><br>            fixed4 frag(v2f i) : SV_Target &#123;<br>                <span class="hljs-comment">// 法线经过了插值，所以最好归一化一下</span><br>                fixed3 worldNormal = <span class="hljs-built_in">normalize</span>(i.worldNormal);<br>                fixed3 worldLightDir = <span class="hljs-built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));<br><br>                fixed4 texColor = tex2D(_MainTex, i.uv);<br><br>                fixed3 albedo = texColor.rgb * _Color.rgb;<br><br>                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;<br><br>                fixed3 diffuse = _LightColor0.rgb * albedo * <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">dot</span>(worldNormal, worldLightDir));<br><br>                <span class="hljs-comment">// 只有打开了透明通道才有意义，否则，这些透明度并不会对片元的透明效果由任何影响</span><br>                <span class="hljs-keyword">return</span> fixed4(ambient + diffuse, texColor.a * _AlphaScale);<br>            &#125;<br>            ENDCG<br>        &#125;<br>    &#125;<br>    Fallback &quot;Transparent/VertexLit&quot;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>Shader</tag>
      
      <tag>Lighting</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UnityShader-基础纹理</title>
    <link href="/2021/07/15/UnityShader-%E5%9F%BA%E7%A1%80%E7%BA%B9%E7%90%86/"/>
    <url>/2021/07/15/UnityShader-%E5%9F%BA%E7%A1%80%E7%BA%B9%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="UnityShader-基础纹理"><a href="#UnityShader-基础纹理" class="headerlink" title="UnityShader-基础纹理"></a>UnityShader-基础纹理</h1><p>纹理映射(texture mapping)：使用一张图片来控制模型外观</p><p>纹理映射坐标(texture-mapping)：定义了该顶点在纹理中对应的2D坐标，通常使用二维变量(u, v)表示，也被称为UV坐标，范围被归一化到[0, 1]</p><p>纹理采样时使用的纹理坐标不一定在[0, 1]范围内，会根据平铺模式决定如何采样</p><p>在Unity中，纹理空间符合OpenGL传统，原点位于纹理左下角</p><p>纹理的处理过程可以用以下图片内容描述：</p><p><img src="/2021/07/15/UnityShader-%E5%9F%BA%E7%A1%80%E7%BA%B9%E7%90%86/image-20210823153409761.png" alt="image-20210823153409761"></p><ul><li><p>在应用阶段，物体上每个顶点的纹理坐标就已经被计算出来，并伴随顶点位置信息一齐传递给几何阶段</p></li><li><p>在几何阶段，纹理坐标会经过平铺和位移变换，生成所谓的UV坐标，这时利用UV坐标可以计算出该顶点采样的像素值，算法类似于插值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> PIXEL <span class="hljs-title function_">GetTargetPixelWithUV</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PIXEL</span> <span class="hljs-title">pixels</span>[<span class="hljs-title">HORIZONTAL_AMOUNT_OF_PIXELS</span>][<span class="hljs-title">VERTICAL_AMOUNT_OF_PIXELS</span>];</span><br>    <span class="hljs-type">int</span> row = Lerp(<span class="hljs-number">0</span>, HORIZONTAL_AMOUNT_OF_PIXELS, uv.x);<br>    <span class="hljs-type">int</span> col = Lerp(<span class="hljs-number">0</span>, VERTICAL_AMOUNT_OF_PIXELS, uv.y);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PIXEL</span> <span class="hljs-title">target</span> =</span> pixels[row][col];<br>    <span class="hljs-keyword">return</span> target;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="单张纹理"><a href="#单张纹理" class="headerlink" title="单张纹理"></a>单张纹理</h2><p>Shader实现：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-comment">// Upgrade <span class="hljs-doctag">NOTE:</span> replaced &#x27;_Object2World&#x27; with &#x27;unity_ObjectToWorld&#x27;</span><br><br>Shader &quot;AABB/Single Texture&quot; &#123;<br>    Properties &#123;<br>        _Color (&quot;Color Tint&quot;, Color) = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>        _MainTex (&quot;Main Tex&quot;, <span class="hljs-number">2</span>D) = &quot;white&quot; &#123;&#125;<br>        _Specular (&quot;Specular&quot;, Color) = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>        _Gloss (&quot;Gloss&quot;, Range(<span class="hljs-number">8.0</span>, <span class="hljs-number">256</span>)) = <span class="hljs-number">20</span><br>    &#125;<br>    SubShader &#123;<br>        Pass &#123;<br>            Tags &#123; &quot;LightMode&quot; = &quot;ForwardBase&quot; &#125;<br><br>            CGPROGRAM<br><br>            <span class="hljs-meta">#include &quot;UnityCG.cginc&quot;</span><br>            <span class="hljs-meta">#include &quot;Lighting.cginc&quot;</span><br>            <span class="hljs-meta">#pragma vertex vert</span><br>            <span class="hljs-meta">#pragma fragment frag</span><br><br>            fixed4 _Color;<br>            <span class="hljs-type">sampler2D</span> _MainTex;<br>            <span class="hljs-comment">// 声明纹理的某个属性：纹理名_ST, S: scale T: translation</span><br>            <span class="hljs-comment">// _MainTex_ST.xy 存储缩放值， .zw存放偏移值</span><br>            float4 _MainTex_ST;<br>            fixed4 _Specular;<br>            <span class="hljs-type">float</span> _Gloss;<br><br>            struct a2v &#123;<br>                float4 vertex : POSITION;<br>                float3 normal : NORMAL;<br>                float4 texcoord : TEXCOORD0;<br>            &#125;;<br><br>            struct v2f &#123;<br>                float4 pos : SV_POSITION;<br>                float3 worldNormal : TEXCOORD0;<br>                float3 worldPos : TEXCOORD1;<br>                float2 uv : TEXCOORD2;<br>            &#125;;<br><br>            v2f vert(a2v v) &#123;<br>                v2f o;<br>                o.pos = UnityObjectToClipPos(v.vertex);<br>                o.worldNormal = UnityObjectToWorldNormal(v.normal);<br>                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<br><br>                <span class="hljs-comment">//o.uv = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;</span><br>                <span class="hljs-comment">// built-in function</span><br>                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);<br><br>                <span class="hljs-keyword">return</span> o;<br>            &#125;<br><br>            fixed4 frag(v2f i): SV_Target &#123;<br>                fixed3 worldNormal = <span class="hljs-built_in">normalize</span>(i.worldNormal);<br>                fixed3 worldLightDir = <span class="hljs-built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));<br><br>                <span class="hljs-comment">// 使用CG的tex2D函数进行采样，第一个参数是需要采样的纹理。第二个参数是纹理坐标，返回计算得到的纹素（纹理像素）值</span><br>                <span class="hljs-comment">// 使用采样结果和_Color的乘积作为材质的反射率</span><br>                fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb;<br><br>                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;<br><br>                fixed3 diffuse = _LightColor0.rgb * albedo * saturate(<span class="hljs-built_in">dot</span>(worldNormal, worldLightDir));<br><br>                <span class="hljs-comment">// fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);</span><br>                <span class="hljs-comment">// 输入为世界空间中的顶点位置</span><br>                fixed3 viewDir = <span class="hljs-built_in">normalize</span>(UnityWorldSpaceViewDir(i.worldPos));<br><br>                <span class="hljs-comment">// Vec_h = (Vec3_view + Vec3_light) / (length(Vec3_view + Vec3_light))</span><br>                fixed3 halfDir = <span class="hljs-built_in">normalize</span>(worldLightDir + viewDir);<br><br>                <span class="hljs-comment">// C_specular = (C_light * m_specular) * (max(0, dot(Vec3_normal * Vec3_h)))**m_gloss</span><br>                fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="hljs-built_in">pow</span>(<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">dot</span>(worldNormal, halfDir)), _Gloss);<br><br>                <span class="hljs-keyword">return</span> fixed4(ambient + diffuse + specular, <span class="hljs-number">1.0</span>);<br>            &#125;<br>            ENDCG<br>        &#125;<br>    &#125;<br><br>    Fallback &quot;Specular&quot;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>纹理的属性设置：</strong></p><p><img src="/2021/07/15/UnityShader-%E5%9F%BA%E7%A1%80%E7%BA%B9%E7%90%86/texture_properties.png" alt="texture_properties.png-29kB"></p><ul><li>Alpha from Grayscale：勾选后，透明通道的值将会由每个像素的灰度值生成</li><li>Wrap Mode：决定纹理坐标超过[0, 1]后将会如何被平铺。有两种模式：<ul><li>Repeat：如果纹理坐标超过1，则整数部分被舍弃，直接使用小数部分进行采样，结果是纹理不断重复</li><li>Clamp：如果纹理大于1，则被截取到1，如果小于0，则被截取到0</li></ul></li><li>Filter Mode：决定纹理由于变换而产生拉伸时将会采用哪种滤波模式。支持3种模式：Point, Bilinear, Trilinear。得到的图片滤波效果依次提升，但是耗费的性能也会增加<ul><li>Point：使用最近邻(nearest neighbor)滤波，在放大或者缩小时，采样像素数目只有一个</li><li>Bilinear：线性滤波，会找到4个邻近像素进行插值混合，<strong>通常选择该模式</strong></li><li>Trilinear：会在多级渐远纹理之间进行混合，单张纹理下和Bilinear效果相同</li></ul></li></ul><p><strong>多级渐进纹理(mipmapping)：</strong>将原纹理提前用滤波处理来得到很多更小的图像，得到多层较小纹理，当物体远离摄像机时，直接使用较小纹理进行计算。在Unity中通过勾选Generate Mip Maps来实现</p><blockquote><p>注：这里我的理解是，假设原来拥有128x128大小的纹理和平面，两者刚好贴合，当平面因为远离摄像机而面积变小后（经过了透视除法，x, y,z的坐标值被除以w），经过屏幕映射而包围的像素数目减少，假设为64x64像素大小，此时采集128x128大小的纹理时，中间会间隔一个像素无法被采集到，因此容易出现马赛克或者锯齿，丢失细节（在LearnOpenGL中说还会导致内存浪费，我暂时不能理解），因此我们可以提前将纹理以合适的方式处理好（而不一定是默认插值方式），并生成对应的小纹理，这样采样时就能够控制细节。</p></blockquote><p>纹理最大尺寸(Max Size)：如果导入纹理超过设置的最大尺寸，则会将纹理缩放为该最大分辨率。导入纹理大小最好时2的幂，有利于存储</p><p>纹理模式(Format)：影响纹理的精度和占用内存</p><h2 id="凹凸映射-bump-mapping"><a href="#凹凸映射-bump-mapping" class="headerlink" title="凹凸映射(bump mapping)"></a>凹凸映射(bump mapping)</h2><p>目的：使用一张纹理来修改模型表面的法线，以提供更多的细节，让模型看起来凹凸不平</p><p>主要实现方法分为高度纹理(height map)和法线纹理(normal map)</p><h3 id="高度纹理"><a href="#高度纹理" class="headerlink" title="高度纹理"></a>高度纹理</h3><p>高度纹理使用一张高度图来实现凹凸映射，高度图中存储强度值，用于表示模型表面局部的海拔高度</p><p>缺点：计算复杂，不能直接得到表面法线，需要由灰度值计算获得</p><h3 id="法线纹理"><a href="#法线纹理" class="headerlink" title="法线纹理"></a>法线纹理</h3><p>存储表面的法线方向，法线和像素之间的映射关系为：<br>$$<br>pixel &#x3D; \frac{normal + 1}{2}<br>$$<br>法线纹理按照坐标系的不同分为**模型空间下的法线纹理(object-space normal map)<strong>和</strong>切线空间下的法线纹理(tangent-space normal map)**。一般选择后者，因为切线空间下的法线纹理记录的是相对法线信息，能够适应完全不同的网格。</p><p><strong>切线空间：</strong></p><p>原点为顶点，z轴是顶点的法线方向，x轴是切线方向，y轴是副切线方向</p><p><strong>在切线空间下计算：</strong></p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs glsl">Shader &quot;Normal Map In Tangent Space&quot; &#123;<br>    Properties &#123;<br>        _Color(&quot;Color Tint&quot;, Color) = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>        _MainTex(&quot;Main Tex&quot;, <span class="hljs-number">2</span>D) = &quot;white&quot; &#123;&#125;<br>        <span class="hljs-comment">// bump: Unity内置的法线纹理,当没有提供任何法线纹理时。&quot;bump&quot;对应模型自带的法线信息</span><br>        _BumpMap(&quot;Normal Map&quot;, <span class="hljs-number">2</span>D) = &quot;bump&quot; &#123;&#125;<br>        <span class="hljs-comment">// 控制凹凸程度，为0时。法线纹理不会对光照产生任何影响</span><br>        _BumpScale(&quot;Bump Scale&quot;, Float) = <span class="hljs-number">1.0</span><br>        _Specular(&quot;Specular&quot;, Color) = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>        _Gloss(&quot;Gloss&quot;, Range(<span class="hljs-number">8.0</span>, <span class="hljs-number">256</span>)) = <span class="hljs-number">20.0</span><br>    &#125;<br><br>    SubShader &#123;<br>        Pass &#123;<br>            Tags &#123; &quot;LightMode&quot; = &quot;ForwardBase&quot; &#125;<br><br>            CGPROGRAM<br>            <span class="hljs-meta">#include &quot;Lighting.cginc&quot;</span><br>            <span class="hljs-meta">#pragma vertex vert</span><br>            <span class="hljs-meta">#pragma fragment frag</span><br><br>            fixed4 _Color;<br>            <span class="hljs-type">sampler2D</span> _MainTex;<br>            float4 _MainTex_ST;<br>            <span class="hljs-type">sampler2D</span> _BumpMap;<br>            float4 _BumpMap_ST;<br>            <span class="hljs-type">float</span> _BumpScale;<br>            fixed4 _Specular;<br>            <span class="hljs-type">float</span> _Gloss;<br><br>            struct a2v &#123;<br>                float4 vertex : POSITION;<br>                float3 normal : NORMAL;<br>                <span class="hljs-comment">// tangent的xyz分量存放切线向量，而w分量决定副切线的方向性</span><br>                float4 tangent : TANGENT;<br>                float4 texcoord : TEXCOORD0;<br>            &#125;;<br><br>            struct v2f &#123;<br>                float4 pos : SV_POSITION;<br>                float4 uv : TEXCOORD0;<br>                float3 lightDir : TEXCOORD1;<br>                float3 viewDir :  TEXCOORD2;<br>            &#125;;<br><br>            v2f vert(a2v v) &#123;<br>                v2f o;<br>                o.pos = UnityObjectToClipPos(v.vertex);<br>                <span class="hljs-comment">// 存储纹理坐标</span><br>                o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;<br>                <span class="hljs-comment">// 存储法线纹理坐标</span><br>                o.uv.zw = v.texcoord.xy * _BumpMap_ST.xy + _BumpMap_ST.zw;<br><br>                <span class="hljs-comment">// float3 binormal = cross(normalize(v.normal), normalize(v.tangent.xyz)) * v.tangent.w;</span><br>                <span class="hljs-comment">// Construct a matrix which transform vectors from object space to tangent space</span><br>                <span class="hljs-comment">// float3x3 rotation = float3x3(v.tangent.xyz, binormal, v.normal);</span><br>                <span class="hljs-comment">// Or just use the built-in macro</span><br>                TANGENT_SPACE_ROTATION;<br><br>                <span class="hljs-comment">// Transform the light direction from object space to tangent space</span><br>                o.lightDir = mul(rotation, ObjSpaceLightDir(v.vertex)).xyz;<br>                <span class="hljs-comment">// Transform the view direction from object space to tangent space</span><br>                o.viewDir = mul(rotation, ObjSpaceViewDir(v.vertex)).xyz;<br><br>                <span class="hljs-keyword">return</span> o;<br>            &#125;<br><br>            fixed4 frag(v2f i): SV_Target &#123;<br>                fixed3 tangentLightDir = <span class="hljs-built_in">normalize</span>(i.lightDir);<br>                fixed3 tangentViewDir = <span class="hljs-built_in">normalize</span>(i.viewDir);<br><br>                <span class="hljs-comment">// Get the texel in the normal map</span><br>                fixed4 packedNormal = tex2D(_BumpMap, i.uv.zw);<br>                fixed3 tangentNormal;<br><br>                <span class="hljs-comment">// If the texture is not marked as &quot;Normal map&quot;</span><br>                <span class="hljs-comment">// tangentNormal.xy = (packedNormal.xy * 2 - 1) * _BumpScale;</span><br>                <span class="hljs-comment">// tangentNormal.z = sqrt(1.0 - saturate(dot(tangentNormal.xy, tangentNormal.xy)));</span><br><br>                <span class="hljs-comment">// Or mark the texture as &quot;Normal map&quot;, and use the built-in function</span><br>                <span class="hljs-comment">// Unity会根据不同平台选择压缩算法，因此使用内置函数获得切线向量会更加安全</span><br>                tangentNormal = UnpackNormal(packedNormal);<br>                tangentNormal.xy *= _BumpScale;<br>                <span class="hljs-comment">// 当_BumpScale越大时，xy的值也就越大，计算出的z值越小，凹凸程度越大</span><br>                <span class="hljs-comment">// 注意到，当tangentNormal.xy为0时，法线方向就为(0, 0, 1)，即默认的法线方向，没有用到凹凸纹理</span><br>                tangentNormal.z = <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">1.0</span> - saturate(<span class="hljs-built_in">dot</span>(tangentNormal.xy, tangentNormal.xy)));<br><br>                <span class="hljs-comment">// 使用CG的tex2D函数进行采样，第一个参数是需要采样的纹理。第二个参数是纹理坐标，返回计算得到的纹素（纹理像素）值</span><br>                <span class="hljs-comment">// 此过程类似于映射，即该片段对应的uv的值被映射到纹理图片的某个像素上，然后对该像素进行采样作为需求的颜色值</span><br>                <span class="hljs-comment">// 使用采样结果和_Color的乘积作为材质的反射率</span><br>                fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb;<br><br>                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;<br><br>                fixed3 diffuse = _LightColor0.rgb * albedo * saturate(<span class="hljs-built_in">dot</span>(tangentNormal, tangentLightDir));<br><br>                <span class="hljs-comment">// Vec_h = (Vec3_view + Vec3_light) / (length(Vec3_view + Vec3_light))</span><br>                fixed3 halfDir = <span class="hljs-built_in">normalize</span>(tangentLightDir + tangentViewDir);<br><br>                <span class="hljs-comment">// C_specular = (C_light * m_specular) * (max(0, dot(Vec3_normal * Vec3_h)))**m_gloss</span><br>                fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="hljs-built_in">pow</span>(<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">dot</span>(tangentNormal, halfDir)), _Gloss);<br><br>                <span class="hljs-keyword">return</span> fixed4(ambient + diffuse + specular, <span class="hljs-number">1.0</span>);<br>            &#125;<br>            ENDCG<br><br>        &#125;<br>    &#125;<br>    Fallback &quot;Specular&quot;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>在世界空间下计算：</strong></p><p>基本思想：在顶点着色器中计算从切线空间到世界空间的变换矩阵，并把它传递给片元着色器。变换矩阵的计算可以由切线空间的标准基在世界空间下的表示得到</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs glsl">Shader &quot;Normal Map In World Space&quot; &#123;<br>    Properties &#123;<br>        _Color(&quot;Color Tint&quot;, Color) = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>        _MainTex(&quot;Main Tex&quot;, <span class="hljs-number">2</span>D) = &quot;white&quot; &#123;&#125;<br>        <span class="hljs-comment">// bump: Unity内置的法线纹理,当没有提供任何法线纹理时。&quot;bump&quot;对应模型自带的法线信息</span><br>        _BumpMap(&quot;Normal Map&quot;, <span class="hljs-number">2</span>D) = &quot;bump&quot; &#123;&#125;<br>        <span class="hljs-comment">// 控制凹凸程度，为0时。法线纹理不会对光照产生任何影响</span><br>        _BumpScale(&quot;Bump Scale&quot;, Float) = <span class="hljs-number">1.0</span><br>        _Specular(&quot;Specular&quot;, Color) = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>        _Gloss(&quot;Gloss&quot;, Range(<span class="hljs-number">8.0</span>, <span class="hljs-number">256</span>)) = <span class="hljs-number">20.0</span><br>    &#125;<br><br>    SubShader &#123;<br>        Pass &#123;<br>            Tags &#123; &quot;LightMode&quot; = &quot;ForwardBase&quot; &#125;<br><br>            CGPROGRAM<br>            <span class="hljs-meta">#include &quot;Lighting.cginc&quot;</span><br>            <span class="hljs-meta">#pragma vertex vert</span><br>            <span class="hljs-meta">#pragma fragment frag</span><br><br>            fixed4 _Color;<br>            <span class="hljs-type">sampler2D</span> _MainTex;<br>            float4 _MainTex_ST;<br>            <span class="hljs-type">sampler2D</span> _BumpMap;<br>            float4 _BumpMap_ST;<br>            <span class="hljs-type">float</span> _BumpScale;<br>            fixed4 _Specular;<br>            <span class="hljs-type">float</span> _Gloss;<br><br>            struct a2v &#123;<br>                float4 vertex : POSITION;<br>                float3 normal : NORMAL;<br>                float4 tangent : TANGENT;<br>                float4 texcoord : TEXCOORD0;<br>            &#125;;<br><br>            struct v2f &#123;<br>                float4 pos : SV_POSITION;<br>                float4 uv : TEXCOORD0;<br>                <span class="hljs-comment">// 目标：存储从切线空间到世界空间的变换矩阵，用于对法线贴图中的法线进行变换</span><br>                <span class="hljs-comment">// 该矩阵由切线空间的坐标轴组成，即x：切线，y：副切线，z：法线</span><br>                float4 TtoW0 : TEXCOORD1;<br>                float4 TtoW1 : TEXCOORD2;<br>                float4 TtoW2 : TEXCOORD3;<br>            &#125;;<br><br>            v2f vert(a2v v) &#123;<br>                v2f o;<br>                o.pos = UnityObjectToClipPos(v.vertex);<br>                <span class="hljs-comment">// 存储纹理坐标</span><br>                o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;<br>                <span class="hljs-comment">// 存储法线纹理坐标</span><br>                o.uv.zw = v.texcoord.xy * _BumpMap_ST.xy + _BumpMap_ST.zw;<br><br>                float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<br>                fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);<br>                fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);<br>                fixed3 worldBinormal = <span class="hljs-built_in">cross</span>(worldNormal, worldTangent) * v.tangent.w;<br><br>                <span class="hljs-comment">// Compute the matrix that transform directions from tangent space to world space</span><br>                <span class="hljs-comment">// Put the world position in w component for optimization</span><br>                o.TtoW0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);<br>                o.TtoW1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);<br>                o.TtoW2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);<br><br>                <span class="hljs-keyword">return</span> o;<br>            &#125;<br><br>            fixed4 frag(v2f i): SV_Target &#123;<br><span class="hljs-comment">// Get the position in world space</span><br>float3 worldPos = float3(i.TtoW0.w, i.TtoW1.w, i.TtoW2.w);<br><span class="hljs-comment">// Compute the light and view dir in world space</span><br>fixed3 lightDir = <span class="hljs-built_in">normalize</span>(UnityWorldSpaceLightDir(worldPos));<br>fixed3 viewDir = <span class="hljs-built_in">normalize</span>(UnityWorldSpaceViewDir(worldPos));<br><br><span class="hljs-comment">// Get the normal in tangent space</span><br>fixed3 bump = UnpackNormal(tex2D(_BumpMap, i.uv.zw));<br>bump.xy *= _BumpScale;<br>bump.z = <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">1.0</span> - saturate(<span class="hljs-built_in">dot</span>(bump.xy, bump.xy)));<br><span class="hljs-comment">// Transform the narmal from tangent space to world space</span><br>bump = <span class="hljs-built_in">normalize</span>(half3(<span class="hljs-built_in">dot</span>(i.TtoW0.xyz, bump), <span class="hljs-built_in">dot</span>(i.TtoW1.xyz, bump), <span class="hljs-built_in">dot</span>(i.TtoW2.xyz, bump)));<br><br>fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb;<br><br>fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;<br><br>fixed3 diffuse = _LightColor0.rgb * albedo * <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">dot</span>(bump, lightDir));<br><br>fixed3 halfDir = <span class="hljs-built_in">normalize</span>(lightDir + viewDir);<br>fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="hljs-built_in">pow</span>(<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">dot</span>(bump, halfDir)), _Gloss);<br><br><span class="hljs-keyword">return</span> fixed4(ambient + diffuse + specular, <span class="hljs-number">1.0</span>);<br>            &#125;<br>            ENDCG<br><br>        &#125;<br>    &#125;<br>    Fallback &quot;Specular&quot;<br>&#125;<br></code></pre></td></tr></table></figure><p>关于Unity对Normal map类型纹理的压缩问题：</p><p>Unity在某些平台上使用了DXT5nm的压缩格式，因此需要针对这种格式进行解码，在DXT5nm格式的法线纹理中，纹素的a通道对应法线的x分量，g通道对应法线的y分量，r和b通道被舍弃，<strong>法线的z分量由xy推导而得</strong>，这样可以减少法线纹理占用的内存空间</p><p>Create from Grayscale：用于从高度图中生成法线纹理，设置后可以调整Bumpiness和Filtering来控制凹凸程度和计算方式</p><h2 id="渐变纹理-ramp-texture"><a href="#渐变纹理-ramp-texture" class="headerlink" title="渐变纹理(ramp texture)"></a>渐变纹理(ramp texture)</h2><p>可以用于控制漫反射光照效果，生成类似于卡通风格的图像</p><p>实现代码：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs glsl">Shader &quot;Ramp Texture&quot; &#123;<br>    Properties &#123;<br>        _Color(&quot;Color Tint&quot;, Color) = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>        _RampTex(&quot;Ramp Tex&quot;, <span class="hljs-number">2</span>D) = &quot;white&quot; &#123;&#125;<br>        _Specular(&quot;Specular&quot;, Color) = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>        _Gloss(&quot;Gloss&quot;, Range(<span class="hljs-number">8.0</span>, <span class="hljs-number">256</span>)) = <span class="hljs-number">20</span><br>    &#125;<br><br>    SubShader &#123;<br>        Pass &#123;<br>            Tags &#123; &quot;LightMode&quot; = &quot;ForwardBase&quot; &#125;<br><br>            CGPROGRAM<br><br>            <span class="hljs-meta">#include &quot;Lighting.cginc&quot;</span><br>            <span class="hljs-meta">#pragma vertex vert</span><br>            <span class="hljs-meta">#pragma fragment frag</span><br><br>            fixed4 _Color;<br>            <span class="hljs-type">sampler2D</span> _RampTex;<br>            float4 _RampTex_ST;<br>            fixed4 _Specular;<br>            <span class="hljs-type">float</span> _Gloss;<br><br>            struct a2v &#123;<br>                float4 vertex : POSITION;<br>                float3 normal : NORMAL;<br>                float4 texcoord : TEXCOORD0;<br>            &#125;;<br><br>            struct v2f &#123;<br>                float4 pos : SV_POSITION;<br>                float3 worldNormal : TEXCOORD0;<br>                float3 worldPos: TEXCOORD1;<br>                float2 uv : TEXCOORD2;<br>            &#125;;<br><br>            v2f vert(a2v v) <br>            &#123;<br>                v2f o;<br><br>                o.pos = UnityObjectToClipPos(v.vertex);<br><br>                o.worldNormal = UnityObjectToWorldNormal(v.normal);<br><br>                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<br><br>                o.uv = TRANSFORM_TEX(v.texcoord, _RampTex);<br><br>                <span class="hljs-keyword">return</span> o;<br>            &#125;<br><br>            fixed4 frag(v2f i) : SV_Target &#123;<br>                fixed3 worldNormal = <span class="hljs-built_in">normalize</span>(i.worldNormal);<br>                fixed3 worldLightDir = <span class="hljs-built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));<br><br>                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;<br><br>                <span class="hljs-comment">// Use the texture to sample the diffuse color</span><br>                fixed halfLambert = <span class="hljs-number">0.5</span> * <span class="hljs-built_in">dot</span>(worldNormal, worldLightDir) + <span class="hljs-number">0.5</span>;<br><br>                <span class="hljs-comment">// 将该片段的halfLambert(0~1)对应的值映射到纹理图片上，获得一个像素值</span><br>                <span class="hljs-comment">// 由于_RampTex为一维纹理，颜色从左到右分段加深，因此漫反射弱(halfLambert小)的地方采样颜色深，</span><br>                <span class="hljs-comment">// 漫反射强(halfLambert大)的地方采样颜色浅，因此形成视觉上的渐变纹理</span><br>                fixed3 diffuseColor = tex2D(_RampTex, fixed2(halfLambert, halfLambert)).rgb * _Color.rgb;<br><br>                fixed3 diffuse = _LightColor0.rgb * diffuseColor;<br><br>                fixed3 viewDir = <span class="hljs-built_in">normalize</span>(UnityWorldSpaceViewDir(i.worldPos));<br><br>                fixed3 halfDir = <span class="hljs-built_in">normalize</span>(worldLightDir + viewDir);<br><br>                fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="hljs-built_in">pow</span>(<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">dot</span>(worldNormal, halfDir)), _Gloss);<br><br>                <span class="hljs-keyword">return</span> fixed4(ambient + diffuse + specular, <span class="hljs-number">1.0</span>);<br>            &#125;<br>            ENDCG <br>        &#125;<br>    &#125;<br>    Fallback &quot;Specular&quot;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是，我们需要把渐变纹理的Wrap Mode设置成Clamp模式，以防止对纹理进行采样时由于浮点数精度造成的问题</p><h2 id="遮罩纹理-mask-texture"><a href="#遮罩纹理-mask-texture" class="headerlink" title="遮罩纹理(mask texture)"></a>遮罩纹理(mask texture)</h2><p>遮罩允许我们可以保护某些区域，使它们免于某些修改。</p><ul><li>用于控制某些区域的反光强度，得到更加细腻的效果</li><li>控制多种纹理的混合</li></ul><p>流程：通过采样得到遮罩纹理的纹素值，然后使用其中某个（或某几个）通道的值来于某种表面属性相乘，可以保证像素级别地控制模型表面的各种性质</p><p>实现代码：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs glsl">Shader &quot;Mask Texture&quot; &#123;<br>Properties &#123;<br>_Color (&quot;Color Tint&quot;, Color) = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>_MainTex (&quot;Main Tex&quot;, <span class="hljs-number">2</span>D) = &quot;white&quot; &#123;&#125;<br>_BumpMap (&quot;Normal Map&quot;, <span class="hljs-number">2</span>D) = &quot;bump&quot; &#123;&#125;<br>_BumpScale(&quot;Bump Scale&quot;, Float) = <span class="hljs-number">1.0</span><br>_SpecularMask (&quot;Specular Mask&quot;, <span class="hljs-number">2</span>D) = &quot;white&quot; &#123;&#125;<br>_SpecularScale (&quot;Specular Scale&quot;, Float) = <span class="hljs-number">1.0</span><br>_Specular (&quot;Specular&quot;, Color) = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>_Gloss (&quot;Gloss&quot;, Range(<span class="hljs-number">8.0</span>, <span class="hljs-number">256</span>)) = <span class="hljs-number">20</span><br>&#125;<br>SubShader &#123;<br>Pass &#123; <br>Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;<br><br>CGPROGRAM<br><br><span class="hljs-meta">#pragma vertex vert</span><br><span class="hljs-meta">#pragma fragment frag</span><br><br><span class="hljs-meta">#include &quot;Lighting.cginc&quot;</span><br><br>fixed4 _Color;<br><span class="hljs-type">sampler2D</span> _MainTex;<br>            <span class="hljs-comment">// 三个纹理公用一个属性变量，此时修改平铺和偏移系数会同时影响3个纹理的采样</span><br>float4 _MainTex_ST;<br><span class="hljs-type">sampler2D</span> _BumpMap;<br><span class="hljs-type">float</span> _BumpScale;<br><span class="hljs-type">sampler2D</span> _SpecularMask;<br><span class="hljs-type">float</span> _SpecularScale;<br>fixed4 _Specular;<br><span class="hljs-type">float</span> _Gloss;<br><br>struct a2v &#123;<br>float4 vertex : POSITION;<br>float3 normal : NORMAL;<br>float4 tangent : TANGENT;<br>float4 texcoord : TEXCOORD0;<br>&#125;;<br><br>struct v2f &#123;<br>float4 pos : SV_POSITION;<br>float2 uv : TEXCOORD0;<br>float3 lightDir: TEXCOORD1;<br>float3 viewDir : TEXCOORD2;<br>&#125;;<br><br>            v2f vert(a2v v) &#123;<br>                v2f o;<br>                o.pos = UnityObjectToClipPos(v.vertex);<br><br>                o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;<br><br>                <span class="hljs-comment">// Construct a matrix: rotation,</span><br>                <span class="hljs-comment">// which transform vectors from object space to tangent space</span><br>                TANGENT_SPACE_ROTATION;<br>                <br>                o.lightDir = mul(rotation, ObjSpaceLightDir(v.vertex)).xyz;<br>                o.viewDir = mul(rotation, ObjSpaceViewDir(v.vertex)).xyz;<br><br>                <span class="hljs-keyword">return</span> o;<br>            &#125;<br><br>            fixed4 frag(v2f i) : SV_Target &#123;<br>                fixed3 tangentLightDir = <span class="hljs-built_in">normalize</span>(i.lightDir);<br>                fixed3 tangentViewDir = <span class="hljs-built_in">normalize</span>(i.viewDir);<br><br>                fixed3 tangentNormal = UnpackNormal(tex2D(_BumpMap, i.uv));<br><br>                tangentNormal.xy *= _BumpScale;<br><br>                tangentNormal.z = <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">1.0</span> - saturate(<span class="hljs-built_in">dot</span>(tangentNormal.xy, tangentNormal.xy)));<br><br>                fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb;<br><br>                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT * albedo;<br><br>                fixed3 diffuse = _LightColor0.rgb * albedo * <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">dot</span>(tangentNormal, tangentLightDir));<br><br>                fixed3 halfDir = <span class="hljs-built_in">normalize</span>(tangentLightDir + tangentViewDir);<br><br>                <span class="hljs-comment">// Get the mask value</span><br>                fixed specularMask = tex2D(_SpecularMask, i.uv).r * _SpecularScale;<br><br>                <span class="hljs-comment">// Compute specular term with the specular mask</span><br>                fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="hljs-built_in">pow</span>(<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">dot</span>(tangentNormal, halfDir)), _Gloss) * specularMask;<br><br>                <span class="hljs-keyword">return</span> fixed4(ambient + diffuse + specular, <span class="hljs-number">1.0</span>);<br><br>            &#125;<br>            ENDCG<br>        &#125;<br>    &#125;<br>    FallBack &quot;Specular&quot;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>Shader</tag>
      
      <tag>Texture</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UnityShader-基础光照</title>
    <link href="/2021/07/13/UnityShader-%E5%9F%BA%E7%A1%80%E5%85%89%E7%85%A7/"/>
    <url>/2021/07/13/UnityShader-%E5%9F%BA%E7%A1%80%E5%85%89%E7%85%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="UnityShader-基础光照"><a href="#UnityShader-基础光照" class="headerlink" title="UnityShader-基础光照"></a>UnityShader-基础光照</h1><p>从宏观上说，渲染包含了两大部分：决定一个像素的可见性，决定这个像素上的光照计算</p><h2 id="标准光照模型"><a href="#标准光照模型" class="headerlink" title="标准光照模型"></a>标准光照模型</h2><h3 id="环境光"><a href="#环境光" class="headerlink" title="环境光"></a>环境光</h3><p>用来模拟间接光照，指光线会在多个物体之间反射，最后进入摄像机。计算方法如下：<br>$$<br>c_{ambient} &#x3D; g_{ambient}<br>$$</p><p>在Unity中，场景中的环境光通过Window-&gt;Render-&gt;Lighting中设置，在Shader中通过内置变量<code>UNITY_LIGHTMODEL_AMBIENT</code>获取</p><h3 id="自发光"><a href="#自发光" class="headerlink" title="自发光"></a>自发光</h3><p>光线可以直接由光源发射进入摄像机，而不需要经过任何物体反射，计算方法：<br>$$<br>c_{emissive} &#x3D; m_{emissive}<br>$$<br>在实时渲染中，该物体不会照亮周围的表面</p><p>如果需要计算自发光，只需要在片元着色器输出最后的颜色之前，把材质的自发光添加到输出颜色上即可</p><h3 id="漫反射"><a href="#漫反射" class="headerlink" title="漫反射"></a>漫反射</h3><p>漫反射用于对那些物体表面随机散射到各个方向的辐射度进行建模的，视角的位置不重要，即任何反射方向上的分布都是一样的。但是受到入射角影响很大</p><h4 id="兰伯特定律-Lambert’s-Law"><a href="#兰伯特定律-Lambert’s-Law" class="headerlink" title="兰伯特定律(Lambert’s Law)"></a>兰伯特定律(Lambert’s Law)</h4><p>漫反射光照遵循<strong>兰伯特定律(Lambert’s law)<strong>：反射光线的强度与表面法线和光源方向之间夹角的余弦值成正比，计算方式如下：<br>$$<br>c_{diffuse} &#x3D; (c_{light} \cdot m_{diffuse})max(0, n \cdot I)<br>$$<br>其中，$n$是表面法线，$I$是</strong>指向光源</strong>的单位矢量，$m_{diffuse}$是材质的漫反射颜色，$c_{light}$是光源颜色</p><br><p>Unity中<strong>逐顶点漫反射光照</strong>效果实现如下：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs glsl">Shader &quot;Diffuse Vertex Level&quot;&#123;<br>    Properties &#123;<br>        _Diffuse (&quot;Diffuse&quot;, Color) = (<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>)<br>    &#125;<br><br>    SubShader &#123;<br>        Pass &#123;<br>            <span class="hljs-comment">// 光照模式为前向渲染，得到Unity内置光照变量</span><br>            Tags &#123;&quot;LightMode&quot;=&quot;ForwardBase&quot;&#125;<br><br>            CGPROGRAM<br><br>            <span class="hljs-meta">#pragma vertex vert</span><br>            <span class="hljs-meta">#pragma fragment frag</span><br><br>            <span class="hljs-meta">#include &quot;UnityCG.cginc&quot;</span><br>            <span class="hljs-comment">// 包含计算光照的头文件</span><br>            <span class="hljs-meta">#include &quot;Lighting.cginc&quot;</span><br><br>            fixed4 _Diffuse;<br><br>            struct a2v &#123;<br>                float4 vertex : POSITION;<br>                float3 normal : NORMAL;<br>            &#125;;<br><br>            struct v2f &#123;<br>                float4 pos : SV_POSITION;<br>                fixed3 color : COLOR0;<br>            &#125;;<br><br>            v2f vert(a2v v) &#123;<br>                v2f o;<br>                o.pos = UnityObjectToClipPos(v.vertex);<br><br>                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;<br><br>                <span class="hljs-comment">// 使用法向量左乘世界空间变换到模型空间的矩阵 等价于 使用法向量右乘模型空间变换到世界空间的逆转置矩阵</span><br>                fixed3 worldNormal = <span class="hljs-built_in">normalize</span>(mul(v.normal, (float3x3)unity_WorldToObject));<br>                <br>                <span class="hljs-comment">// 只能适用于只有一个光源而且是平行光的情况</span><br>                fixed3 worldLight = <span class="hljs-built_in">normalize</span>(_WorldSpaceLightPos0.xyz);<br><br>                <span class="hljs-comment">// diffuse = c_light * m_diffuse * max(0, dot(Vec_n, Vec_light))</span><br>                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(<span class="hljs-built_in">dot</span>(worldNormal, worldLight));<br><br>                o.color = ambient + diffuse;<br>                <span class="hljs-comment">// o.color = _Diffuse.rgb;</span><br>                <span class="hljs-keyword">return</span> o;<br>            &#125;<br><br>            fixed4 frag(v2f i) : SV_Target &#123;<br>                <span class="hljs-keyword">return</span> fixed4(i.color, <span class="hljs-number">1.0</span>);<br>            &#125;<br><br>            ENDCG<br>        &#125;<br>    &#125;<br>    Fallback &quot;Diffuse&quot;<br>&#125;<br></code></pre></td></tr></table></figure><p>Unity中<strong>逐像素漫反射光照</strong>效果实现如下：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs glsl">Shader &quot;AABB/Diffuse Pixel Level&quot;&#123;<br>    Properties &#123;<br>        _Diffuse (&quot;Diffuse&quot;, Color) = (<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>)<br>    &#125;<br><br>    SubShader &#123;<br>        Pass &#123;<br>            Tags &#123;&quot;LightMode&quot;=&quot;ForwardBase&quot;&#125;<br><br>            CGPROGRAM<br><br>            <span class="hljs-meta">#pragma vertex vert</span><br>            <span class="hljs-meta">#pragma fragment frag</span><br><br>            <span class="hljs-meta">#include &quot;UnityCG.cginc&quot;</span><br>            <span class="hljs-meta">#include &quot;Lighting.cginc&quot;</span><br><br>            fixed4 _Diffuse;<br><br>            struct a2v &#123;<br>                float4 vertex : POSITION;<br>                float3 normal : NORMAL;<br>            &#125;;<br><br>            struct v2f &#123;<br>                float4 pos : SV_POSITION;<br>                fixed3 worldNormal : TEXCOORD0;<br>            &#125;;<br><br>            v2f vert(a2v v) &#123;<br>                v2f o;<br>                o.pos = UnityObjectToClipPos(v.vertex);<br><br>                o.worldNormal = mul(v.normal, (float3x3)unity_WorldToObject);<br>                <span class="hljs-keyword">return</span> o;<br>            &#125;<br><br>            fixed4 frag(v2f i) : SV_Target &#123;<br>                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;<br><br>                fixed3 worldNormal = <span class="hljs-built_in">normalize</span>(i.worldNormal);<br><br>                fixed3 worldLightDir = <span class="hljs-built_in">normalize</span>(_WorldSpaceLightPos0.xyz);<br><br>                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(<span class="hljs-built_in">dot</span>(worldNormal, worldLightDir));<br><br>                fixed3 color = ambient + diffuse;<br><br>                <span class="hljs-keyword">return</span> fixed4(color, <span class="hljs-number">1.0</span>);<br>            &#125;<br><br>            ENDCG<br>        &#125;<br>    &#125;<br>    Fallback &quot;Diffuse&quot;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于当前模型，在光线无法到达的区域，模型的外观通常是全黑的，没有任何明暗变化，这使得模型失去细节表现。</p><br><h4 id="半兰伯特模型-Half-Lambert"><a href="#半兰伯特模型-Half-Lambert" class="headerlink" title="半兰伯特模型(Half Lambert)"></a>半兰伯特模型(Half Lambert)</h4><p>在任何区域的光照强度都将大于等于0，使得被光面也能够有明暗变化，计算公式为：<br>$$<br>c_{diffuse} &#x3D; (c_{light} \cdot m_{diffuse})(\alpha(\hat n \cdot I) + \beta)<br>$$<br>大多数情况下，$\alpha$ 和 $\beta$ 的值均为0.5，这样把点乘的结果范围从[-1, 1]映射到[0, 1]，保证模型暗面的细节也能够被显示出来。</p><p><strong>半兰伯特模型</strong>实现如下：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs glsl">Shader &quot;Half Lambert&quot;&#123;<br>    Properties &#123;<br>        _Diffuse (&quot;Diffuse&quot;, Color) = (<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>)<br>    &#125;<br><br>    SubShader &#123;<br>        Pass &#123;<br>            Tags &#123;&quot;LightMode&quot;=&quot;ForwardBase&quot;&#125;<br><br>            CGPROGRAM<br><br>            <span class="hljs-meta">#pragma vertex vert</span><br>            <span class="hljs-meta">#pragma fragment frag</span><br><br>            <span class="hljs-meta">#include &quot;UnityCG.cginc&quot;</span><br>            <span class="hljs-meta">#include &quot;Lighting.cginc&quot;</span><br><br>            fixed4 _Diffuse;<br><br>            struct a2v &#123;<br>                float4 vertex : POSITION;<br>                float3 normal : NORMAL;<br>            &#125;;<br><br>            struct v2f &#123;<br>                float4 pos : SV_POSITION;<br>                fixed3 worldNormal : TEXCOORD0;<br>            &#125;;<br><br>            v2f vert(a2v v) &#123;<br>                v2f o;<br>                o.pos = UnityObjectToClipPos(v.vertex);<br><br>                o.worldNormal = mul(v.normal, (float3x3)unity_WorldToObject);<br>                <span class="hljs-keyword">return</span> o;<br>            &#125;<br><br>            fixed4 frag(v2f i) : SV_Target &#123;<br>                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;<br><br>                fixed3 worldNormal = <span class="hljs-built_in">normalize</span>(i.worldNormal);<br><br>                fixed3 worldLightDir = <span class="hljs-built_in">normalize</span>(_WorldSpaceLightPos0.xyz);<br><br>                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * (<span class="hljs-number">0.5</span> * <span class="hljs-built_in">dot</span>(worldNormal, worldLightDir) + <span class="hljs-number">0.5</span>);<br><br>                fixed3 color = ambient + diffuse;<br><br>                <span class="hljs-keyword">return</span> fixed4(color, <span class="hljs-number">1.0</span>);<br>            &#125;<br><br>            ENDCG<br>        &#125;<br>    &#125;<br>    Fallback &quot;Diffuse&quot;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="高光反射"><a href="#高光反射" class="headerlink" title="高光反射"></a>高光反射</h3><p>用于计算那些沿着完全镜面反射方向被反射的光线，可以让物体看起来有光泽</p><h4 id="Phong模型"><a href="#Phong模型" class="headerlink" title="Phong模型"></a>Phong模型</h4><p>反射方向计算及图案示例：<br>$$<br>r &#x3D; 2(\hat n \cdot I)\hat n - I<br>$$<br><img src="/2021/07/13/UnityShader-%E5%9F%BA%E7%A1%80%E5%85%89%E7%85%A7/image-20210819233731955.png" alt="image-20210819233731955"></p><p>然后利用<strong>Phong模型</strong>来计算高光反射部分：<br>$$<br>c_{specular} &#x3D; (c_{light} \cdot m_{specular})max(0, \hat v \cdot r)^{m_{gloss}}<br>$$<br>$m_{gloss}$是**光泽度(gloss)**，也被称为反光度(shininess)。用于控制高光区域的亮点有多宽，两者的增长趋势相反</p><p>$m_{specular}$ 是材质的高光反射颜色，控制该材质对于高光反射的强度和颜色</p><p>$c_{light}$是光源的颜色和强度</p><p>$\hat v$是视角方向</p><p>Phong高光反射模型图如下：</p><p><img src="/2021/07/13/UnityShader-%E5%9F%BA%E7%A1%80%E5%85%89%E7%85%A7/specular.png" alt="specular.png-31.2kB"></p><br><h4 id="Blinn模型"><a href="#Blinn模型" class="headerlink" title="Blinn模型"></a>Blinn模型</h4><p>另一种高光反射模型——<strong>Blinn模型</strong>如下图：</p><p><img src="/2021/07/13/UnityShader-%E5%9F%BA%E7%A1%80%E5%85%89%E7%85%A7/Blinn.png" alt="Blinn.png-32.1kB"></p><p>该模型避免计算反射方向$\hat r$，为此引入新的矢量$\hat h$，计算方法：<br>$$<br>\hat h &#x3D; \frac{\hat v + I}{\abs {\hat v + I}}<br>$$<br>Blinn模型公式如下：<br>$$<br>c_{specular} &#x3D; (c_{light} \cdot m_{specular})max(0, \hat n \cdot \hat h)^{m_{gloss}}<br>$$<br><strong>两种模型对比：</strong></p><p><strong>性能：</strong>在硬件实现时，如果摄像机和光源距离足够远，Blinn模型会快于Phong模型，因为这时可以认为 $\hat v$ 和 $\hat I$ 都是定值，因此 $\hat h$ 是一个常量。否则，Phong模型可能更快。</p><p><strong>效果：</strong>两者都是经验模型，需要根据实际情况判断</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p><strong>逐顶点Phong模型</strong>实现，由于高光反射部分的计算是非线性的，而在顶点着色器中计算光照再进行插值的过程是线性的，破环了原计算的非线性关系，会出现较大的视觉问题</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs glsl">Shader &quot;Specular Vertex Level&quot; &#123;<br>    Properties &#123;<br>        _Diffuse(&quot;Diffuse&quot;, Color) = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>        _Specular(&quot;Specular&quot;, Color) = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>        <span class="hljs-comment">// 控制高光区域的大小</span><br>        _Gloss(&quot;Gloss&quot;, Range(<span class="hljs-number">8.0</span>, <span class="hljs-number">256</span>)) = <span class="hljs-number">20</span><br>    &#125;<br>    SubShader &#123;<br>        Pass &#123;<br>            Tags &#123; &quot;LightMode&quot; = &quot;ForwardBase&quot; &#125;<br><br>            CGPROGRAM<br><br>            <span class="hljs-meta">#include &quot;Lighting.cginc&quot;</span><br><br>            <span class="hljs-meta">#pragma vertex vert</span><br>            <span class="hljs-meta">#pragma fragment frag</span><br><br>            fixed4 _Diffuse;<br>            fixed4 _Specular;<br>            <span class="hljs-type">float</span> _Gloss;<br><br>            struct a2v &#123;<br>                float4 vertex : POSITION;<br>                float3 normal : NORMAL;<br>            &#125;;<br><br>            struct v2f &#123;<br>                float4 pos : SV_POSITION;<br>                fixed3 color : COLOR;<br>            &#125;;<br><br>            v2f vert(a2v v)&#123;<br>                v2f o;<br>                o.pos = UnityObjectToClipPos(v.vertex);<br><br>                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;<br>                fixed3 worldNormal = <span class="hljs-built_in">normalize</span>(mul(v.normal, (float3x3)unity_WorldToObject));<br>                fixed3 worldLightDir = <span class="hljs-built_in">normalize</span>(_WorldSpaceLightPos0.xyz);<br><br>                <span class="hljs-comment">// diffuse = C_light * m_diffuse * max(0, dot(Vec_n, Vec_light))</span><br>                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(<span class="hljs-built_in">dot</span>(worldNormal, worldLightDir));<br><br>                <span class="hljs-comment">// 使用内置函数reflect计算反射光方向，参数1为光源到反射点的向量，因此取反</span><br>                fixed3 reflectDir = <span class="hljs-built_in">normalize</span>(<span class="hljs-built_in">reflect</span>(-worldLightDir, worldNormal));<br><br>                fixed3 viewDir = <span class="hljs-built_in">normalize</span>(_WorldSpaceCameraPos.xyz - mul(unity_ObjectToWorld, v.vertex).xyz);<br>                <span class="hljs-comment">// specular = C_light * m_specular * (max(0, dot(Vec_r, Vec_v)))**m_gloss</span><br>                fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="hljs-built_in">pow</span>(saturate(<span class="hljs-built_in">dot</span>(reflectDir, viewDir)), _Gloss);<br><br>                o.color = ambient + diffuse + specular;<br>                <span class="hljs-keyword">return</span> o;<br>            &#125;<br><br>            fixed4 frag(v2f i) : SV_Target &#123;<br>                <span class="hljs-keyword">return</span> fixed4(i.color, <span class="hljs-number">1.0</span>);<br>            &#125;<br>            ENDCG<br>        &#125;<br>    &#125;<br>    Fallback &quot;Specular&quot;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>逐像素Phong模型</strong>实现：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs glsl">Shader &quot;Specular Pixel Level&quot; &#123;<br>    Properties &#123;<br>        _Diffuse(&quot;Diffuse&quot;, Color) = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>        _Specular(&quot;Specular&quot;, Color) = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>        <span class="hljs-comment">// 控制高光区域的大小</span><br>        _Gloss(&quot;Gloss&quot;, Range(<span class="hljs-number">8.0</span>, <span class="hljs-number">256</span>)) = <span class="hljs-number">20</span><br>    &#125;<br>    SubShader &#123;<br>        Pass &#123;<br>            Tags &#123; &quot;LightMode&quot; = &quot;ForwardBase&quot; &#125;<br><br>            CGPROGRAM<br><br>            <span class="hljs-meta">#include &quot;Lighting.cginc&quot;</span><br><br>            <span class="hljs-meta">#pragma vertex vert</span><br>            <span class="hljs-meta">#pragma fragment frag</span><br><br>            fixed4 _Diffuse;<br>            fixed4 _Specular;<br>            <span class="hljs-type">float</span> _Gloss;<br><br>            struct a2v &#123;<br>                float4 vertex : POSITION;<br>                float3 normal : NORMAL;<br>            &#125;;<br><br>            struct v2f &#123;<br>                float4 pos : SV_POSITION;<br>                float3 worldNormal : TEXCOORD0;<br>                float3 worldPos : TEXCOORD1;<br>            &#125;;<br><br>            v2f vert(a2v v)&#123;<br>                v2f o;<br>                o.pos = UnityObjectToClipPos(v.vertex);<br><br>                o.worldNormal = mul(v.normal, (fixed3x3)unity_WorldToObject);<br>                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<br>                <span class="hljs-keyword">return</span> o;<br>            &#125;<br><br>            fixed4 frag(v2f i) : SV_Target &#123;<br>                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;<br>                fixed3 worldNormal = <span class="hljs-built_in">normalize</span>(i.worldNormal);<br>                fixed3 worldLightDir = <span class="hljs-built_in">normalize</span>(_WorldSpaceLightPos0.xyz);<br><br>                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(<span class="hljs-built_in">dot</span>(worldNormal, worldLightDir));<br><br>                fixed3 reflectDir = <span class="hljs-built_in">normalize</span>(<span class="hljs-built_in">reflect</span>(-worldLightDir, worldNormal));<br>                fixed3 viewDir = <span class="hljs-built_in">normalize</span>(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);<br><br>                fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="hljs-built_in">pow</span>(saturate(<span class="hljs-built_in">dot</span>(reflectDir, viewDir)), _Gloss);<br><br>                <span class="hljs-keyword">return</span> fixed4(ambient + diffuse + specular, <span class="hljs-number">1.0</span>);<br>            &#125;<br>            ENDCG<br>        &#125;<br>    &#125;<br>    Fallback &quot;Specular&quot;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Blinn-Phong模型</strong>实现：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs glsl">Shader &quot;AABB/Blinn Phong&quot; &#123;<br>    Properties &#123;<br>        _Diffuse(&quot;Diffuse&quot;, Color) = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>        _Specular(&quot;Specular&quot;, Color) = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>        <span class="hljs-comment">// 控制高光区域的大小</span><br>        _Gloss(&quot;Gloss&quot;, Range(<span class="hljs-number">8.0</span>, <span class="hljs-number">256</span>)) = <span class="hljs-number">20</span><br>    &#125;<br>    SubShader &#123;<br>        Pass &#123;<br>            Tags &#123; &quot;LightMode&quot; = &quot;ForwardBase&quot; &#125;<br><br>            CGPROGRAM<br><br>            <span class="hljs-meta">#include &quot;Lighting.cginc&quot;</span><br><br>            <span class="hljs-meta">#pragma vertex vert</span><br>            <span class="hljs-meta">#pragma fragment frag</span><br><br>            fixed4 _Diffuse;<br>            fixed4 _Specular;<br>            <span class="hljs-type">float</span> _Gloss;<br><br>            struct a2v &#123;<br>                float4 vertex : POSITION;<br>                float3 normal : NORMAL;<br>            &#125;;<br><br>            struct v2f &#123;<br>                float4 pos : SV_POSITION;<br>                float3 worldNormal : TEXCOORD0;<br>                float3 worldPos : TEXCOORD1;<br>            &#125;;<br><br>            v2f vert(a2v v)&#123;<br>                v2f o;<br>                o.pos = UnityObjectToClipPos(v.vertex);<br><br>                <span class="hljs-comment">// o.worldNormal = mul(v.normal, (fixed3x3)unity_WorldToObject);</span><br>                <span class="hljs-comment">// 使用Unity 内置函数</span><br>                o.worldNormal = UnityObjectToWorldNormal(v.normal);<br><br>                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<br>                <span class="hljs-keyword">return</span> o;<br>            &#125;<br><br>            fixed4 frag(v2f i) : SV_Target &#123;<br>                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;<br>                fixed3 worldNormal = <span class="hljs-built_in">normalize</span>(i.worldNormal);<br><br>                <br><br>                <span class="hljs-comment">// fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz);</span><br>                <span class="hljs-comment">// 输入为世界空间中的顶点位置</span><br>                fixed3 worldLightDir = <span class="hljs-built_in">normalize</span>(UnityWorldSpaceLightDir(i.worldPos));<br><br>                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(<span class="hljs-built_in">dot</span>(worldNormal, worldLightDir));<br><br>                <span class="hljs-comment">// fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);</span><br>                <span class="hljs-comment">// 输入为世界空间中的顶点位置</span><br>                fixed3 viewDir = <span class="hljs-built_in">normalize</span>(UnityWorldSpaceViewDir(i.worldPos));<br><br>                <span class="hljs-comment">// Vec_h = (Vec3_view + Vec3_light) / (length(Vec3_view + Vec3_light))</span><br>                fixed3 halfDir = <span class="hljs-built_in">normalize</span>(worldLightDir + viewDir);<br><br>                <span class="hljs-comment">// C_specular = (C_light * m_specular) * (max(0, dot(Vec3_normal * Vec3_h)))**m_gloss</span><br>                fixed3 specular = _LightColor0.rgb * _Specular.rgb * <span class="hljs-built_in">pow</span>(<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">dot</span>(worldNormal, halfDir)), _Gloss);<br><br>                <span class="hljs-keyword">return</span> fixed4(ambient + diffuse + specular, <span class="hljs-number">1.0</span>);<br>            &#125;<br>            ENDCG<br>        &#125;<br>    &#125;<br>    Fallback &quot;Specular&quot;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>逐像素光照 vs 逐顶点光照</strong></p><p>在逐像素光照中，以每个像素为基础，得到法线（来自顶点法线插值或者法线纹理采样）后进行光照模型计算，又被称为<strong>Phong着色</strong></p><p>在逐顶点光照中，以每个顶点为基础计算光照，然后在渲染图元内进行线性插值，最后输出像素颜色</p><p><strong>性能：</strong>逐像素光照计算量大于逐顶点光照</p><p><strong>效果：</strong>由于逐顶点光照依赖线性插值得到像素光照，因此当光照模型中有<strong>非线性计算</strong>时（如高光反射），逐顶点光照会有明显瑕疵。同时，顶点处的颜色总是亮于图元内部的颜色，某些情况下会出现明显的棱角</p><h2 id="Unity内置函数"><a href="#Unity内置函数" class="headerlink" title="Unity内置函数"></a>Unity内置函数</h2><p><img src="/2021/07/13/UnityShader-%E5%9F%BA%E7%A1%80%E5%85%89%E7%85%A7/image-20210820013839185.png" alt="image-20210820013839185"></p><p>注意：这些函数都没有保证得到的额方向矢量是单位矢量，因此，需要在使用前把它们归一化</p><p>实际使用过程中，推荐在UnityCG.cginc和Lighting.cginc文件中直接查找关键词，同时浏览实现方法，避免踩坑</p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>Shader</tag>
      
      <tag>Lighting</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UnityShader-ShaderLab</title>
    <link href="/2021/07/12/UnityShader-ShaderLab/"/>
    <url>/2021/07/12/UnityShader-ShaderLab/</url>
    
    <content type="html"><![CDATA[<h1 id="UnityShader-ShaderLab"><a href="#UnityShader-ShaderLab" class="headerlink" title="UnityShader-ShaderLab"></a>UnityShader-ShaderLab</h1><blockquote><p>本文用于放置一些ShaderLab中的基本概念和属性速查表</p></blockquote><h2 id="Unity-Shader的基本框架"><a href="#Unity-Shader的基本框架" class="headerlink" title="Unity Shader的基本框架"></a>Unity Shader的基本框架</h2><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs glsl">Shader &quot;MyShader&quot; &#123;<br>    Properties &#123;<br>        _MyTexture (&quot;My Texture&quot;, <span class="hljs-number">2</span>D) = &quot;white&quot; &#123; &#125;<br>        <span class="hljs-comment">// place other properties here, such as colors or vectors.</span><br>    &#125;<br>    SubShader &#123;<br>        <span class="hljs-comment">// place the shader code here for your:</span><br>        <span class="hljs-comment">// - surface shader,</span><br>        <span class="hljs-comment">// - vertex and program shader, or</span><br>        <span class="hljs-comment">// - fixed function shader</span><br>    &#125;<br>    SubShader &#123;<br>        <span class="hljs-comment">// a simpler version of the subshader above goes here.</span><br>        <span class="hljs-comment">// this version is for supporting older graphics cards.</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><p><img src="/2021/07/12/UnityShader-ShaderLab/image-20210819195901522.png" alt="image-20210819195901522"></p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-comment">//Float类型，下面对应变量可以用flaot,half,fixed  </span><br>_Name(&quot;Inspector Name&quot;, Float) = defaultValue  <br><span class="hljs-comment">//Float类型,可以用一个滑动条控制范围,下面对应变量可以用float,half,fixed  </span><br>_Name(&quot;Inspector Name&quot;, Range(<span class="hljs-built_in">min</span>, <span class="hljs-built_in">max</span>)) = defaultValue  <br><span class="hljs-comment">//颜色类型，下面对应变量可以用float4,half4,fixed4，如果是颜色，尽量fixed4  </span><br>_Name(&quot;Inspector Name&quot;, Color) = (defaultValue.r, defaultValue.g, defaultValue.b, defaultValue.a)  <br><span class="hljs-comment">//2D纹理类型,默认纹理可以为空，白，黑，灰，凹凸，下面对应变量sampler2D  </span><br>_Name(&quot;Inspector Name&quot;, <span class="hljs-number">2</span>D) = &quot;&quot; / &quot;white&quot; / &quot;black&quot; / &quot;gray&quot; / &quot;bump&quot;&#123;options&#125;  <br><span class="hljs-comment">//长方形纹理，非2次方大小的纹理，其同上  </span><br>_Name(&quot;Inspector Name&quot;, Rect) = &quot;&quot; / &quot;white&quot; / &quot;black&quot; / &quot;gray&quot; / &quot;bump&quot;&#123;options&#125;  <br><span class="hljs-comment">//立方体贴图CubeMap  </span><br>_Name(&quot;Inspector Name&quot;, Cube) = &quot;&quot; &#123;options&#125;  <br><span class="hljs-comment">//传递一个Vector4向量  </span><br>_Name(&quot;Inspector Name&quot;, Vector) = (defaultValue.x, defaultValue.y, defaultValue.z, defaultValue.w)  <br>  <br><span class="hljs-comment">//注：上面纹理后面&#123;&#125;里面是一些纹理TexGen，LightmapMode光照模式等内容  </span><br></code></pre></td></tr></table></figure><h2 id="SubShader"><a href="#SubShader" class="headerlink" title="SubShader"></a>SubShader</h2><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs glsl">SubShader &#123;<br>    [Tags]<br>    [RenderSetup]<br>    Pass &#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="状态设置"><a href="#状态设置" class="headerlink" title="状态设置"></a>状态设置</h3><p><img src="/2021/07/12/UnityShader-ShaderLab/image-20210819200033406.png" alt="image-20210819200033406"></p><h3 id="标签类型"><a href="#标签类型" class="headerlink" title="标签类型"></a>标签类型</h3><p><img src="/2021/07/12/UnityShader-ShaderLab/image-20210819200122349.png" alt="image-20210819200122349"></p><h2 id="Pass"><a href="#Pass" class="headerlink" title="Pass"></a>Pass</h2><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs glsl">Pass &#123;<br>    [Name]<br>    [Tags]<br>    [RenderSetup]<br>   <span class="hljs-comment">// Other code</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="标签类型-1"><a href="#标签类型-1" class="headerlink" title="标签类型"></a>标签类型</h3><p><img src="/2021/07/12/UnityShader-ShaderLab/image-20210819200315169.png" alt="image-20210819200315169"></p><p>特殊Pass：</p><ul><li><p>UsePass：服用其他Unity Shader中的Pass，必须使用大写形式的名字</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs glsl">UsePass &quot;MyShader/MYPASSNAME&quot;<br></code></pre></td></tr></table></figure></li><li><p>GrabPass：抓取屏幕并将结果存储在一张纹理中，以用于后续的Pass处理</p></li></ul><h2 id="Fallback"><a href="#Fallback" class="headerlink" title="Fallback"></a>Fallback</h2><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs glsl">Fallback &quot;name&quot;<br></code></pre></td></tr></table></figure><p>备用Shader，同时会影响阴影的投射</p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>Shader</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UnityShader-渲染流水线</title>
    <link href="/2021/07/10/UnityShader-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/"/>
    <url>/2021/07/10/UnityShader-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="UnityShader-渲染流水线"><a href="#UnityShader-渲染流水线" class="headerlink" title="UnityShader-渲染流水线"></a>UnityShader-渲染流水线</h1><h2 id="渲染流程"><a href="#渲染流程" class="headerlink" title="渲染流程"></a>渲染流程</h2><p>计算机从一系列顶点数据(POSITION)、纹理(TEXCOORD)等信息出发，把这些信息最终转换成一张二维图像显示在屏幕上。</p><p>渲染流程可分为3个阶段：应用阶段(Application Stage)、几何阶段(Geometry Stage)、光栅化阶段(Rasterizer Stage)</p><p><img src="/2021/07/10/UnityShader-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/%E6%A6%82%E5%BF%B5%E6%B5%81%E6%B0%B4%E7%BA%BF.png" alt="概念流水线.png-16.9kB"></p><h3 id="应用阶段"><a href="#应用阶段" class="headerlink" title="应用阶段"></a>应用阶段</h3><p>通常由CPU负责实现，这一阶段的主要任务：</p><ul><li>准备好场景数据。如摄像机位置、视锥体、场景模型、使用光源等</li><li>粗粒度剔除工作。把不可见的物体剔除</li><li>设置每个模型的<strong>渲染状态</strong>。包括材质、纹理、Shader等</li></ul><p>这一阶段输出渲染所需的几何信息，即<strong>渲染图元</strong>（rendering primitives）。渲染图元一般是点、线、三角面等</p><h3 id="几何阶段"><a href="#几何阶段" class="headerlink" title="几何阶段"></a>几何阶段</h3><p>这一阶段处理和绘制相关的操作。决定需要绘制的图元是什么，怎样绘制和在哪里绘制(what, how, where)。<strong>该阶段在GPU上进行</strong>。</p><p>主要任务：把顶点坐标变换到屏幕空间中，即输出<strong>屏幕空间的顶点信息</strong>，再交给光栅器进行处理。这一阶段将会输出屏幕空间的二维顶点坐标、每个顶点对应的深度值、着色等相关信息，并传递给下一个阶段</p><h3 id="光栅化阶段"><a href="#光栅化阶段" class="headerlink" title="光栅化阶段"></a>光栅化阶段</h3><p>这一阶段利用上个阶段传递的数据来产生屏幕像素，渲染出最终图像。</p><p>该阶段输入的信息为<strong>屏幕坐标系下的顶点位置</strong>以及它们相关的额外信息，如<strong>深度值(z坐标)<strong>、</strong>法线方向</strong>、<strong>视角方向</strong>等</p><p>主要任务：决定每个渲染图元中哪些像素应该被绘制在屏幕上。它需要对逐顶点数据（包括纹理坐标、顶点颜色等）进行<strong>插值</strong>，再进行<strong>逐像素处理</strong>。也就是说，计算每个图元覆盖了哪些像素，以及为这些像素计算它们的颜色</p><h2 id="软件-x2F-硬件之间的联系"><a href="#软件-x2F-硬件之间的联系" class="headerlink" title="软件&#x2F;硬件之间的联系"></a>软件&#x2F;硬件之间的联系</h2><h3 id="CPU和GPU之间的通信"><a href="#CPU和GPU之间的通信" class="headerlink" title="CPU和GPU之间的通信"></a>CPU和GPU之间的通信</h3><p>该过程对应渲染流水线中的应用阶段。对于CPU而言，应用阶段可以分为一下阶段：</p><ol><li>把数据加载到显存（Video Random Access Memory, VRAM）中。这一阶段加载的数据包括但不限于顶点的位置信息、法线方向、顶点颜色、纹理坐标等</li><li>设置渲染状态。即定义场景中的网格如何被渲染，例如顶点\片元着色器的选择、光源属性、材质等</li><li>调用Draw Call。CPU发送一个命令给GPU。让GPU开始进行渲染，该命令会指向需要被渲染图元的列表</li></ol><h3 id="CPU、OpenGL-x2F-DirectX、显卡驱动和GPU之间的联系"><a href="#CPU、OpenGL-x2F-DirectX、显卡驱动和GPU之间的联系" class="headerlink" title="CPU、OpenGL&#x2F;DirectX、显卡驱动和GPU之间的联系"></a>CPU、OpenGL&#x2F;DirectX、显卡驱动和GPU之间的联系</h3><p><img src="/2021/07/10/UnityShader-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/OpenGL%E5%92%8CDirectX.png" alt="OpenGL和DirectX.png-56.1kB"></p><h2 id="GPU流水线"><a href="#GPU流水线" class="headerlink" title="GPU流水线"></a>GPU流水线</h2><p>GPU流水线即GPU的渲染过程。对应于渲染流水线中的几何阶段和光栅化阶段</p><p><img src="/2021/07/10/UnityShader-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/GPU%E6%B5%81%E6%B0%B4%E7%BA%BF.png" alt="GPU流水线.png-82.2kB"></p><p><span style="color:green">绿色：该流水线阶段是完全可编程控制的，实线表示必须实现，虚线表示该阶段可选</span></p><p><span style="color:#FFCC00">黄色：该流水线阶段可配置但不可编程</span></p><p><span style="color:blue">蓝色：该流水线阶段由GPU固定实现，开发者没有任何控制权</span></p><h3 id="顶点着色器-Vertex-Shader"><a href="#顶点着色器-Vertex-Shader" class="headerlink" title="顶点着色器(Vertex Shader)"></a>顶点着色器(Vertex Shader)</h3><ul><li>完全可编程</li><li>通常用于实现顶点的空间变换、顶点着色</li><li>处理单位：顶点，即每个输入顶点都会调用一次顶点着色器，顶点着色器不能创建和销毁顶点，且每个顶点相对独立（方便GPU并行计算）</li><li>主要工作：<ul><li>坐标变换。将顶点坐标从模型空间转换到<strong>齐次裁剪坐标空间</strong>（<a href="https://zhuanlan.zhihu.com/p/258437902">什么是齐次坐标? - 知乎 (zhihu.com)</a>），再由硬件做透视除法转换到**归一化的设备坐标(Normalized Device Coordinates, NDC)**。在OpenGL中，NDC的z分量在[-1, 1]之间，而DirectX中，z分量在[0, 1]之间</li><li>逐顶点光照</li><li>输出后续阶段所需数据</li></ul></li></ul><p>![Vertex Shader.png-34.9kB](UnityShader-渲染流水线&#x2F;Vertex Shader.png)</p><p>注：根据原书的说法，右图应该是处于NDC下的坐标</p><h3 id="曲面细分着色器-Tessellation-Shader"><a href="#曲面细分着色器-Tessellation-Shader" class="headerlink" title="曲面细分着色器(Tessellation Shader)"></a>曲面细分着色器(Tessellation Shader)</h3><ul><li>可选着色器</li><li>用于细分图元</li></ul><h3 id="几何着色器-Geometry-Shader"><a href="#几何着色器-Geometry-Shader" class="headerlink" title="几何着色器(Geometry Shader)"></a>几何着色器(Geometry Shader)</h3><ul><li>可选着色器</li><li>用于执行逐图元(Pre-Primitive)的着色操作，或者被用于产生更多的图元</li></ul><h3 id="裁剪-Clipping"><a href="#裁剪-Clipping" class="headerlink" title="裁剪(Clipping)"></a>裁剪(Clipping)</h3><ul><li>将不在摄像机视野内的顶点裁剪掉，并剔除某些三角图元的图片（区别于应用阶段的粗粒度剔除工作，它只是将不可见物体剔除，不会涉及图元和片元），可以使用自定义的裁剪平面来配置裁剪区域。也可以<strong>通过指令控制裁剪三角图元的正面还是背面</strong>。</li></ul><p><img src="/2021/07/10/UnityShader-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/Clipping.png" alt="Clipping.png-25.5kB"></p><h3 id="屏幕映射-Screen-Mapping"><a href="#屏幕映射-Screen-Mapping" class="headerlink" title="屏幕映射(Screen Mapping)"></a>屏幕映射(Screen Mapping)</h3><ul><li>不可配置和编程</li><li>负责把每个图元的坐标（输入坐标仍然是三维坐标，范围在单位立方体内）转换到屏幕坐标系中，会经历一个缩放的过程，输入的z坐标不会做任何处理</li><li>屏幕坐标系和z坐标一起构成<strong>窗口坐标系(Window Coordinates)</strong></li><li>屏幕映射得到的屏幕坐标决定了这个顶点对应屏幕上哪个像素以及距离这个像素有多远</li></ul><p><img src="/2021/07/10/UnityShader-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/ScreenMapping.png" alt="ScreenMapping.png-22.6kB"></p><ul><li>屏幕坐标系在OpenGL和DirectX之间存在差异，这可能导致图像倒转</li></ul><p>![Screen Mapping_OpenGL_DirectX.png-26.9kB](UnityShader-渲染流水线&#x2F;Screen Mapping_OpenGL_DirectX.png)</p><h3 id="三角形设置-Triangle-Setup"><a href="#三角形设置-Triangle-Setup" class="headerlink" title="三角形设置(Triangle Setup)"></a>三角形设置(Triangle Setup)</h3><ul><li>开发者没有任何控制权</li><li>该阶段会计算光栅化一个三角网格所需的信息，根据三角网格的顶点数据（输入数据）得到整个三角网格对像素的覆盖情况</li></ul><h3 id="三角形遍历-Triangle-Traversal"><a href="#三角形遍历-Triangle-Traversal" class="headerlink" title="三角形遍历(Triangle Traversal)"></a>三角形遍历(Triangle Traversal)</h3><ul><li><p>开发者没有任何控制权</p></li><li><p>检查每个像素是否被一个三角网格所覆盖，如果被覆盖，则生成一个<strong>片元(fragment)</strong></p></li><li><p>该阶段也被称为<strong>扫描变换(Scan Conversion)</strong></p></li><li><p>三角形遍历阶段会根据上一个阶段的计算结果来判断一个三角网格覆盖了哪些像素，<strong>并使用三角网格的3个顶点信息对整个覆盖区域的像素进行插值</strong></p></li><li><p>关于该阶段对哪些信息进行了怎样的插值（如法线插值、纹理插值等），可以参考OpenGL的官方教程<a href="https://ogldev.org/www/tutorial09/tutorial09.html">OpenGL tutorial09</a></p><p>简单来说，每个顶点的<strong>法向量</strong>由构成它的三角形的法向量的平均值构成，而三角形内部的法向量由三角形的顶点插值构成，这样，如果物体不是平坦的（即三角形图元不在一个平面上），那么图元内的法向量方向也会不同，这样能够使得计算得到的光照更加真实</p><p>插值对于<strong>纹理坐标</strong>的应用也类似，这些坐标作为模型的一部分定义在每个顶点上。为了用贴图覆盖三角形你必须对每个像素进行一样的插值操作并给每个像素定义正确的纹理坐标，这些坐标都是插值的结果</p></li><li><p>片元：包含很多状态的集合，这些状态用于计算每个像素的最终颜色。这些状态包括了<strong>屏幕坐标</strong>、<strong>深度信息</strong>，以及其他从几何阶段输出的顶点信息，例如<strong>法线</strong>、<strong>纹理坐标</strong>等</p></li></ul><p><img src="/2021/07/10/UnityShader-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/TriangleSetupAndTraversal.png" alt="TriangleSetupAndTraversal.png-80kB"></p><h3 id="片元着色器-Fragment-Shader"><a href="#片元着色器-Fragment-Shader" class="headerlink" title="片元着色器(Fragment Shader)"></a>片元着色器(Fragment Shader)</h3><ul><li>完全可编程</li><li>用于实现逐片元(Pre-Fragment)的着色操作，输出一个或者多个颜色值</li><li>该阶段完成<strong>纹理采样</strong>操作( Tex2D(texture, uv) )</li></ul><h3 id="逐片元操作-Pre-Fragment-Operations"><a href="#逐片元操作-Pre-Fragment-Operations" class="headerlink" title="逐片元操作(Pre-Fragment Operations)"></a>逐片元操作(Pre-Fragment Operations)</h3><ul><li>负责执行很多重要工作，如修改颜色、深度缓冲、进行混合等，在DirectX中被称为<strong>输出合并阶段(Output-Merger)</strong></li><li>决定每个片元的可见性，如深度测试、模板测试等</li><li>如果一个片元通过了所有测试，就需要把这个片元的颜色值和已经存储在颜色缓冲区中的颜色进行合并，或者说混合</li><li>该阶段高度可配置，如关闭深度写入(ZWrite Off)，定义混合方法(Blend SrcAlpha OneMinusSrcAlpha)</li></ul><h4 id="模板测试-Stencil-Test"><a href="#模板测试-Stencil-Test" class="headerlink" title="模板测试(Stencil Test)"></a>模板测试(Stencil Test)</h4><p>TODO</p><h4 id="深度测试-Depth-Test"><a href="#深度测试-Depth-Test" class="headerlink" title="深度测试(Depth Test)"></a>深度测试(Depth Test)</h4><ul><li><p>根据片元的深度进行比较，将没有通过测试的片元舍弃</p></li><li><p>和模板测试不同的是，如果一个片元没有通过深度测试，则没有权利更改深度缓冲区的值；如果通过测试，可以指定是否覆盖掉原有深度值，即开启&#x2F;关闭深度写入</p></li></ul><p>模板测试和深度测试的简要过程如下：</p><p>![Stencil Test_Depth Test.png-93.5kB](UnityShader-渲染流水线&#x2F;Stencil Test_Depth Test.png)</p><h4 id="混合-Blend"><a href="#混合-Blend" class="headerlink" title="混合(Blend)"></a>混合(Blend)</h4><ul><li>对于半透明物体，需要使用混合操作来让物体看起来透明</li><li>混合操作高度可配置，通过设置混合函数能够实现不同的混合效果</li></ul><p><img src="/2021/07/10/UnityShader-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/Blending.png" alt="Blending.png-67.6kB"></p><br><h4 id="Early-Z技术"><a href="#Early-Z技术" class="headerlink" title="Early-Z技术"></a>Early-Z技术</h4><p>对于大部分GPU来说，为了避免 计算被舍弃片元的颜色 造成造成的性能浪费，它们会尽可能在<strong>执行片元着色器之前就进行这些测试</strong></p><p>但是，提前测试的结果可能与片元着色器的一些操作冲突，例如，在透明度测试中，需要在片元着色器中手动进行测试(调用clip函数)，这将导致GPU禁用提前测试，降低性能</p><br><p>GPU采用双重缓冲(Double Buffering)策略避免看到正在进行光栅化的图元</p><h2 id="关于Draw-Call"><a href="#关于Draw-Call" class="headerlink" title="关于Draw Call"></a>关于Draw Call</h2><h3 id="命令缓冲区-Command-Buffer"><a href="#命令缓冲区-Command-Buffer" class="headerlink" title="命令缓冲区(Command Buffer)"></a>命令缓冲区(Command Buffer)</h3><p>让CPU和GPU能够并行工作。CPU向其中添加命令，GPU从中取出命令，添加和读取过程相互独立（生产者和消费者问题）</p><p><img src="/2021/07/10/UnityShader-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/CommandBuffer.png" alt="CommandBuffer.png-49.9kB"></p><h3 id="批处理方法-Batching"><a href="#批处理方法-Batching" class="headerlink" title="批处理方法(Batching)"></a>批处理方法(Batching)</h3><p>由于每次调用Draw Call，CPU需要向GPU发送很多内容，该提交过程非常影响性能，因此对于<strong>静态物体</strong>，可以将网格合并后批量发送，但是对于动态物体，由于每一帧都要合并后发送，可能会在性能上造成影响</p><h2 id="固定管线渲染"><a href="#固定管线渲染" class="headerlink" title="固定管线渲染"></a>固定管线渲染</h2><p>在较旧的GPU上实现的渲染流水线，除非考虑兼容，不然不要使用</p><br><p>其他：</p><p>关于批处理：Wloka M. Batch, Batch, Batch: What does it mean?[C]&#x2F;&#x2F;Presentation at game developers conference. 2003.</p><p>关于实时渲染：Alkenine-Moller T, Haines E, Hoffman N. Real-time rendering[M]. CRC Press, 2008.</p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>Shader</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Game Dev Log</title>
    <link href="/2021/04/23/Game%20Dev%20Log/"/>
    <url>/2021/04/23/Game%20Dev%20Log/</url>
    
    <content type="html"><![CDATA[<h1 id="Game-Dev-Log"><a href="#Game-Dev-Log" class="headerlink" title="Game Dev Log"></a>Game Dev Log</h1><h2 id="2021-4-23"><a href="#2021-4-23" class="headerlink" title="2021-4-23"></a>2021-4-23</h2><p>关键词：物理引擎，碰撞</p><ol><li><p>y轴抖动问题<br>现场还原：当Player落在cube平面上时，会出现y轴方向的速度不断波动的问题<br>可能原因：cube的厚度过小(0.2)，两个物体的碰撞判断造成<br>解决方法：增加cube的厚度</p></li><li><p>物体碰撞产生速度分量<br>现场还原：当Player在方块的边缘下落时，它会产生一个水平方向的速度分量，并且会一直运动下去<br>可能原因：Player在碰撞到方块的左（右）上角时，方块会因为牛顿第三定律而给Player施加一个水平方向的力，导致Player获得一个水平方向的速度<br>解决方法：1. 给Player的下表面和方块的上表面添加摩擦材质 2. 在碰撞后的帧中，获得瞬时的刚体速度(velocity &#x3D; rigidbody.velocity)，然后通过代码来控制该速度的水平分量，处理完后再将它重新赋值给刚体</p></li><li><p>Player运动颠簸<br>现场还原：当Player在多个连续的方块上移动时，如果速度比较大，可能会上下颠簸<br>可能原因：方块在接触点上并不平滑（相当于有个坎儿），Player撞到坎儿上导致颠簸<br>解决方法：暂时未知</p></li><li><p>物体卡在方块的侧面或者边角<br>现场还原：<br>可能原因：Player和方块表面不光滑<br>解决办法：设置光滑材质</p></li><li><p>物体穿模<br>现场还原：Player在前进时，如果速度过大，可能直接从方块上传过去<br>可能原因：Player的移动速度过快，前后两帧之间的距离过大，导致碰撞判定不及时，物体已经穿过模型<br>解决办法：1. 降低Player的速度 2. 将碰撞判定改成连续，但是会降低性能（不推荐对低速物体使用）</p></li></ol><h2 id="2021-6-3"><a href="#2021-6-3" class="headerlink" title="2021-6-3"></a>2021-6-3</h2><ol><li>角色和地面之间有间隔<br>现场还原：角色使用Character Controller后，和Plane之间有较大空隙<br>可能原因：Character Controller设置问题<br>解决办法：查文档</li></ol><h2 id="2021-6-17"><a href="#2021-6-17" class="headerlink" title="2021-6-17"></a>2021-6-17</h2><p>双人对战demo2D开发总结</p><ol><li><p>总体问题<br>1.1 玩法缺乏创意<br>1.2 代码整体结构不清晰，封装差，导致可读性不高，不容易扩展<br>1.3 变量访问控制混乱<br>1.4 类中成员变量的设置太多（虽然这样能够提高开发效率）</p></li><li><p>其他细节上的问题及总结<br>2.1 组件模式下组件之间的消息传递问题<br>解决办法：</p></li><li><p>组件之间任何需要共享的数据都放在容器中</p></li><li><p>直接互相应用（最常用）<br>例如：Unity中调用GetComponent<T>()获取游戏对象下某个类型的组件</T></p></li><li><p>通过传递信息的方式进行广播，这种方式一般要保留所有组件的引用</p></li></ol><p>2.2 资源、素材、游戏对象、组件命名的问题<br>解决办法：<br>把每一种需要命名的对象看作一个实例，把这个实例中的属性按照重要性顺序组合起来构成名字<br>例如：<br>玩家腿部的预制件：Player_Leg_Prefab<br>炸弹爆炸的动画：Bomb_Explosion_Animation<br>冰面的砖块：Ice_Tile</p><p>2.3 关于自动机的控制<br>描述：<br>自动机可以被使用在角色控制、敌人AI上，但是如果状态和转移条件控制的不合理，则会使得代码的结构变得十分复杂，<br>这种情况下反而不如使用if语句，逻辑上更加直观<br>问题：<br>如何设计好状态机的状态和转移条件<br>解决方法：暂无</p><p>2.4 关于持续作用效果的问题<br>描述：<br>当某个条件触发时，物体的状态发生改变，并在一段时间后恢复原来的状态<br>例如：<br>当子弹和人物发生碰撞时，会刷新人物受到伤害的动画，直到动画播放完毕人物恢复到原来的状态<br>问题：<br>如果没有动画如何控制好时间？<br>例如：<br>当子弹与箱子发生碰撞的时候，箱子的颜色发生改变，直到一段时间后箱子的颜色恢复到原来的颜色<br>解决办法：<br>本质问题还是状态的改变，因此设置一个bool变量表示当前状态，当子弹与箱子发生碰撞时，改变箱子的颜色，然后记录下此时的时间，<br>在Update循环中检查当前时间距离上次记录的受击时间是否到达一定的间隔，如果到达设定的时间间隔，代表当前状态执行完成，<br>需要将状态还原为初始状态<br>伪代码如下：<br>&#x2F;&#x2F; Variables<br>bool isHit &#x3D; false;<br>float lastGetHitTime &#x3D; 0f;<br>float intervalTime &#x3D; 0.3f;</p><p>&#x2F;&#x2F; OnTrigger<br>void OnTriggerCollider2D(Collider other):<br>    if other is bullet:<br>        isHit &#x3D; true;<br>        lastGetHitTime &#x3D; currentTime;<br>        color &#x3D; hitColor;</p><p>&#x2F;&#x2F; Update<br>void Update():<br>    if isHit:<br>        if currentTime - lastGetHitTime &gt; intervalTime:<br>            isHit &#x3D; false;<br>            color &#x3D; originColor;</p><p>2.5 Update函数中应该如何编写结构合理的代码<br>解决办法：</p><ol><li><p>如果采用bool变量代表状态：<br>代码结构采用<br>if()func1();<br>elif()func2();<br>elif()func3();<br>…<br>else funcn();</p></li><li><p>如果采用状态机：<br>代码结构：<br>state.Update();</p></li></ol><h2 id="2021-6-17-1"><a href="#2021-6-17-1" class="headerlink" title="2021-6-17"></a>2021-6-17</h2><p>描述：<br>学习项目：Character Controller With Animations -Walk, Run, Jump &amp; Attack<br>地址：<a href="https://www.youtube.com/watch?v=qc0xU2Ph86Q&list=WL&index=1">https://www.youtube.com/watch?v=qc0xU2Ph86Q&amp;list=WL&amp;index=1</a></p><ol><li><p>状态的保持与传递<br>描述：在进行跳跃时，有两种选择：</p></li><li><p>人物在空中依然能够操纵角色的速度大小和方向：直接添加跳跃动作即可</p></li><li><p>人物在空中的速度大小和方向由跳跃之前的状态决定<br>现场还原：当人物处于Idle状态下按跳跃，人物会竖直起跳；当人物移动时跳跃，人物的移动方向保持不变<br>解决办法：设置isGrounded状态下才接收状态量的改变</p></li><li><p>分层设计<br>描述：在Update函数中，数据分层进行处理，这样可以方便添加一些特殊效果</p></li><li><p>输入：接收来自键盘和鼠标的输入<br>如果屏蔽输入，那么角色将暂时不受玩家控制</p></li><li><p>设置速度：设置角色的速度<br>在角色位置移动之前，可以通过输入和环境来共同影响速度</p></li><li><p>设置位置： 设置角色的位置</p></li><li><p>动画操纵<br>描述：本质是通过变量的值来操纵动画<br>例如：混合树通过一个或者多个float类型变量的值来代表当前动画，我们在改变这些变量时就是在改变动画的状态</p></li></ol><h2 id="2020-6-18"><a href="#2020-6-18" class="headerlink" title="2020-6-18"></a>2020-6-18</h2><p>关键词：状态机<br>描述：将昨天人物移动的代码以状态机的方式重写</p><ol><li><p>变量的访问控制<br>解决办法：将大部分变量设置为私有，然后通过访问器来访问相关变量</p></li><li><p>状态的复用<br>描述：将State基类和StateMachine类设置为泛型，以此来声明状态所属的物体</p></li><li><p>状态的转换问题<br>描述：相对于使用if-else句型，状态机的状态在转换时只关注到2个状态，因此有利于找出和修改bug，<br>但是构建状态机需要画出比较严谨的状态转换图，而且状态拆分过多也可能造成许多不必要的转换<br>解决办法：对于状态过多导致的重复转换问题，使用层次状态机（给每个状态设置父状态，可以使用继承或者链表的形式）</p></li><li><p>状态机的核心：只要控制了物体的一切状态，就可以控制物体的一切行为</p></li><li><p>如何区分不同的状态？<br>解决办法：根据标准而定</p></li><li><p>把状态量在某一个范围的集合作为一种状态，例如速度在某个区间，人物在某个平面内移动，<br>某些状态还具有持续时间，如果到达持续时间，则状态发生改变，例如喝水的状态，睡觉的状态</p></li><li><p>一个状态也可以划分为许多子状态，子状态是父状态集合下的一个新的划分<br>例如：把人物站在地面上作为一个状态，那么子状态可以是站立、移动、快跑等等</p></li><li><p>一般来说，状态所包含的状态量越少（例如在地面上的状态只包含一个状态量，而行走包含站在地面上和移动速度两个状态量），则状态处理起来越简单</p></li><li><p>自然界通过产生力来产生物体的运动，我们看到的只是物体位置的改变，而物体本质的状态是受力、加速度<br>启发：状态只需要控制一些父状态量（加速度，速度），就能够通过既定的规则来生成子状态量（位置）</p></li><li><p>状态改变的条件不一定包含在某一个状态中，需要在外部生成该条件</p></li><li><p>每个状态维护者一个状态量的范围，当超出界限时，状态量发生改变，这个临界值可以作为状态改变的条件<br>例如：<br>从地面到空中，状态isGrounded发生该改变<br>从站立到行走，输入发生改变<br>从行走到冲刺，输入发生改变<br>从冲刺到站立，冲刺时间、耐力值发生改变<br>从站立到攻击，输入发生改变<br>从攻击到站立，攻击持续时间发生改变</p></li><li><p>思考：游戏中的取消后摇是怎么回事？<br>运动状态的改变影响到了攻击状态的该变（停止）</p></li><li><p>状态的叠加：几个分状态合成物体的实际状态，例如物体作为质点的平移状态、物体作为轴的旋转状态和物体的攻击状态叠加形成实际看到的状态</p></li><li><p>实际开发中，不用思考以上问题，怎么简单、直观怎么来，最后都能够把问题补上的 :)</p></li></ol><h2 id="2021-7-16"><a href="#2021-7-16" class="headerlink" title="2021-7-16"></a>2021-7-16</h2><p>UGDAP游戏开发实训经验总结</p><ol><li>一款成功的游戏需要好的玩法，每个游戏都要为自己设计核心系统<br>核心玩法（系统）的设计：<br>游戏目的-可操作行为-障碍<br>游戏目的：<br>玩家游玩游戏需要追寻怎样的引导，游戏策划需要仔细的规划好游戏中的每一个目标点，如解开谜题、敌人的难度、收集道具</li></ol><p>可操作行为：<br>玩家的行动能力，一般ACT游戏中，玩家能够行走、奔跑、跳跃，卡牌游戏中，玩家抽牌、出牌都是可操作行为<br>玩家的行为决定了他具有怎样的能力</p><p>障碍：<br>基于玩家的行为进行设计，可以考虑以下几方面的因素：<br>反应速度、智力、耐力（一般不会）、记忆力、策略…</p><ol start="2"><li>倾听：<br>团队-投资人-游戏-玩家-自己</li></ol><p>—- 开发方面 —-<br>3. 开发前需要思考的事情*<br>3.1 游戏需要实现怎样的功能？<br>最需要思考的事情，这决定了你的代码多大概率会写成屎山:)。<br>游戏系统：<br>背包系统、射击系统、玩家移动系统、敌人AI、卡牌系统、物理系统、场景交互系统…提前规划好系统后，可以把这些系统<br>作为游戏模块设计，降低代码之间的耦合<br>敌人、地形种类：<br>哪些敌人、地形具有相似的功能，这决定了你的代码是否使用继承，以及预制件是否使用继承<br>提供测试接口：<br>为了减少编译次数，你的游戏在测试阶段应尽可能提供多的测试接口，几乎所有能够通过调整数值进行测试的效果都可以<br>提供测试接口，以方便快速测试。<br>可以调整的数值有：<br>位移、速度、加速度、发力时长、收招时长、攻击范围、受击范围、硬直时间、击退距离、击倒、击飞、击飞轨迹、特效<br>位置、特效大小、特效持续时间、摄像机的震动幅度与时长、高亮持续时间、定帧时长…</p><h2 id="2021-7-23"><a href="#2021-7-23" class="headerlink" title="2021-7-23"></a>2021-7-23</h2><p>静态类和单例模式的区别：<br>单例模式能够延迟加载<br>单例模式能够继承类、接口、重写方法<br>一般开发工具的时候使用静态类，因为静态类是提前编译好的（如Math类），其他情况一般使用单例</p><h2 id="2021-7-31"><a href="#2021-7-31" class="headerlink" title="2021-7-31"></a>2021-7-31</h2><p>腾讯next idea高校游戏创意大赛总结：</p><ul><li>在思考某个设计的解决方案时，通常都会有多种办法，如果它们各有利弊，则可以先记录下来，当后续的需求不会对方法<br>产生较大影响时，任选其一即可，切忌选择恐惧</li></ul><ol><li>项目组织和设计<br>设计得比较合适的地方：<br>@ 敌人的脚本使用状态机控制，将各种状态行为分离开来，即使后来需要改变部分敌人的初始状态也能够较快的进行设置<br>@ 运动体的移动方式都是通过控制 速度来得到位移，尽量不要直接对运动物体的位置进行修改<br>@</li></ol><p>设计得不太合理的地方：<br>@ 主角状态的设置不太合理，当主角获得buff之后，仅仅添加了一个bool值来代表当前状态发生改变，导致其他所有组件<br>都要拿到该状态后再添加相应动作，代码耦合度非常高<br>@ Notebook的GameObject设计不合理，使用了太多的非子物体引用，导致场景转换十分麻烦，比较合适的做法是，<br>为Notebook设计一个唯一的父物体，为该物体添加Notebook Manager单例，其他物体都挂载或者间接挂载在该物体<br>下方，这种方式在移动物体时不会造成引用丢失。根据这里的原理，我们可以将场景中的所有物体都归类到相应系统中，<br>当需要其他系统的引用时，直接通过对应系统的单例获得</p><p>中规中矩的地方：</p><ol start="2"><li>与他人合作<br>2.1 与其他程序合作<br>尽量不要修改同一个模块的功能，在场景中添加物体时，尽量做到整体添加</li></ol><p>2.2 与策划合作<br>文本：如何将txt格式的文字转化为对话框<br>各种数值：如何将excel表格中的数据转化成数据对象（结构体）？</p><ol start="3"><li>遇到的小问题<br>3.1 对于大部分成员变量添加一层封装效果（C#为访问器），可以实现部分变量的延迟加载，特别是涉及到一些变量的<br>同步问题时，可以在缺少该变量时及时获取<br>3.2 对于持久化的数据，可以存储在Scriptable Object对象中，大大降低程序对内存的使用量<br>3.3 通常情况下，Debug的最好方式就是输出语句，在写完一段逻辑后，应该输出相应的信息来验证是否符合自己的预期<br>，可以在OnGUI函数中创建Button、Label来帮助Debug<br>3.4 动画、音乐播放时存在同步的问题，即当前Update中设置了动画播放后，需要等待至少一帧的时间，被设置的动画<br>才真正开始播放，此时获取的动画状态才是正确的，可以使用协程来进行同步<br>3.5 敌人死亡应该和死亡动画的播放分割开来，即死亡特效新建一个游戏对象来制作</li></ol><h2 id="2021-9-23"><a href="#2021-9-23" class="headerlink" title="2021-9-23"></a>2021-9-23</h2><p>腾讯next idea高校游戏创意大赛总结2:</p><p>动画和游戏逻辑的同步：</p><p>最初，我的设计理念是，能够在代码中设置好的逻辑尽量不放在编辑器中。比如，游戏对象的查找，敌人、道具的生成，组件的初始化等等，这样做的优点在于，不容易和场景中的其它对象产生耦合，同时有利于debug和做功能上的微调。</p><p>但是，在动画播放和事件触发的逻辑层面，如果纯粹使用代码来控制流程，则会比较复杂。</p><p>首先，事件的触发点难以调整。在编辑器中，能够直接在相应的帧处添加事件，开发者能够很方便地进行可视化调整。如果放在代码中添加，则难以将动画帧和事件对应起来</p><p>另一个是代码逻辑的问题。如果不添加动画帧事件，即根据normalizedTime判断事件触发的时机，则会滥用Coroutine，同时，如果多个动画中间又掺杂了多个事件，则会造成协程的层层嵌套，极大地增加了代码编写难度。</p><p>目前想到地较好解决办法是，对于小型项目，可以直接在编辑器中添加动画帧事件，但缺点是，难以找到这些动画帧事件的引用，增加了debug的难度</p><p>另一种方式是，依然在代码中为动画帧添加事件，但是，对于具体触发的帧数，还是在编辑器中设置成可调节的，尽管动画效果调整时会麻烦一些，debug却轻松一些了</p><p>游戏测试的问题：</p><p>游戏测试需要今早做，因为模块和模块，功能和功能结合的时候也可能产生很多Bug，需要多个程序之间沟通交流，通过熟悉对方的逻辑和流程找出产生bug的原因和bug的位置</p><p><strong>对于Unity来说，在编辑器中正常运行的功能，在build出的成品中依然可能出现很严重的bug</strong>。目前已知的有，部分视频在编辑器中能够正常播放，而在最终项目中完全无法播放。对于一些代码中的和编辑器有关的类、属性和函数，在最终项目中也可能被编译器忽略掉了。</p><p>因此，build项目也需要一个测试版本，只有该版本也通过所有测试之后，才能够发布最终版本</p><p>功能设计时模块化的重要性：</p><p>在与其它程序合作的过程中，不同功能肯定是分开设计的，因此需要进行模块化设计，比如人物的行为控制模块化，地图资源加载模块化，Boss战的功能模块化等等。这就要求模块之间的耦合度尽可能低，不能或者尽量少地依赖于其它模块，这样才能在多个场景中独立地调试该游戏功能或内容。</p><p>对于可能产生依赖的部分，要区分必要依赖和非必要依赖。例如，对于一个需要追踪的敌人，追踪目标是必要的，但我们在调试的时候，可以设置一个默认追踪目标，防止因为报错而无法测试该功能，但又需要给出警告，便于后续debug</p><p>Boss战设计：</p><p>设计该内容时，策划给出了许多基本需求，这也算是首次做一个比较复杂而且精炼的内容。设计要点如下：</p><ul><li>Boss基本状态控制</li><li>Boss技能效果、释放动画、顺序等</li><li>Boss对场景的控制</li><li>Boss战各个阶段的表现和阶段之间的转换</li></ul><p>因此，在编写代码之前，必须先写出较为详细的设计文档，以确定整体的框架结构和各个功能实现过程中可能出现的交叉和难点。</p><p>同时，如何存储Boss战每个阶段的数据也需要精心规划，既要让数据易修改、易保存，又要尽可能将数据可视化，方便策划进行效果调整和程序员debug工作。</p><p>例如，在本次Boss战的设计中，我为每个技能、阶段设计一个类，而每个阶段又包含了该阶段Boss所拥有的技能；每个技能类、阶段类有对应的ScriptableObject，用于存储持久化数据，在进入相应阶段时，程序从这些SO中读取数据到类的成员变量中，实现Boss的阶段初始化。</p><p>在实践中主要遇到以下难点：</p><ul><li>Boss战中有一个在地图指定位置生成小怪的功能，而由于小怪具有比较复杂的AI，因此为其专门设计了参数的保存和读取方式，可以通过在场景中设置好召唤生物的各个状态，再将状态按照相应规则保存到字符串中，这样，每次召唤生物时，就可以通过解析字符串将召唤物初始化</li><li>Boss战不同的阶段还涉及到地形的变化，由于地形不便于序列化存储，且同一阶段中不会发生太大的改变，因此直接作为Boss战场景的子结点，通过设置激活状态实现阶段转移</li></ul><p>代码重构实践：</p><p>需要根据实际情况具体应用，对于需要长期运营的项目或者需求经常改动的项目，代码重构是十分有必要的，这不仅能使得代码更加清晰易懂，而且好的重构能够缩小需要改动的代码范围</p><p>但是，如果代码不用经常改动，则尽量在最初设计的时候就考虑到每个类的变量和函数分布，减少重构代码耗费的时间</p><p>游戏数据的存储：</p><p>便于序列化的数据尽量使用ScriptableObject、json等方式存储，便于与策划合作，调整效果</p><p>对于难以序列化的数据，则采用AssetBundle或者预制件的方式存储，如果没有方便的工具，尽量还是由程序员自己调整效果</p><h2 id="2021-10-10"><a href="#2021-10-10" class="headerlink" title="2021-10-10"></a>2021-10-10</h2><p>腾讯游戏比赛中遇到的一个寻路问题：</p><p>一个处在悬浮平台上方的敌人，如何最终处于地面上的玩家？</p><p>这个问题看似简单，对于策划来说，你让敌人从平台上掉下来不就行了吗，但是，如果仅仅这样设计，就会出现非常多的漏洞</p><ol><li>敌人不知道平台的几何信息。加入玩家处在一个类似于洞穴的地形内部，敌人如果一直朝着玩家目标的位置移动，则永远无法到达，因为洞穴的出口在反方向，敌人只有折回去才能找到玩家</li><li>玩家处于平台下方时，敌人不知道选择从哪个方向掉下平台，如果随机选择一个方向，则会回到上一个问题</li><li>一般的寻路算法在这里不好使。对于常见的AStar算法而言，其寻路时建立的图结点是没有考虑重力影响的，如果让敌人直接沿着结点寻路，则会出现敌人在空中漂移的情况，这是不行的</li></ol><p>我观察过一些游戏的敌人AI，在一般的3d游戏里，如果道路是连接在一起的，则敌人能够到达指定位置，但是，如果？？</p><p>在造梦西游里出现过一样的情形，敌人同样也会在平台上方转悠而无法掉下来。</p><p>关于Unity中人物骨骼控制的问题：</p><p>最初，我对Unity中人物骨骼控制不太了解，因为我认为那是动画师的事情，所以我跟着油管上的一个TPS教程学习，它完全使用了Animation Rigging这个插件来进行人物动画制作，即仅仅控制武器的变换，然后通过IK来控制人物骨骼的变换</p><p>但是这样会产生一个问题，即循环约束，例如，令玩家的骨骼被武器约束以模拟玩家握住武器的姿势，但是，我又希望武器被玩家身体的某个骨骼约束（例如肩膀），这样便形成了循环约束，这样最开始设置的约束就会产生偏移，同时，武器本身也不能自由移动了。除了这个，Animation Rigging也还有其它的问题，比如我希望通过动画来调整权重，这又不得不在Rig对象下建立一个动画机，但可能由于一些执行顺序的问题，上层的动画机会覆盖下层动画机的设置，导致IK权重无法发生变化。后来经过我观察发现，该博主最后也不再经常使用这个插件了。</p><p>后来我是用Unity的Avatar+Humanoid来完成的骨骼动画控制，虽然最终达成了目标，但是依然受到了很多限制，调试了很长时间才做出一个比较合适的动作</p><p>最主要的问题还是在于Humanoid模式，我主要是为了方便人物动画重定向才这么做的，但是使用之后，发现角色的骨骼旋转都被Avatar控制了，只有少部分的骨骼能够通过调用API的方式进行旋转（这个API我也是找了很久才找到，之前一直在测试为什么不能通过代码控制骨骼旋转的问题），如果我希望对人物的其它骨骼旋转进行微调，则没有相应的办法（不过也可能是我没有找到）</p><p>最后调试出来的逻辑是这样的：</p><p>非瞄准模式下：</p><p>鼠标的xy输入控制人物身上的一个空对象进行旋转，让摄像机Follow这个空对象进行变换</p><p>人物的旋转：受两个因素的影响，即move的输入加上相机当前的角度，当然，角色的旋转是平滑过渡的</p><p>人物的移动：人物的旋转四元数乘上人物的前向向量得到旋转后的目标方向，之后角色朝着这个方向移动</p><p>在瞄准模式下：</p><p>人物的旋转分为两部分：</p><p>在水平方向上，人物在y轴上的旋转保持和相机的旋转角度相同。这里会产生一个同步的问题，即如果人物的旋转是在Update中计算得到的，而虚拟相机的旋转是在LateUpdate中执行的（关于为什么要在Late Update中执行，可以参考这篇文章：<a href="https://www.cnblogs.com/zhaoqingqing/p/3454091.html">Update和LateUpdate的区别 - 赵青青 - 博客园 (cnblogs.com)</a>，那么人物的旋转会慢相机旋转一帧，由于相机在每一帧中的旋转角度是不均匀的，从相对论的角度来说，人物相对于相机的角度在每帧也大概率是不同的，因此会出现人物旋转的延迟问题。解决办法是，提前计算好LateUpdate中相机跟随的空对象的角度，存储到一个变量中（不过得确保空对象只在这里被计算过了，否则相机旋转放在Late Update中执行也没有意义），然后利用这个角度更新人物的旋转，最后在LateUpdate中更新跟随空对象的旋转，经过测试，不再出现旋转延迟的问题。</p><p>在垂直方向上，只有人物的胸腔部分随着摄像机的移动旋转，这里让胸腔的旋转跟随空对象沿x轴的旋转，同样需要进行差值过渡和范围裁剪</p><p>之前尝试过几种其它的旋转方式，发现效果都不太理想。例如，让武器对准相机前方一定距离的目标，然后使用IK对右臂进行约束。但是调用Avatar的API后发现，使用SetIKRotation只能作用于手腕的旋转变换，不能很好地带动肘部和肩部的旋转；对于Avatar的LookAtTarget函数，使用后发现只能操纵头部的旋转，依然不能带动人物手臂还有武器的旋转</p><p>总结：在遇到逻辑上的问题时，最好先参考别人的代码逻辑实现，然后再自己针对每一个细节进行调试，这样能避免踩到很多坑</p>]]></content>
    
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>Dev Log</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>棋盘覆盖问题</title>
    <link href="/2020/10/27/%E6%A3%8B%E7%9B%98%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98/"/>
    <url>/2020/10/27/%E6%A3%8B%E7%9B%98%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="棋盘覆盖问题"><a href="#棋盘覆盖问题" class="headerlink" title="棋盘覆盖问题"></a>棋盘覆盖问题</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>有一个边长为2的n次方的正方形棋盘，其中一个位置被图上了颜色，如图：</p><p><img src="/2020/10/27/%E6%A3%8B%E7%9B%98%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98/image-20201027191923231.png" alt="image-20201027191923231"></p><p>现在要使用角形的图案来填满这块棋盘，请问填法是什么？</p><p>示例：</p><p><img src="/2020/10/27/%E6%A3%8B%E7%9B%98%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98/image-20201027192251702.png" alt="image-20201027192251702"></p><h2 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h2><p>因为棋盘的边长是2的幂次，所以对半分块是很容易的，在把棋盘分成四块后，其中有一块一定被上过色，那么这时只需要放置一个角形图案到剩余的三块中间，那么这四块有可以分别视为涂过色的新棋盘，当棋盘的边长只剩2时，可以直接放置角形图案充满棋盘。因此，此题可以使用分治的思想来解决。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>每种颜色使用一个独立的整数来表示，当该颜色被使用过后，就让整数加1来代表新的颜色。</p><p>显然，当我们知道一个棋盘的初始位置和边长之后，那么棋盘的其他位置就被确定下来，因此可以用一个SubBoard类来存储这些变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Board</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">color</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span>[][] board;<br>    <span class="hljs-type">int</span> len;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Board</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> &#123;<br>        board = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[a][a];<br>        len = a;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; a; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; a; j++) &#123;<br>                board[i][j] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">displayBoard</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; board.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; board.length; j++) &#123;<br>                System.out.printf(<span class="hljs-string">&quot;%2d &quot;</span>, board[i][j]);<br>            &#125;<br>            System.out.println();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getPos</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">return</span> board[i][j];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fillColor</span><span class="hljs-params">(Point pos)</span> &#123;<br>        board[pos.row][pos.col] = color;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fillColor</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        board[i][j] = color;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNewColor</span><span class="hljs-params">()</span> &#123;<br>        color++;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cover</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">SubBoard</span> <span class="hljs-variable">subBoard</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubBoard</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), len, <span class="hljs-built_in">this</span>);<br>        subBoard.cover();<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubBoard</span> &#123;<br>    Board board;<br>    Point sPos;<br>    <span class="hljs-type">int</span> len;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SubBoard</span><span class="hljs-params">(Point s, <span class="hljs-type">int</span> len, Board board)</span> &#123;<br>        <span class="hljs-built_in">this</span>.sPos = s;<br>        <span class="hljs-built_in">this</span>.len = len;<br>        <span class="hljs-built_in">this</span>.board = board;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cover</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sRow</span> <span class="hljs-operator">=</span> sPos.row;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sCol</span> <span class="hljs-operator">=</span> sPos.col;<br>        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">2</span>) &#123;<span class="hljs-comment">//边长为2直接填充</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> sRow; i &lt; sRow + len; i++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> sCol; j &lt; sCol + len; j++) &#123;<br>                    <span class="hljs-keyword">if</span> (board.getPos(i, j) == <span class="hljs-number">0</span>) &#123;<br>                        board.fillColor(i, j);<br>                    &#125;<br>                &#125;<br>            &#125;<br>            board.setNewColor();<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">subLen</span> <span class="hljs-operator">=</span> len / <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">//划分成4个子棋盘</span><br>        SubBoard[] subBoards = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubBoard</span>[] &#123; <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubBoard</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(sRow, sCol), subLen, board),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubBoard</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(sRow, sCol + subLen), subLen, board),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubBoard</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(sRow + subLen, sCol), subLen, board),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubBoard</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(sRow + subLen, sCol + subLen), subLen, board) &#125;;<br><span class="hljs-comment">//每个棋盘填色的位置</span><br>        Point[] fillPos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>[] &#123; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(subBoards[<span class="hljs-number">0</span>].getEndRow(), subBoards[<span class="hljs-number">0</span>].getEndCol()),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(subBoards[<span class="hljs-number">1</span>].getEndRow(), subBoards[<span class="hljs-number">1</span>].getStartCol()),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(subBoards[<span class="hljs-number">2</span>].getStartRow(), subBoards[<span class="hljs-number">2</span>].getEndCol()),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(subBoards[<span class="hljs-number">3</span>].getStartRow(), subBoards[<span class="hljs-number">3</span>].getStartCol()) &#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; subBoards.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (!subBoards[i].isPainted()) &#123;<br>                subBoards[i].fillColor(fillPos[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">this</span>.setNewColor();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; subBoards.length; i++) &#123;<br>            subBoards[i].cover();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fillColor</span><span class="hljs-params">(Point pos)</span> &#123;<br>        board.fillColor(pos);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fillColor</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        board.fillColor(i, j);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNewColor</span><span class="hljs-params">()</span> &#123;<br>        board.setNewColor();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getEndRow</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.sPos.row + <span class="hljs-built_in">this</span>.getLen() - <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getEndCol</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.sPos.col + <span class="hljs-built_in">this</span>.getLen() - <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getStartRow</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.sPos.row;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getStartCol</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.sPos.col;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getLen</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> len;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setLen</span><span class="hljs-params">(<span class="hljs-type">int</span> len)</span> &#123;<br>        <span class="hljs-built_in">this</span>.len = len;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Point <span class="hljs-title function_">getsPos</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sPos;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setsPos</span><span class="hljs-params">(Point sPos)</span> &#123;<br>        <span class="hljs-built_in">this</span>.sPos = sPos;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPainted</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> sPos.row; i &lt; sPos.row + len; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> sPos.col; j &lt; sPos.col + len; j++) &#123;<br>                <span class="hljs-keyword">if</span> (board.getPos(i, j) != <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-type">int</span> row;<br>    <span class="hljs-type">int</span> col;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Point</span><span class="hljs-params">(<span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c)</span> &#123;<br>        row = r;<br>        col = c;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>分治</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速排序</title>
    <link href="/2020/10/27/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <url>/2020/10/27/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>快速排序，顾名思义，是消耗时间较少的排序算法。其基本思想也是基于自顶向下，分而治之。</p><p>对于升序排序，首先选取一个元素，将其放到特定的位置，使这个元素左边的值都比它小，右边的值都比它大。然后问题就被化解成对左边的数组进行排序和右边的数组进行排序，直到数组元素只剩一个时，直接返回最小解。</p><p>使用递归算法的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] numbers, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> e)</span> &#123;<br>    <span class="hljs-keyword">if</span> (s &gt;= e)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> numbers[s];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> s;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> e;<br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; numbers[j] &gt;= tmp) &#123;<br>            j--;<br>        &#125;<br>        numbers[i] = numbers[j];<br>        <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; numbers[i] &lt;= tmp) &#123;<br>            i++;<br>        &#125;<br>        numbers[j] = numbers[i];<br>    &#125;<br>    numbers[i] = tmp;<br><br>    quickSort(numbers, s, i - <span class="hljs-number">1</span>);<br>    quickSort(numbers, i + <span class="hljs-number">1</span>, e);<br>&#125;<br></code></pre></td></tr></table></figure><p>但是，使用递归总是面临着栈溢出的风险，所以也需要考虑非递归的算法，究其本质，只是使用外部栈来实现递归的过程。</p><p>其基本思想如下：</p><p>在进行一轮划分后，把右边的数组先存到栈中，继续划分左边的数组，直到没有数组可以划分，这时从栈中取出数组继续划分，循环直到栈为空。</p><p>Java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] numbers)</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 非递归算法，用栈来存储还未排序的片段，然后当只剩当前 一个元素时从栈中取数据，直到栈空</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> numbers.length - <span class="hljs-number">1</span>;<br>    Stack&lt;Integer&gt; start = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    Stack&lt;Integer&gt; end = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    <span class="hljs-type">int</span> tmp;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">int</span> j;<br><br>    <span class="hljs-keyword">while</span> (s &lt; e || !start.isEmpty()) &#123;<br>        <span class="hljs-keyword">if</span> (s &lt; e) &#123;<br>            tmp = numbers[s];<br>            i = s;<br>            j = e;<br>            <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>                <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; numbers[j] &gt;= tmp) &#123;<br>                    j--;<br>                &#125;<br>                numbers[i] = numbers[j];<br>                <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; numbers[i] &lt;= tmp) &#123;<br>                    i++;<br>                &#125;<br>                numbers[j] = numbers[i];<br>            &#125;<br>            numbers[i] = tmp;<br>            start.add(i + <span class="hljs-number">1</span>);<br>            end.add(e);<br>            e = i - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!start.isEmpty()) &#123;<br>            s = start.pop();<br>            e = end.pop();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>分治</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大整数乘法</title>
    <link href="/2020/10/27/%E5%A4%A7%E6%95%B4%E6%95%B0%E4%B9%98%E6%B3%95/"/>
    <url>/2020/10/27/%E5%A4%A7%E6%95%B4%E6%95%B0%E4%B9%98%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="大整数乘法"><a href="#大整数乘法" class="headerlink" title="大整数乘法"></a>大整数乘法</h1><p>对于位数不超过10位的整数而言，可以直接使用运算符做乘法，但是遇到更大的整数只能使用数组来模拟运算。</p><p>这里总结了二进制表示的大整数的乘法。</p><p>假设u和v是两个二进制大整数，如果直接相乘，需要$O(n^2)$的时间复杂度，当然思路也是十分清晰的，直接把每一位相乘得到的数字加起来就好。</p><p>也可以使用分治的思想来实现乘法，并且如果能够使用移位指令的话，时间复杂度能够降低到$O(n^{1.59})$，（但我不知道怎么实现o(╥﹏╥)o）。</p><p>所以借用了算法的思想，使用数组来实现了大整数乘法，只是时间复杂度就难以估算了，在不能移位的情况下，应该也是$O(n^2)$的级别。</p><h2 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h2><p>要求得u乘v的结果，可以把两者拆成两半，分别求出其结果后，再根据化简公式得到uv的值。很显然，<strong>最小的解</strong>（或者说能够直接得到的解）是u ，v的长度都为1时，uv等价于u &amp; v，又因为<strong>每个子问题之间是相互独立</strong>的，因此采用自顶向下，分而治之的方法。</p><ul><li><p>如何划分成两半？</p><p>  需要分奇偶讨论，当u,v为奇数时，$u&#x3D;w2^{(n+1)&#x2F;2}+x$, $v&#x3D;y2^{(n-1)&#x2F;2}+z$。</p><p>  当u,v为偶数时，$u&#x3D;w2^{n&#x2F;2}+x$，$v&#x3D;y2^{n&#x2F;2}+z$。</p><p>  <img src="/2020/10/27/%E5%A4%A7%E6%95%B4%E6%95%B0%E4%B9%98%E6%B3%95/image-20201027172220777.png" alt="image-20201027172220777"></p></li><li><p>如何通过划分得到的值计算uv?</p><p>  化简乘法公式就好，使用乘法分配律后得到：偶数时$uv &#x3D; wy2^n + (wz+xy)2^{n&#x2F;2}+xz$。奇数时同理。</p></li><li><p>如何用数组表示w,x,y,z？</p><p>  创建一个新的数组，把要保留的位赋值给它们，然后返回其引用就好。</p></li><li><p>当n&#x3D; 1 时怎么处理？</p><p>  很明显，划分到最后所有的数组长度都为1，这时如果另一个相乘的数的数组长度不为1，可以继续划分直到两个数组的长度都为1，也可以直接进行计算后返回值，这里就继续采用分治思想，将其划分成最小的解后再进行计算。由于n&#x3D;1为奇数，因此可以划分成它本身和一个0值，在处理和0相乘的数时直接返回0就好。</p></li></ul><p>还有一点要注意的是，在划分的过程中可能出现很多位数组长度的0值，这时需要清除掉数组中多余的0。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>函数的详细功能见每个函数之前的注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> DivideConquer;<br><br><span class="hljs-keyword">import</span> java.util.Random;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BigNum</span> &#123;<br>    <span class="hljs-type">byte</span>[] number;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Use the recursion algorithm to implement the product of two big numbers.</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * Assume that we have two binary numbers:u and v. And then we can seperate each</span><br><span class="hljs-comment">     * to the higher bits and lower bits.For example, u can be considered as two</span><br><span class="hljs-comment">     * parts-- w in high bits and x in low bits. The number v can be also considered</span><br><span class="hljs-comment">     * as y in high bits and z in low bits.</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * To get the product of uv, you can use this formula:</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * &lt;pre&gt;</span><br><span class="hljs-comment">     * uv = wy * 2 ^ (n) + (wz + xy) * 2 ^ (n / 2) + xz</span><br><span class="hljs-comment">     * &lt;/pre&gt;</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * Then get the value of wy,wz,xy,xz with recursion until the length of the</span><br><span class="hljs-comment">     * number is 1, whose result is itself. We can implement the moveLeft function</span><br><span class="hljs-comment">     * to get the value of x * 2^(n).</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> a</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the product of this and a.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> BigNum <span class="hljs-title function_">multiply</span><span class="hljs-params">(BigNum v)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.isZero() || v.isZero()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigNum</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.isOne() &amp;&amp; v.isOne()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigNum</span>(<span class="hljs-string">&quot;1&quot;</span>);<br>        &#125;<br>        <span class="hljs-type">BigNum</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">lenU</span> <span class="hljs-operator">=</span> u.getLength();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">lenV</span> <span class="hljs-operator">=</span> v.getLength();<br>        <span class="hljs-comment">// BigNum result = new BigNum(lenU + lenV);</span><br>        <span class="hljs-type">int</span> hLenU, lLenU;<br>        <span class="hljs-type">int</span> hLenV, lLenV;<br>        <span class="hljs-keyword">if</span> (lenU % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>            hLenU = (lenU + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>            lLenU = (lenU - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            hLenU = lenU / <span class="hljs-number">2</span>;<br>            lLenU = lenU / <span class="hljs-number">2</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (lenV % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>            hLenV = (lenV + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>            lLenV = (lenV - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            hLenV = lenV / <span class="hljs-number">2</span>;<br>            lLenV = lenV / <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-type">BigNum</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> u.clearTail(lLenU);<br>        <span class="hljs-type">BigNum</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> u.clearHead(hLenU);<br>        <span class="hljs-type">BigNum</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> v.clearTail(lLenV);<br>        <span class="hljs-type">BigNum</span> <span class="hljs-variable">z</span> <span class="hljs-operator">=</span> v.clearHead(hLenV);<br>        <span class="hljs-comment">// System.out.println(&quot;u:&quot; + u + &quot; v:&quot; + v);</span><br>        <span class="hljs-comment">// System.out.println(&quot;w:&quot; + w + &quot; x:&quot; + x + &quot; y:&quot; + y + &quot; z:&quot; + z);</span><br><br>        <span class="hljs-type">BigNum</span> <span class="hljs-variable">wy</span> <span class="hljs-operator">=</span> w.multiply(y);<br>        <span class="hljs-type">BigNum</span> <span class="hljs-variable">wz</span> <span class="hljs-operator">=</span> w.multiply(z);<br>        <span class="hljs-type">BigNum</span> <span class="hljs-variable">xy</span> <span class="hljs-operator">=</span> x.multiply(y);<br>        <span class="hljs-type">BigNum</span> <span class="hljs-variable">xz</span> <span class="hljs-operator">=</span> x.multiply(z);<br><br>        <span class="hljs-comment">// System.out.println(&quot;wy:&quot; + wy + &quot; wz:&quot; + wz + &quot; xy:&quot; + xy + &quot; xz:&quot; + xz);</span><br><br>        <span class="hljs-type">BigNum</span> <span class="hljs-variable">uv</span> <span class="hljs-operator">=</span> wy.moveLeft(lLenU + lLenV).add(wz.moveLeft(lLenU)).add(xy.moveLeft(lLenV)).add(xz);<br><br>        <span class="hljs-comment">// System.out.println(&quot;uv:&quot; + uv + &quot;\n&quot;);</span><br>        <span class="hljs-keyword">return</span> uv;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Add two big numbers with each bit.</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> a</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> sum</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> BigNum <span class="hljs-title function_">add</span><span class="hljs-params">(BigNum a)</span> &#123;<br>        <span class="hljs-built_in">this</span>.trimHead();<br>        a.trimHead();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">lenG</span> <span class="hljs-operator">=</span> a.getLength() &gt; <span class="hljs-built_in">this</span>.getLength() ? a.getLength() : <span class="hljs-built_in">this</span>.getLength();<br>        <span class="hljs-comment">// int lenL = a.getLength() &lt; this.getLength() ? a.getLength() :</span><br>        <span class="hljs-comment">// this.getLength();</span><br>        <span class="hljs-type">BigNum</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigNum</span>(lenG + <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> i, j, k;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cf</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        i = <span class="hljs-built_in">this</span>.getLength() - <span class="hljs-number">1</span>;<br>        j = a.getLength() - <span class="hljs-number">1</span>;<br>        k = result.getLength() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> cf + <span class="hljs-built_in">this</span>.getInt(i) + a.getInt(j);<br>            result.setByte(k, tmp % <span class="hljs-number">2</span>);<br>            cf = tmp / <span class="hljs-number">2</span>;<br>            i--;<br>            j--;<br>            k--;<br>        &#125;<br>        BigNum lagerNum;<br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>) &#123;<br>            lagerNum = a;<br>            i = j;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            lagerNum = <span class="hljs-built_in">this</span>;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> cf + lagerNum.getInt(i);<br>            result.setByte(k, tmp % <span class="hljs-number">2</span>);<br>            cf = tmp / <span class="hljs-number">2</span>;<br>            i--;<br>            k--;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (cf != <span class="hljs-number">0</span>) &#123;<br>            result.setByte(k, <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result.trimHead();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * trim the higher zero.</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> BigNum <span class="hljs-title function_">trimHead</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.isZero()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigNum</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">this</span>.getInt(k) == <span class="hljs-number">0</span>) &#123;<br>            k++;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getLength() - k;<br>        <span class="hljs-type">BigNum</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigNum</span>(len);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; result.getLength(); i++) &#123;<br>            result.setByte(i, number[k]);<br>            k++;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Clear the low n bits of the number.</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> n</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> BigNum <span class="hljs-title function_">clearTail</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getLength() - n;<br>        <span class="hljs-keyword">if</span> (length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigNum</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-type">BigNum</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigNum</span>(length);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            result.setByte(i, number[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result.trimHead();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Clear the high n bits of the number.</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> n</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> BigNum <span class="hljs-title function_">clearHead</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getLength() - n;<br>        <span class="hljs-keyword">if</span> (length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigNum</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-type">BigNum</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigNum</span>(length);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> n, k = <span class="hljs-number">0</span>; i &lt; number.length; i++, k++) &#123;<br>            result.setByte(k, number[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result.trimHead();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Imitate the move left operator in binary numbers.</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> n digit to move</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> Big number having been moved left</span><br><span class="hljs-comment">     */</span><br>    BigNum <span class="hljs-title function_">moveLeft</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">newLength</span> <span class="hljs-operator">=</span> number.length + n;<br>        <span class="hljs-type">BigNum</span> <span class="hljs-variable">bigNum</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigNum</span>(newLength);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (i = newLength - <span class="hljs-number">1</span>; i &gt;= (newLength - n); i--) &#123;<br>            bigNum.setByte(i, <span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; number.length; j++) &#123;<br>            bigNum.setByte(j, number[j]);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> bigNum.trimHead();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BigNum</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        number = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; number.length; i++) &#123;<br>            <span class="hljs-built_in">this</span>.setByte(i, <span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * initiate object by String</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> s</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BigNum</span><span class="hljs-params">(String s)</span> &#123;<br>        number = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[s.length()];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            number[i] = Byte.parseByte(s.substring(i, i + <span class="hljs-number">1</span>));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * change number[index] to Integer</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> index</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getInt</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">return</span> Byte.toUnsignedInt(number[index]);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">toInteger</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getLength() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            result += <span class="hljs-built_in">this</span>.getInt(i) * k;<br>            k *= <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getLength</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> number.length;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setByte</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> x)</span> &#123;<br>        number[index] = Byte.parseByte(Integer.toString(x));<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; number.length; i++) &#123;<br>            builder.append(Byte.toString(number[i]));<br>        &#125;<br>        <span class="hljs-keyword">return</span> builder.toString();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isZero</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; number.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.getInt(i) == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isOne</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.getLength() == <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-built_in">this</span>.getInt(<span class="hljs-number">0</span>) == <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Get a random big binary number</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> n the digit of the binary number</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> BigNum <span class="hljs-title function_">getRandomNum</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            builder.append(Integer.toString(random.nextInt(<span class="hljs-number">2</span>)));<br>        &#125;<br>        <span class="hljs-type">BigNum</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigNum</span>(builder.toString());<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高精度</tag>
      
      <tag>Java</tag>
      
      <tag>分治</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入底层-数据的按位运算</title>
    <link href="/2020/10/23/%E6%B7%B1%E5%85%A5%E5%BA%95%E5%B1%82-%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8C%89%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <url>/2020/10/23/%E6%B7%B1%E5%85%A5%E5%BA%95%E5%B1%82-%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8C%89%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h1 id="深入底层——数据的按位运算"><a href="#深入底层——数据的按位运算" class="headerlink" title="深入底层——数据的按位运算"></a>深入底层——数据的按位运算</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>由于程序中的所有数在计算机内存中都是以二进制的形式储存的，因此要对这些数进行直接操作的话，只能按位来处理。不同于其他复杂的运算符，位运算消耗的时钟周期是最少的，因此如果要追求极致的效率，那么位运算是理想的选择。</p><h2 id="基本运算符及性质"><a href="#基本运算符及性质" class="headerlink" title="基本运算符及性质"></a>基本运算符及性质</h2><h3 id="与运算-amp"><a href="#与运算-amp" class="headerlink" title="与运算&amp;"></a>与运算&amp;</h3><p>”遇0清0，遇1不变“。只有两个二进制位都是1时运算后才为1，其他情况都为0。</p><p>与运算最常见地被用来清除数据的某些位数，或者用来判断某一位是否为1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//将0011的末位清0</span><br><span class="hljs-number">0011</span> &amp; <span class="hljs-number">0010</span> = <span class="hljs-number">0010</span>;<br><span class="hljs-comment">//判断x的第3位是否为1(index start from 0)</span><br><span class="hljs-keyword">if</span> x == <span class="hljs-number">1100</span>:<br>x &amp; <span class="hljs-number">1000</span> = <span class="hljs-number">1000</span>(not zero)<br><span class="hljs-keyword">if</span> x == <span class="hljs-number">0100</span>:<br>x &amp; <span class="hljs-number">1000</span> = <span class="hljs-number">0000</span>(zero)<br></code></pre></td></tr></table></figure><h3 id="或运算"><a href="#或运算" class="headerlink" title="或运算|"></a>或运算|</h3><p>“遇1置1，遇0不变”。只有两个二进制位都为0时运算后才为0，其他情况都为1。</p><p>或运算可以用来把某些位置为1，但更常用来将两个错位的数据合并起来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//合并1100 和 0011</span><br><span class="hljs-number">1100</span> | <span class="hljs-number">0011</span> = <span class="hljs-number">11111</span><br></code></pre></td></tr></table></figure><h3 id="非运算"><a href="#非运算" class="headerlink" title="非运算~"></a>非运算~</h3><p>将数据的每一位取反。常用来计算补码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//-1转化为0</span><br>~<span class="hljs-number">1111</span> = <span class="hljs-number">0000</span><br><span class="hljs-comment">//计算-1的补码</span><br>~<span class="hljs-number">1111</span> + <span class="hljs-number">1</span> = <span class="hljs-number">0001</span><br></code></pre></td></tr></table></figure><h3 id="异或运算"><a href="#异或运算" class="headerlink" title="异或运算^"></a>异或运算^</h3><p>如果两个二进制位不同，则结果为1，否则结果为0。</p><p>异或运算可以看成是不带进位的加法。</p><p>异或运算有一些很好的性质：</p><p>x ^ x  &#x3D; 0</p><p>x ^ 0 &#x3D; x</p><p>交换律：x ^ a ^ x &#x3D; x ^ x ^ a &#x3D; a</p><p>结合律：a ^ b ^ c &#x3D; a ^ (b ^ c)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//交换两个数（不能储存在同一个地址下）</span><br>x ^= y;<br>y ^= x;<br>x ^= y;<br><br><span class="hljs-comment">//找出藏在成对数据中的唯一数据</span><br><span class="hljs-comment">//如:1,1,2,3,3,4,4 -&gt; 2</span><br>a = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> i <span class="hljs-number">0</span> -&gt; length - <span class="hljs-number">1</span>:<br>a ^= <span class="hljs-built_in">array</span>[i];<br><span class="hljs-keyword">return</span> a;<br></code></pre></td></tr></table></figure><h3 id="左移-lt-lt"><a href="#左移-lt-lt" class="headerlink" title="左移&lt;&lt;"></a>左移&lt;&lt;</h3><p>将数据的二进制位依次左移，相当于乘2。也经常和与运算结合起来取出特定位置的数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">x * <span class="hljs-number">2</span> == x &lt;&lt; <span class="hljs-number">1</span>;<br><span class="hljs-comment">//取出x = 0101 1100的高4位</span><br>x &amp;= <span class="hljs-number">-1</span> &lt;&lt; <span class="hljs-number">4</span>;<br></code></pre></td></tr></table></figure><h3 id="右移-gt-gt"><a href="#右移-gt-gt" class="headerlink" title="右移&gt;&gt;"></a>右移&gt;&gt;</h3><p>将数据的二进制位依次右移，相当于除以2。右移又分为逻辑右移和算术右移，算术右移会根据最高位来补位。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">x / <span class="hljs-number">2</span> == x &gt;&gt; <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h2 id="题海拾贝"><a href="#题海拾贝" class="headerlink" title="题海拾贝"></a>题海拾贝</h2><h3 id="byteSwap"><a href="#byteSwap" class="headerlink" title="byteSwap"></a>byteSwap</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * byteSwap - swaps the nth byte and the mth byte</span><br><span class="hljs-comment"> *  Examples: byteSwap(0x12345678, 1, 3) = 0x56341278</span><br><span class="hljs-comment"> *            byteSwap(0xDEADBEEF, 0, 2) = 0xDEEFBEAD</span><br><span class="hljs-comment"> *  You may assume that 0 &lt;= n &lt;= 3, 0 &lt;= m &lt;= 3</span><br><span class="hljs-comment"> *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *  Max ops: 25</span><br><span class="hljs-comment"> *  Rating: 2</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">byteSwap</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m)</span><br>&#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * first get the bytes needed to swap: n_byte and m_byte, which </span><br><span class="hljs-comment">   * seperately present nth byte of x and mth byte of y.</span><br><span class="hljs-comment">   * then set y = n_byte ^ m_byte.</span><br><span class="hljs-comment">   * because y ^ n_byte = n_byte ^ m_byte ^ n_byte = m_byte,</span><br><span class="hljs-comment">   * same as y ^ m_byte, so x ^= y &lt;&lt; n will set nth byte to m_byte,</span><br><span class="hljs-comment">   * and x ^= y &lt;&lt; m will set mth byte to n_byte.</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-type">int</span> y = <span class="hljs-number">0</span>;<br>  n = n &lt;&lt; <span class="hljs-number">3</span>;<br>  m = m &lt;&lt; <span class="hljs-number">3</span>;<br>  y = <span class="hljs-number">0xff</span> &amp; ((x &gt;&gt; n) ^ (x &gt;&gt; m));<br>  x = x ^ (y &lt;&lt; n);<br>  x = x ^ (y &lt;&lt; m);<br>  <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><p>可见，异或运算有时也能用来<strong>存储</strong>好几个数据，比如y存储了x的第n个字节和第m个字节，这样在重新和原始的x进行异或运算时，重复的数据被抵消掉了，留下的就是交换后的数据。</p><h3 id="rotateRight"><a href="#rotateRight" class="headerlink" title="rotateRight"></a>rotateRight</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * rotateRight - Rotate x to the right by n</span><br><span class="hljs-comment"> *   Can assume that 0 &lt;= n &lt;= 31</span><br><span class="hljs-comment"> *   Examples: rotateRight(0x87654321,4) = 0x18765432</span><br><span class="hljs-comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt; !</span><br><span class="hljs-comment"> *   Max ops: 25</span><br><span class="hljs-comment"> *   Rating: 3 </span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">rotateRight</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> n)</span><br>&#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * x &gt;&gt; n presents the lower n bits, and (x ^ (x &gt;&gt; 31)) &lt;&lt; </span><br><span class="hljs-comment">   * (31 ^ n) &lt;&lt; 1 presents the higher 32 - n bits. In order to</span><br><span class="hljs-comment">   * clean the 1 generated by moving right, you can XOR the sign of </span><br><span class="hljs-comment">   * x.It&#x27;s x ^ (x &gt;&gt; 31)</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-keyword">return</span> (x &gt;&gt; n) ^ ((x ^ (x &gt;&gt; <span class="hljs-number">31</span>)) &lt;&lt; (<span class="hljs-number">31</span> ^ n) &lt;&lt; <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里要注意的是，&lt;&lt;的运算符优先级是高于^的，这里有一个很巧妙的处理方法：<code>(31 ^ n) &lt;&lt; 1</code>。因为如果要计算32 - n的话，如果使用补码来模拟减法运算，一则增加了运算符的个数，二则是，当n为0时，x &lt;&lt; 32会变成 x&lt;&lt;1。而31是$2^5 - 1$即11111, 和n异或运算后刚好把n中的1全部消除了，就相当于31-n。最后补上&lt;&lt;1 代表实际右移了32 - n步。</p><p>另一个处理巧妙的地方在于使用符号位处理掉了x&gt;&gt;n产生的补充位，如果x是负数，则x ^ x&gt;&gt;31会让x每一位存储1，在于x&gt;&gt;n的高位异或之后刚好抵消。如果x是正数则没有影响。</p><h3 id="logicalNeg"><a href="#logicalNeg" class="headerlink" title="logicalNeg"></a>logicalNeg</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * logicalNeg - implement the ! operator, using all of </span><br><span class="hljs-comment"> *              the legal operators except !</span><br><span class="hljs-comment"> *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1</span><br><span class="hljs-comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 12</span><br><span class="hljs-comment"> *   Rating: 4 </span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">logicalNeg</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span><br>&#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * If x == 0, then negX | x &gt;&gt; 31 = 0,</span><br><span class="hljs-comment">   * else it must be -1, so add 1 to the result is </span><br><span class="hljs-comment">   * the final answer.</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-keyword">return</span> (((~x + <span class="hljs-number">1</span>) | x) &gt;&gt; <span class="hljs-number">31</span>) + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>0 和 非0的区别</strong>刚好可以通过补码来体现：只有0和0x8000 0000的补码才等于它们本身，而补码和自身或运算之后，又只有非0的数符号位为1，因此根据这个特点就能轻松区别0和非0数了。</p><h3 id="isGreater"><a href="#isGreater" class="headerlink" title="isGreater"></a>isGreater</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * isGreater - if x &gt; y  then return 1, else return 0 </span><br><span class="hljs-comment"> *   Example: isGreater(4,5) = 0, isGreater(5,4) = 1</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 24</span><br><span class="hljs-comment"> *   Rating: 3</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">isGreater</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span><br>&#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * first, we can get the average of x and y with no overflow happening</span><br><span class="hljs-comment">   * by using the expression: (x &amp; y) + (x ^ y) &gt;&gt; 1.</span><br><span class="hljs-comment">   * Ideas as follows:</span><br><span class="hljs-comment">   * for these bits which are both 1 in x and y, then bits_x &amp; bits_y = average()</span><br><span class="hljs-comment">   * eg: bits_x = 0100, bits_y = 0100, then average = bits_x &amp; bits_y = 0100</span><br><span class="hljs-comment">   * for other bits, to get their average, we can use (bits_x ^ bits_y)&gt;&gt;1.</span><br><span class="hljs-comment">   * eg: bits_x = 0100 = 4, bits_y = 0010 = 2, then average = (0110)&gt;&gt;1 = 0011 = 3</span><br><span class="hljs-comment">   * So if we want to get the average of x and y, we can separate x and y to </span><br><span class="hljs-comment">   * the two conditions above and deal with them with certain operator, then </span><br><span class="hljs-comment">   * add them to get the correct result. Because this operation won&#x27;t generate carrying,</span><br><span class="hljs-comment">   * so the result won&#x27;t overflow.</span><br><span class="hljs-comment">   * </span><br><span class="hljs-comment">   * In addition, because the sign of x - y and (x - y)/2 are the same, so we can </span><br><span class="hljs-comment">   * get the sign of average(x , ~y), when x &gt; y, the sign is 0, else sign is 1,</span><br><span class="hljs-comment">   * so the result is !sign.</span><br><span class="hljs-comment">   * </span><br><span class="hljs-comment">  */</span><br>  y = ~y;<br>  <span class="hljs-keyword">return</span> !(((x &amp; y) + ((x ^ y) &gt;&gt; <span class="hljs-number">1</span>)) &gt;&gt; <span class="hljs-number">31</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这题的处理方法甚为巧妙，如果对两个数直接相减，则可能有溢出的风险，但如果换种方式求解其<strong>平均数</strong>，则不会发生溢出，这样两个数的大小就可以直接用符号位来判断了。</p><p>妙哉！（但还有个4步解题的，已经不是正常脑回路想得到的了… …）</p><h3 id="satAdd"><a href="#satAdd" class="headerlink" title="satAdd"></a>satAdd</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * satAdd - adds two numbers but when positive overflow occurs, returns</span><br><span class="hljs-comment"> *          maximum possible value, and when negative overflow occurs,</span><br><span class="hljs-comment"> *          it returns minimum positive value.</span><br><span class="hljs-comment"> *   Examples: satAdd(0x40000000,0x40000000) = 0x7fffffff</span><br><span class="hljs-comment"> *             satAdd(0x80000000,0xffffffff) = 0x80000000</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 30</span><br><span class="hljs-comment"> *   Rating: 4</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">satAdd</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span><br>&#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * if x + y overflow, then sum has different sign with x and y.</span><br><span class="hljs-comment">   * so if overflow, the value overFlow will be -1, overwise 0.</span><br><span class="hljs-comment">   * </span><br><span class="hljs-comment">   * In this case, if pos + pos = neg, then overFlow &lt;&lt; 31 will be </span><br><span class="hljs-comment">   * 0x80000000, and sum &gt;&gt; overFlow will be 0xfffffffff, and both XOR </span><br><span class="hljs-comment">   * will be 0x7fffffff. Same if neg + neg = pos.</span><br><span class="hljs-comment">   * </span><br><span class="hljs-comment">   * If not overflow, overFlow &lt;&lt; 31 is always 0, and sum &gt;&gt; overFlow is still</span><br><span class="hljs-comment">   * sum. So the result is not changed.</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-type">int</span> sum = x + y;<br>  <span class="hljs-type">int</span> overFlow = ((sum ^ x) &amp; (sum ^ y)) &gt;&gt; <span class="hljs-number">31</span>;<br>  <span class="hljs-keyword">return</span> (sum &gt;&gt; overFlow) ^ (overFlow &lt;&lt; <span class="hljs-number">31</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>也是运用异或运算来产生两个特殊的最大值和最小值。</p><h3 id="howManyBits"><a href="#howManyBits" class="headerlink" title="howManyBits"></a>howManyBits</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* howManyBits - return the minimum number of bits required to represent x in</span><br><span class="hljs-comment"> *             two&#x27;s complement</span><br><span class="hljs-comment"> *  Examples: howManyBits(12) = 5</span><br><span class="hljs-comment"> *            howManyBits(298) = 10</span><br><span class="hljs-comment"> *            howManyBits(-5) = 4</span><br><span class="hljs-comment"> *            howManyBits(0)  = 1</span><br><span class="hljs-comment"> *            howManyBits(-1) = 1</span><br><span class="hljs-comment"> *            howManyBits(0x80000000) = 32</span><br><span class="hljs-comment"> *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *  Max ops: 90</span><br><span class="hljs-comment"> *  Rating: 4</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">howManyBits</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span><br>&#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * To get the minimum bits needed by x, just get the first &#x27;1&#x27;</span><br><span class="hljs-comment">   * from high bit to low bit of x if x &gt; 0 or ~x if x &lt; 0.</span><br><span class="hljs-comment">   * </span><br><span class="hljs-comment">   * The main idea is binary search, first check the high 16 bits.</span><br><span class="hljs-comment">   * If it&#x27;s not 0, then x must &gt;= 2^16, else x must &lt; 2^16. Record </span><br><span class="hljs-comment">   * 16 in value.</span><br><span class="hljs-comment">   * then check the high 8 bits in the none zero zone of x. Loop </span><br><span class="hljs-comment">   * until the high 1 bit. Finally add all of the recorded values and the</span><br><span class="hljs-comment">   * sign bit to get the result.</span><br><span class="hljs-comment">   * </span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-type">int</span> b16, b8, b4, b2, b1, b0;<br>  <span class="hljs-type">int</span> sign = x &gt;&gt; <span class="hljs-number">31</span>;<br>  x ^= sign;<br><br>  b16 = !!(x &gt;&gt; <span class="hljs-number">16</span>) &lt;&lt; <span class="hljs-number">4</span>;<br>  x = x &gt;&gt; b16;<br>  b8 = !!(x &gt;&gt; <span class="hljs-number">8</span>) &lt;&lt; <span class="hljs-number">3</span>;<br>  x = x &gt;&gt; b8;<br>  b4 = !!(x &gt;&gt; <span class="hljs-number">4</span>) &lt;&lt; <span class="hljs-number">2</span>;<br>  x = x &gt;&gt; b4;<br>  b2 = !!(x &gt;&gt; <span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-number">1</span>;<br>  x = x &gt;&gt; b2;<br>  b1 = (x &gt;&gt; <span class="hljs-number">1</span>);<br>  x = x &gt;&gt; b1;<br>  b0 = x;<br>  <span class="hljs-keyword">return</span> b16 + b8 + b4 + b2 + b1 + b0 + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>二分查找</strong>在位运算中的运用。</p><p>要判断x的最高位1在什么位置，先在较高的半位查找，如果确定在上半区域，则在这个区域继续查找，直到区域只剩下1个二进制位。</p><p>具体方法见代码注释。</p><h3 id="ilog2"><a href="#ilog2" class="headerlink" title="ilog2"></a>ilog2</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * ilog2 - return floor(log base 2 of x), where x &gt; 0</span><br><span class="hljs-comment"> *   Example: ilog2(16) = 4</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 90</span><br><span class="hljs-comment"> *   Rating: 4</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">ilog2</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span><br>&#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * same idea as above problem</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-type">int</span> sum1, sum2, sum3, sum4, sum5;<br>  sum1 = (!!(x &gt;&gt; <span class="hljs-number">16</span>)) &lt;&lt; <span class="hljs-number">4</span>;<br>  x = x &gt;&gt; sum1;<br>  sum2 = (!!(x &gt;&gt; <span class="hljs-number">8</span>)) &lt;&lt; <span class="hljs-number">3</span>;<br>  x = x &gt;&gt; sum2;<br>  sum3 = (!!(x &gt;&gt; <span class="hljs-number">4</span>)) &lt;&lt; <span class="hljs-number">2</span>;<br>  x = x &gt;&gt; sum3;<br>  sum4 = (!!(x &gt;&gt; <span class="hljs-number">2</span>)) &lt;&lt; <span class="hljs-number">1</span>;<br>  x = x &gt;&gt; sum4;<br>  sum5 = (x &gt;&gt; <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">return</span> sum1 + sum2 + sum3 + sum4 + sum5;<br>&#125;<br></code></pre></td></tr></table></figure><p>上个题的举一反三。</p><h3 id="浮点数处理"><a href="#浮点数处理" class="headerlink" title="浮点数处理"></a>浮点数处理</h3><p>按照规则取出符号，阶码和尾码就好，在做除法时要考虑舍入的问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * float_half - Return bit-level equivalent of expression 0.5*f for</span><br><span class="hljs-comment"> *   floating point argument f.</span><br><span class="hljs-comment"> *   Both the argument and result are passed as unsigned int&#x27;s, but</span><br><span class="hljs-comment"> *   they are to be interpreted as the bit-level representation of</span><br><span class="hljs-comment"> *   single-precision floating point values.</span><br><span class="hljs-comment"> *   When argument is NaN, return argument</span><br><span class="hljs-comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span><br><span class="hljs-comment"> *   Max ops: 30</span><br><span class="hljs-comment"> *   Rating: 4</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-title function_">float_half</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> uf)</span><br>&#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * first get sign, exp digit and check if uf need to round off.</span><br><span class="hljs-comment">   * if uf = inf or nan, return uf</span><br><span class="hljs-comment">   * if exp = 0 or exp = 1, as well as uf is 0 or not format digit or </span><br><span class="hljs-comment">   * exp = 1, move left the addition of tail digit and the round bit.</span><br><span class="hljs-comment">   * and finally add the sign bit.</span><br><span class="hljs-comment">   * In other cases, DEC exp digit.</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-built_in">exp</span> = uf &amp; <span class="hljs-number">0xff800000</span>;<br>  <span class="hljs-type">unsigned</span> frac;<br>  <span class="hljs-type">unsigned</span> mask = <span class="hljs-number">0x7fffff</span>;<br>  <span class="hljs-type">unsigned</span> shift = <span class="hljs-number">1</span>;<br><br>  <span class="hljs-keyword">switch</span> (<span class="hljs-built_in">exp</span>)<br>  &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">0x7f800000</span>:<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">0xff800000</span>:<br>    <span class="hljs-keyword">return</span> uf;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">0x80000000</span>:<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">default</span>:<br>    <span class="hljs-keyword">switch</span> (sign_exp -= <span class="hljs-number">0x800000</span>)<br>    &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0x80000000</span>:<br>      mask = <span class="hljs-number">0xfffff</span>;<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>      shift = <span class="hljs-number">0</span>;<br>    &#125;<br>  &#125;<br><br>  frac = uf &amp; mask;<br>  frac = frac &gt;&gt; shift;<br><br>  <span class="hljs-keyword">switch</span> (uf &amp; <span class="hljs-number">3</span>)<br>  &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>    frac += shift;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> sign_exp | frac;<br>&#125;<br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * float_f2i - Return bit-level equivalent of expression (int) f</span><br><span class="hljs-comment"> *   for floating point argument f.</span><br><span class="hljs-comment"> *   Argument is passed as unsigned int, but</span><br><span class="hljs-comment"> *   it is to be interpreted as the bit-level representation of a</span><br><span class="hljs-comment"> *   single-precision floating point value.</span><br><span class="hljs-comment"> *   Anything out of range (including NaN and infinity) should return</span><br><span class="hljs-comment"> *   0x80000000u.</span><br><span class="hljs-comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span><br><span class="hljs-comment"> *   Max ops: 30</span><br><span class="hljs-comment"> *   Rating: 4</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">float_f2i</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> uf)</span><br>&#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * first get sign, exp and frac digit, then check if uf is over the range of</span><br><span class="hljs-comment">   * unsigned int and return the certain value.</span><br><span class="hljs-comment">   * If not, add the hidden bit and move left frac by 7 bit so that every bit </span><br><span class="hljs-comment">   * won&#x27;t lose even if the right steps of movement is maxinum -- 30.</span><br><span class="hljs-comment">   * Finally, return the result according the correct sign.</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-type">int</span> sign = uf &gt;&gt; <span class="hljs-number">31</span>;<br>  <span class="hljs-type">int</span> <span class="hljs-built_in">exp</span> = (uf &gt;&gt; <span class="hljs-number">23</span>) &amp; <span class="hljs-number">0xff</span>;<br>  <span class="hljs-type">int</span> frac = uf &amp; <span class="hljs-number">0x007fffff</span>;<br>  <span class="hljs-type">int</span> right = <span class="hljs-number">157</span> - <span class="hljs-built_in">exp</span>;<br>  <span class="hljs-type">int</span> <span class="hljs-built_in">abs</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">exp</span> &lt; <span class="hljs-number">127</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">exp</span> &gt; <span class="hljs-number">157</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0x80000000</span>;<br>  <span class="hljs-built_in">abs</span> = (<span class="hljs-number">0x40000000</span> + (frac &lt;&lt; <span class="hljs-number">7</span>)) &gt;&gt; right;<br>  <span class="hljs-keyword">if</span> (sign)<br>    <span class="hljs-keyword">return</span> -<span class="hljs-built_in">abs</span>;<br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>;<br>&#125;<br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * float_twice - Return bit-level equivalent of expression 2*f for</span><br><span class="hljs-comment"> *   floating point argument f.</span><br><span class="hljs-comment"> *   Both the argument and result are passed as unsigned int&#x27;s, but</span><br><span class="hljs-comment"> *   they are to be interpreted as the bit-level representation of</span><br><span class="hljs-comment"> *   single-precision floating point values.</span><br><span class="hljs-comment"> *   When argument is NaN, return argument</span><br><span class="hljs-comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span><br><span class="hljs-comment"> *   Max ops: 30</span><br><span class="hljs-comment"> *   Rating: 4</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-title function_">float_twice</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> uf)</span><br>&#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * first get exp and sign of uf, if exp is not 0, INC when exp is also </span><br><span class="hljs-comment">   * not 255.</span><br><span class="hljs-comment">   * else, it indicates that uf is 0 or not format digit, just double its </span><br><span class="hljs-comment">   * frac and return the result according the correct sign.</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-built_in">exp</span> = uf &amp; <span class="hljs-number">0x7f800000</span>;<br>  <span class="hljs-type">unsigned</span> sign = uf &amp; <span class="hljs-number">0x80000000</span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">exp</span>)<br>  &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">exp</span> != <span class="hljs-number">0x7f800000</span>)<br>      uf = uf + <span class="hljs-number">0x00800000</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>    uf = (uf &lt;&lt; <span class="hljs-number">1</span>) | sign;<br>  <span class="hljs-keyword">return</span> uf;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>位运算</category>
      
    </categories>
    
    
    <tags>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自底向上归并排序</title>
    <link href="/2020/10/08/%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <url>/2020/10/08/%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="自底向上归并排序"><a href="#自底向上归并排序" class="headerlink" title="自底向上归并排序"></a>自底向上归并排序</h1><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p>给定一个无序的数组，要求使用自底向上的方法将数据进行从大到小的排序。</p><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] A = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">9</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>&#125;;   <span class="hljs-comment">//6个元素</span><br>A = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;         <span class="hljs-comment">//排序后的结果</span><br><br><span class="hljs-comment">//排序过程</span><br><span class="hljs-comment">//1. 将元素分成6组</span><br><span class="hljs-comment">//A：2  3  6  9  5  8</span><br><span class="hljs-comment">//2. 每两个两个地合并为一组</span><br><span class="hljs-comment">//A：2,3 6,9 5,8</span><br><span class="hljs-comment">//3. 每两组再合并为新的一组</span><br><span class="hljs-comment">//A：2,3,6,9 5,8</span><br><span class="hljs-comment">//4. 重复以上步骤，发现只剩一个组，排序完成</span><br><span class="hljs-comment">//A：2,3,5,6,8,9</span><br></code></pre></td></tr></table></figure><h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>该算法需要分成两个步骤：拆分和归并，如果使用递归的方法，则拆分可以在递归时完成，即如果数组的长度不为1，就继续拆分下去。</p><p>而如果使用自底向上方法的话，需要时刻跟踪当前存在的组数，每个组所含的元素的数量；归并方法可以使用另外的函数来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//伪代码</span><br><span class="hljs-comment">//先实现合并方法</span><br>merge(A[], startOfFirst, endOfFirst, endOfSecond)&#123;<br>    B[endOfSecond - startOfFirst + <span class="hljs-number">1</span>];     <span class="hljs-comment">//辅助数组</span><br>    <span class="hljs-type">int</span> index1, index2,indexOfB;<br>    index1 = startOfFirst;<br>    index2 = endOfFirst + <span class="hljs-number">1</span>;<br>    indexOfB = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(index1 &lt;= endOfFirst &amp;&amp; index2 &lt;= endOfSecond)&#123;<br>        <span class="hljs-keyword">if</span>(A[index1] &gt; A[index2])&#123;<br>            B[indexOfB] = A[index2];<br>            index2++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ...<br>        &#125;<br>        indexOfB++;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(index1 &gt; endOfFirst)&#123;  <span class="hljs-comment">//后一个数组的元素还没有遍历完</span><br>        <span class="hljs-keyword">while</span>(index2 &lt;= endOfSecond)&#123;<br>            B[indexOfB] = A[index2];<br>            indexOfB++;index2++;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        ...<br>    &#125;<br>    index1 = startOfFirst;<br>    index2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(;index2 &lt; B.length; index2++, index1++)&#123;<br>        A[index1] = B[index2];<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><br><span class="hljs-comment">//实现自底向上排序</span><br>bottomUpSort(A[])&#123;<br>    <span class="hljs-comment">//A的最大长度，当前每组的大小，合并后的新组的最大长度</span><br>    <span class="hljs-comment">//当组的长度超过或者等于A的长度时，结束循环</span><br>    length = A.length;<br>    currentSize = <span class="hljs-number">1</span>;<br>    nextSize = currentSize * <span class="hljs-number">2</span>;<br>    index = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span>(currentSize &lt; length)&#123;<br>        <span class="hljs-keyword">for</span>(index = <span class="hljs-number">0</span>; index + nextSize - <span class="hljs-number">1</span> &lt; length; index += nextSize)&#123;<br>            merge(index, index + currentSize - <span class="hljs-number">1</span>, index + nextSize - <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-comment">//考虑length%nextSize &gt; currentSize</span><br>        <span class="hljs-keyword">if</span>(...)&#123;<br>            merge(index, index + currentSize - <span class="hljs-number">1</span>, length - <span class="hljs-number">1</span>);<br>        &#125;<br>        currentSize = nextSize;<br>        nextSize = currentSize * <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串和正则表达式</title>
    <link href="/2020/09/25/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2020/09/25/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="Strings-Characters-and-Regular-Expressions"><a href="#Strings-Characters-and-Regular-Expressions" class="headerlink" title="Strings, Characters and Regular Expressions"></a>Strings, Characters and Regular Expressions</h1><h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><h3 id="构造String"><a href="#构造String" class="headerlink" title="构造String"></a>构造String</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>();<br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(s1);           <span class="hljs-comment">//通过拷贝构造</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(charArray);    <span class="hljs-comment">//通过字符数组构造</span><br></code></pre></td></tr></table></figure><h3 id="非静态方法"><a href="#非静态方法" class="headerlink" title="非静态方法"></a>非静态方法</h3><ul><li><p>s1.length()</p></li><li><p>s1.charAt(index)  &#x2F;&#x2F;输出某个指定下标的字符</p></li><li><p>s1.getChars(0, 5, charArray, 0);  &#x2F;&#x2F;将子串输出到字符数组中</p></li><li><p>s1.equals(s2)  &#x2F;&#x2F;判断是否相等</p></li><li><p>s1.equalsIgnore(s2)  &#x2F;&#x2F;忽略大小写后判断是否相等，等价于s1.toLowerCase().equals(s2.toLowerCase())</p></li><li><p>s1.compareTo(s2)  &#x2F;&#x2F;按照字典序比较字符串的大小</p></li><li><p>s1.regionMatches(0, s2, 0, 5)    &#x2F;&#x2F;局部匹配，如果前5个字符相同则返回true</p></li><li><p>s1.regionMatches(true, 0, s2, 0, 5);  &#x2F;&#x2F;局部匹配，但是忽略大小写</p></li><li><p>s1.startsWith(s2)  &#x2F;&#x2F;是否以s2开头</p></li><li><p>s1.endsWith(s2)  &#x2F;&#x2F;是否以s2结尾</p></li><li><p>s1.indexOf(char)  &#x2F;&#x2F;首个指定字符的下标，不存在则返回-1</p></li><li><p>s1.indexOf(char, i)  &#x2F;&#x2F;从第i个字符之后的首个指定字符的下标</p></li><li><p>s1.lastIndexOf(char)   &#x2F;&#x2F;末个指定字符的下标，不存在则返回-1</p></li><li><p>s1.lastIndexOf(char, i)  &#x2F;&#x2F;从第i个字符之后的末个指定字符的下标</p></li><li><p>s1.indexOf(str)</p></li><li><p>…</p></li><li><p>s1.substring(fromIndex)   &#x2F;&#x2F;从第fromIndex到最后的字符串</p></li><li><p>s1.substring(fromindex, endindex) &#x2F;&#x2F;[fromindex, endindex)</p></li><li><p>s1.concat(s2)  &#x2F;&#x2F;连接字符串</p></li><li><p>s1.replace(‘l’, ‘L’)   &#x2F;&#x2F;取代字符串中所有的l</p></li><li><p>s1.toUpperCase()</p></li><li><p>s1.toLowerCase()</p></li><li><p>s1.trim()  &#x2F;&#x2F;去掉首尾的空格</p></li><li><p>s1.toCharArray()  &#x2F;&#x2F;字符串转换为字符数组</p></li></ul><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><ul><li>String.valueOf(charArray)  &#x2F;&#x2F;将字符数组转化为字符串</li><li>String.valueOf(charArray, 2, 2)  &#x2F;&#x2F;输出从下标2开始长度为2的字符串</li><li>String.valueOf(integerVal, longVal, booleanVal,…)  &#x2F;&#x2F;将基本类型转换为字符串输出</li></ul><h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><ul><li>sentence.split(“ “) &#x2F;&#x2F;根据空格将句子分成很多个单词，返回一个字符串数组</li></ul><h3 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h3><p>可修改的String</p><p>构造同String</p><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><p>大部分String能用的StringBuilder都能用</p><ul><li>buffer.length()</li><li>buffer.capacity()</li><li>buffer.ensureCapacity(number)</li><li>buffer.setLength(number)</li><li>buffer.setCharAt(index, char)</li><li>buffer.append(String)</li><li>buffer.insert(index, string)  &#x2F;&#x2F;在index之前插入string</li></ul><h2 id="Character类"><a href="#Character类" class="headerlink" title="Character类"></a>Character类</h2><h3 id="静态方法-1"><a href="#静态方法-1" class="headerlink" title="静态方法"></a>静态方法</h3><ul><li>Character.isDefined(c)  &#x2F;&#x2F;该字符是否被定义</li><li>Character.isDigit(c)</li><li>Character.isJavaIdentifierStart(c)  &#x2F;&#x2F;是否是合法的Java首字符</li><li>Character.isJavaIdentifierPart(c)  &#x2F;&#x2F;是否是合法的Java字符</li><li>Character.isLetter(c)</li><li>Character.isLetterOrDigit(c)</li><li>Character.isLowerCase(c)</li><li>Character.isUpperCase(c)</li><li>Character.toUpperCase(c)</li><li>Character.toLowerCase(c)</li><li>Character.forDigit(digit, radix)  &#x2F;&#x2F;radix进制下，将数digit转换为字符</li><li>Character.digit(character, radix)  &#x2F;&#x2F;将character转换成radix进制数</li></ul><h3 id="非静态方法-1"><a href="#非静态方法-1" class="headerlink" title="非静态方法"></a>非静态方法</h3><ul><li>c1.charValue() &#x2F;&#x2F;转换成char</li><li>c1.toString()</li></ul><h2 id="正则表达式，Pattern类和Matcher类"><a href="#正则表达式，Pattern类和Matcher类" class="headerlink" title="正则表达式，Pattern类和Matcher类"></a>正则表达式，Pattern类和Matcher类</h2><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p><strong>Predefined character classes</strong></p><table><thead><tr><th>Character</th><th>Matches</th></tr></thead><tbody><tr><td>\d</td><td>any digit</td></tr><tr><td>\w</td><td>any word character</td></tr><tr><td>\s</td><td>any white-space character</td></tr><tr><td>\D</td><td>any nondigit</td></tr><tr><td>\W</td><td>any nonword character</td></tr><tr><td>\S</td><td>any non-whitespace character</td></tr></tbody></table><p><strong>Quantifiers used in regular expressions</strong></p><table><thead><tr><th>Quantifier</th><th>Matches</th></tr></thead><tbody><tr><td>*</td><td>zero or more pre-character</td></tr><tr><td>+</td><td>one or more pre-character</td></tr><tr><td>^</td><td>not match character</td></tr><tr><td>()</td><td>have or not have</td></tr><tr><td>|</td><td>or</td></tr><tr><td>d{5}</td><td>match five digits</td></tr><tr><td>d{5,}</td><td>match five or more digits</td></tr><tr><td>d{5,6}</td><td>match five to six digits</td></tr><tr><td>?</td><td>match zero or one pre-character</td></tr><tr><td>.</td><td>dot, match any singer character except a new-line character</td></tr><tr><td>[]</td><td>match only-one given character</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><h4 id="Pattern类和Matcher类"><a href="#Pattern类和Matcher类" class="headerlink" title="Pattern类和Matcher类"></a><strong>Pattern类和Matcher类</strong></h4><p><strong>Pattern：</strong></p><p>用来存储一个正则表达式</p><p>声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Pattern</span> <span class="hljs-variable">expression</span> <span class="hljs-operator">=</span> Pattern.compile(<span class="hljs-string">&quot;J.*\\d[0-35-9]-\\d\\d-\\d\\d&quot;</span>);<br></code></pre></td></tr></table></figure><p><strong>Matcher：</strong></p><p>既包含一个正则表达式的Pattern，也包含一个用来查找Pattern的CharSequence</p><p>声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Matcher</span> <span class="hljs-variable">matcher</span> <span class="hljs-operator">=</span> expression.matcher(string1);<br></code></pre></td></tr></table></figure><p>使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(matcher.find())&#123;<br>    System.out.println(matcher.group());<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>字符串</tag>
      
      <tag>正则表达式</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
